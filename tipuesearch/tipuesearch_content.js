var tipuesearch = {"pages":[{"title":" libfdf ","text":"libfdf The library provides an API for flexible input  handling for Fortran \nprograms. For more information, check out the Overview . Developer Info Alberto Garcia, Nick Papior, Raul de la Cruz","tags":"home","loc":"index.html"},{"title":"parsed_line – libfdf ","text":"type, public :: parsed_line Contents Variables ntokens line first last id Components Type Visibility Attributes Name Initial integer(kind=ip), public :: ntokens character(len=MAX_LENGTH), public :: line integer(kind=ip), public :: first (MAX_NTOKENS) integer(kind=ip), public :: last (MAX_NTOKENS) character(len=1), public :: id (MAX_NTOKENS)","tags":"","loc":"type/parsed_line.html"},{"title":"block_fdf – libfdf ","text":"type, public :: block_fdf Contents Variables label mark Components Type Visibility Attributes Name Initial character(len=MAX_LENGTH), public :: label type( line_dlist ), public, pointer :: mark => null()","tags":"","loc":"type/block_fdf.html"},{"title":"line_dlist – libfdf ","text":"type, public :: line_dlist Contents Variables str pline next prev Components Type Visibility Attributes Name Initial character(len=MAX_LENGTH), public :: str type( parsed_line ), public, pointer :: pline => null() type( line_dlist ), public, pointer :: next => null() type( line_dlist ), public, pointer :: prev => null()","tags":"","loc":"type/line_dlist.html"},{"title":"fdf_file – libfdf ","text":"type, private :: fdf_file Contents Variables nlines first last Components Type Visibility Attributes Name Initial integer(kind=ip), public :: nlines type( line_dlist ), public, pointer :: first => null() type( line_dlist ), public, pointer :: last => null()","tags":"","loc":"type/fdf_file.html"},{"title":"fdf_set_started – libfdf","text":"subroutine fdf_set_started(status) Arguments Type Intent Optional Attributes Name logical, intent(in) :: status Contents","tags":"","loc":"proc/fdf_set_started.html"},{"title":"fdf_isblock – libfdf","text":"function fdf_isblock(label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Return Value logical Contents","tags":"","loc":"proc/fdf_isblock.html"},{"title":"fdf_obsolete – libfdf","text":"subroutine fdf_obsolete(label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Contents","tags":"","loc":"proc/fdf_obsolete.html"},{"title":"fdf_islist – libfdf","text":"function fdf_islist(label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Return Value logical Contents","tags":"","loc":"proc/fdf_islist.html"},{"title":"fdf_dump – libfdf","text":"subroutine fdf_dump(label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Contents","tags":"","loc":"proc/fdf_dump.html"},{"title":"fdf_addline – libfdf","text":"subroutine fdf_addline(line) Arguments Type Intent Optional Attributes Name character(len=*) :: line Contents","tags":"","loc":"proc/fdf_addline.html"},{"title":"fdf_searchlabel – libfdf","text":"function fdf_searchlabel(found, nelem, label, plabel) Arguments Type Intent Optional Attributes Name logical :: found (nelem) integer(kind=ip) :: nelem character(len=*) :: label type(parsed_line), pointer :: plabel Return Value integer(kind=ip) Contents","tags":"","loc":"proc/fdf_searchlabel.html"},{"title":"fdf_double – libfdf","text":"function fdf_double(label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label real(kind=dp) :: default type(line_dlist), optional, pointer :: line Return Value real(kind=dp) Contents","tags":"","loc":"proc/fdf_double.html"},{"title":"set_file_names – libfdf","text":"subroutine set_file_names(fileIn, fileOut, optFileIn, optFileOut, unitIn) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: fileIn character(len=*), intent(out) :: fileOut character(len=*), intent(in), optional :: optFileIn character(len=*), intent(in), optional :: optFileOut integer, intent(in), optional :: unitIn Contents","tags":"","loc":"proc/set_file_names.html"},{"title":"fdf_destroy – libfdf","text":"subroutine fdf_destroy(fdfp) Arguments Type Intent Optional Attributes Name type(fdf_file) :: fdfp Contents","tags":"","loc":"proc/fdf_destroy.html"},{"title":"fdf_shutdown – libfdf","text":"subroutine fdf_shutdown() Arguments None Contents None","tags":"","loc":"proc/fdf_shutdown.html"},{"title":"fdf_defined – libfdf","text":"function fdf_defined(label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Return Value logical Contents","tags":"","loc":"proc/fdf_defined.html"},{"title":"fdf_integer – libfdf","text":"function fdf_integer(label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label integer(kind=ip) :: default type(line_dlist), optional, pointer :: line Return Value integer(kind=ip) Contents","tags":"","loc":"proc/fdf_integer.html"},{"title":"fdf_removelabel – libfdf","text":"subroutine fdf_removelabel(label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Contents","tags":"","loc":"proc/fdf_removelabel.html"},{"title":"fdf_recreate_struct – libfdf","text":"subroutine fdf_recreate_struct(bufferFDF) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: bufferFDF (:) Contents","tags":"","loc":"proc/fdf_recreate_struct.html"},{"title":"fdf_bline – libfdf","text":"function fdf_bline(bfdf, pline) Arguments Type Intent Optional Attributes Name type(block_fdf) :: bfdf type(parsed_line), pointer :: pline Return Value logical Contents","tags":"","loc":"proc/fdf_bline.html"},{"title":"is_false – libfdf","text":"function is_false(valstr) result(a) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: valstr Return Value logical Contents","tags":"","loc":"proc/is_false.html"},{"title":"fdf_printfdf – libfdf","text":"subroutine fdf_printfdf() Arguments None Contents None","tags":"","loc":"proc/fdf_printfdf.html"},{"title":"fdf_islinteger – libfdf","text":"function fdf_islinteger(label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Return Value logical Contents","tags":"","loc":"proc/fdf_islinteger.html"},{"title":"fdf_setdebug – libfdf","text":"subroutine fdf_setdebug(level, filedebug) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: level character(len=*) :: filedebug Contents","tags":"","loc":"proc/fdf_setdebug.html"},{"title":"fdf_block – libfdf","text":"function fdf_block(label, bfdf) Arguments Type Intent Optional Attributes Name character(len=*) :: label type(block_fdf) :: bfdf Return Value logical Contents","tags":"","loc":"proc/fdf_block.html"},{"title":"fdf_overwrite – libfdf","text":"subroutine fdf_overwrite(line) Arguments Type Intent Optional Attributes Name character(len=*) :: line Contents","tags":"","loc":"proc/fdf_overwrite.html"},{"title":"fdf_serialize_struct – libfdf","text":"subroutine fdf_serialize_struct(buffer) Arguments Type Intent Optional Attributes Name character(len=1), intent(inout), allocatable :: buffer (:) Contents","tags":"","loc":"proc/fdf_serialize_struct.html"},{"title":"fdf_block_linecount – libfdf","text":"function fdf_block_linecount(label, morph) Arguments Type Intent Optional Attributes Name character(len=*) :: label character(len=*), optional :: morph Return Value integer(kind=ip) Contents","tags":"","loc":"proc/fdf_block_linecount.html"},{"title":"fdf_read – libfdf","text":"recursive subroutine fdf_read(filein, blocklabel) Arguments Type Intent Optional Attributes Name character(len=*) :: filein character(len=*), optional :: blocklabel Contents","tags":"","loc":"proc/fdf_read.html"},{"title":"fdf_initdata – libfdf","text":"subroutine fdf_initdata() Arguments None Contents None","tags":"","loc":"proc/fdf_initdata.html"},{"title":"fdf_ldouble – libfdf","text":"subroutine fdf_ldouble(label, nv, list, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label integer(kind=ip) :: nv real(kind=dp) :: list (nv) type(line_dlist), optional, pointer :: line Contents","tags":"","loc":"proc/fdf_ldouble.html"},{"title":"fdf_deprecated – libfdf","text":"subroutine fdf_deprecated(label, newlabel) Arguments Type Intent Optional Attributes Name character(len=*) :: label character(len=*) :: newlabel Contents","tags":"","loc":"proc/fdf_deprecated.html"},{"title":"fdf_linteger – libfdf","text":"subroutine fdf_linteger(label, ni, list, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label integer(kind=ip) :: ni integer(kind=ip) :: list (ni) type(line_dlist), optional, pointer :: line Contents","tags":"","loc":"proc/fdf_linteger.html"},{"title":"fdf_set_output_file – libfdf","text":"subroutine fdf_set_output_file(fileout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fileout Contents","tags":"","loc":"proc/fdf_set_output_file.html"},{"title":"fdf_bphysical – libfdf","text":"function fdf_bphysical(pline, defunit, after) Arguments Type Intent Optional Attributes Name type(parsed_line), pointer :: pline character(len=*) :: defunit integer(kind=ip), intent(in), optional :: after Return Value real(kind=dp) Contents","tags":"","loc":"proc/fdf_bphysical.html"},{"title":"fdf_string – libfdf","text":"function fdf_string(label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label character(len=*) :: default type(line_dlist), optional, pointer :: line Return Value character(len=80) Contents","tags":"","loc":"proc/fdf_string.html"},{"title":"fdf_convfac – libfdf","text":"function fdf_convfac(from, to) Arguments Type Intent Optional Attributes Name character(len=*) :: from character(len=*) :: to Return Value real(kind=dp) Contents","tags":"","loc":"proc/fdf_convfac.html"},{"title":"fdf_readline – libfdf","text":"function fdf_readline(line) Uses m_read Arguments Type Intent Optional Attributes Name character(len=:), intent(out), allocatable :: line Return Value logical Contents","tags":"","loc":"proc/fdf_readline.html"},{"title":"fdf_locate – libfdf","text":"function fdf_locate(label, mark) Arguments Type Intent Optional Attributes Name character(len=*) :: label type(line_dlist), pointer :: mark Return Value logical Contents","tags":"","loc":"proc/fdf_locate.html"},{"title":"fdf_open – libfdf","text":"subroutine fdf_open(filename) Arguments Type Intent Optional Attributes Name character(len=*) :: filename Contents","tags":"","loc":"proc/fdf_open.html"},{"title":"fdf_input – libfdf","text":"subroutine fdf_input(filein) Arguments Type Intent Optional Attributes Name character(len=*) :: filein Contents","tags":"","loc":"proc/fdf_input.html"},{"title":"fdf_bclose – libfdf","text":"subroutine fdf_bclose(bfdf) Arguments Type Intent Optional Attributes Name type(block_fdf) :: bfdf Contents","tags":"","loc":"proc/fdf_bclose.html"},{"title":"fdf_single – libfdf","text":"function fdf_single(label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label real(kind=sp) :: default type(line_dlist), optional, pointer :: line Return Value real(kind=sp) Contents","tags":"","loc":"proc/fdf_single.html"},{"title":"fdf_physical – libfdf","text":"function fdf_physical(label, default, defunit, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label real(kind=dp) :: default character(len=*) :: defunit type(line_dlist), optional, pointer :: line Return Value real(kind=dp) Contents","tags":"","loc":"proc/fdf_physical.html"},{"title":"fdf_addtoken – libfdf","text":"subroutine fdf_addtoken(line, pline) Arguments Type Intent Optional Attributes Name character(len=*) :: line type(parsed_line), pointer :: pline Contents","tags":"","loc":"proc/fdf_addtoken.html"},{"title":"fdf_isphysical – libfdf","text":"function fdf_isphysical(label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Return Value logical Contents","tags":"","loc":"proc/fdf_isphysical.html"},{"title":"fdf_brewind – libfdf","text":"subroutine fdf_brewind(bfdf) Arguments Type Intent Optional Attributes Name type(block_fdf) :: bfdf Contents","tags":"","loc":"proc/fdf_brewind.html"},{"title":"fdf_islreal – libfdf","text":"function fdf_islreal(label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Return Value logical Contents","tags":"","loc":"proc/fdf_islreal.html"},{"title":"fdf_setoutput – libfdf","text":"subroutine fdf_setoutput(level, fileout_in) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: level character(len=*), intent(in) :: fileout_in Contents","tags":"","loc":"proc/fdf_setoutput.html"},{"title":"fdf_readlabel – libfdf","text":"recursive function fdf_readlabel(nelem, plabel, filein, found) result(readlabel) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: nelem type(parsed_line), pointer :: plabel character(len=*) :: filein logical :: found (nelem) Return Value logical Contents","tags":"","loc":"proc/fdf_readlabel.html"},{"title":"fdf_bbackspace – libfdf","text":"function fdf_bbackspace(bfdf, pline) Arguments Type Intent Optional Attributes Name type(block_fdf) :: bfdf type(parsed_line), optional, pointer :: pline Return Value logical Contents","tags":"","loc":"proc/fdf_bbackspace.html"},{"title":"fdf_close – libfdf","text":"subroutine fdf_close() Arguments None Contents None","tags":"","loc":"proc/fdf_close.html"},{"title":"leqi – libfdf","text":"public  function leqi(string1, string2) Arguments Type Intent Optional Attributes Name character(len=*) :: string1 character(len=*) :: string2 Return Value logical Contents","tags":"","loc":"proc/leqi.html"},{"title":"leqi_strict – libfdf","text":"public  function leqi_strict(str1, str2) Arguments Type Intent Optional Attributes Name character(len=*) :: str1 character(len=*) :: str2 Return Value logical Contents","tags":"","loc":"proc/leqi_strict.html"},{"title":"labeleq – libfdf","text":"public  function labeleq(s1, s2, logunit) Arguments Type Intent Optional Attributes Name character(len=*) :: s1 character(len=*) :: s2 integer(kind=ip), optional :: logunit Return Value logical Contents","tags":"","loc":"proc/labeleq.html"},{"title":"s2i – libfdf","text":"public  function s2i(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value integer(kind=ip) Contents","tags":"","loc":"proc/s2i.html"},{"title":"s2r – libfdf","text":"public  function s2r(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value real(kind=dp) Contents","tags":"","loc":"proc/s2r.html"},{"title":"arr2s – libfdf","text":"public  function arr2s(string_arr, string_size) Arguments Type Intent Optional Attributes Name character(len=1) :: string_arr (*) integer(kind=ip) :: string_size Return Value character(len=MAX_LENGTH) Contents","tags":"","loc":"proc/arr2s.html"},{"title":"s2arr – libfdf","text":"public  function s2arr(string) Arguments Type Intent Optional Attributes Name character(len=*) :: string Return Value character(len=1), (MAX_LENGTH) Contents","tags":"","loc":"proc/s2arr.html"},{"title":"i2s – libfdf","text":"public  function i2s(num) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: num Return Value character(len=5) Contents","tags":"","loc":"proc/i2s.html"},{"title":"packlabel – libfdf","text":"public  subroutine packlabel(s, n) Arguments Type Intent Optional Attributes Name character(len=*) :: s character(len=*) :: n Contents","tags":"","loc":"proc/packlabel.html"},{"title":"chrcap – libfdf","text":"public  subroutine chrcap(string, nchar) Arguments Type Intent Optional Attributes Name character(len=*) :: string integer(kind=ip) :: nchar Contents","tags":"","loc":"proc/chrcap.html"},{"title":"chrlen – libfdf","text":"public  subroutine chrlen(string, nchar, lchar) Arguments Type Intent Optional Attributes Name character(len=*) :: string integer(kind=ip) :: nchar integer(kind=ip) :: lchar Contents","tags":"","loc":"proc/chrlen.html"},{"title":"convert_string_to_array_of_chars – libfdf","text":"public  subroutine convert_string_to_array_of_chars(str, arr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=1), intent(out), dimension(:) :: arr Contents","tags":"","loc":"proc/convert_string_to_array_of_chars.html"},{"title":"convert_array_of_chars_to_string – libfdf","text":"public  subroutine convert_array_of_chars_to_string(arr, str) Arguments Type Intent Optional Attributes Name character(len=1), intent(in), dimension(:) :: arr character(len=*), intent(out) :: str Contents","tags":"","loc":"proc/convert_array_of_chars_to_string.html"},{"title":"warn – libfdf","text":"public  subroutine warn(string) Arguments Type Intent Optional Attributes Name character(len=*) :: string Contents","tags":"","loc":"proc/warn.html"},{"title":"die – libfdf","text":"public  subroutine die(routine, msg, file, line, unit, rc, cline) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: routine character(len=*), intent(in) :: msg character(len=*), intent(in), optional :: file integer(kind=ip), intent(in), optional :: line integer(kind=ip), intent(in), optional :: unit integer(kind=ip), intent(in), optional :: rc character(len=*), intent(in), optional :: cline Contents","tags":"","loc":"proc/die.html"},{"title":"io_seterr – libfdf","text":"public  subroutine io_seterr(unit) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout) :: unit Contents","tags":"","loc":"proc/io_seterr.html"},{"title":"io_setout – libfdf","text":"public  subroutine io_setout(unit) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout) :: unit Contents","tags":"","loc":"proc/io_setout.html"},{"title":"io_geterr – libfdf","text":"public  subroutine io_geterr(unit) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout) :: unit Contents","tags":"","loc":"proc/io_geterr.html"},{"title":"io_getout – libfdf","text":"public  subroutine io_getout(unit) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout) :: unit Contents","tags":"","loc":"proc/io_getout.html"},{"title":"io_assign – libfdf","text":"public  subroutine io_assign(lun) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout) :: lun Contents","tags":"","loc":"proc/io_assign.html"},{"title":"io_reserve – libfdf","text":"public  subroutine io_reserve(lun) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout) :: lun Contents","tags":"","loc":"proc/io_reserve.html"},{"title":"io_close – libfdf","text":"public  subroutine io_close(lun) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout) :: lun Contents","tags":"","loc":"proc/io_close.html"},{"title":"io_status – libfdf","text":"public  subroutine io_status() Arguments None Contents None","tags":"","loc":"proc/io_status.html"},{"title":"nitems – libfdf","text":"public  function nitems(class, pline, after) Arguments Type Intent Optional Attributes Name character(len=1) :: class type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) Contents","tags":"","loc":"proc/nitems.html"},{"title":"nintegers – libfdf","text":"public  function nintegers(pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) Contents","tags":"","loc":"proc/nintegers.html"},{"title":"nreals – libfdf","text":"public  function nreals(pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) Contents","tags":"","loc":"proc/nreals.html"},{"title":"nvalues – libfdf","text":"public  function nvalues(pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) Contents","tags":"","loc":"proc/nvalues.html"},{"title":"nlists – libfdf","text":"public  function nlists(pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) Contents","tags":"","loc":"proc/nlists.html"},{"title":"nintegerlists – libfdf","text":"public  function nintegerlists(pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) Contents","tags":"","loc":"proc/nintegerlists.html"},{"title":"nreallists – libfdf","text":"public  function nreallists(pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) Contents","tags":"","loc":"proc/nreallists.html"},{"title":"nnames – libfdf","text":"public  function nnames(pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) Contents","tags":"","loc":"proc/nnames.html"},{"title":"nblocks – libfdf","text":"public  function nblocks(pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) Contents","tags":"","loc":"proc/nblocks.html"},{"title":"nendblocks – libfdf","text":"public  function nendblocks(pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) Contents","tags":"","loc":"proc/nendblocks.html"},{"title":"nlabels – libfdf","text":"public  function nlabels(pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) Contents","tags":"","loc":"proc/nlabels.html"},{"title":"ntokens – libfdf","text":"public  function ntokens(pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) Contents","tags":"","loc":"proc/ntokens.html"},{"title":"integers – libfdf","text":"public  function integers(pline, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) Contents","tags":"","loc":"proc/integers.html"},{"title":"reals – libfdf","text":"public  function reals(pline, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip), intent(in), optional :: after Return Value real(kind=dp) Contents","tags":"","loc":"proc/reals.html"},{"title":"values – libfdf","text":"public  function values(pline, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip), intent(in), optional :: after Return Value real(kind=dp) Contents","tags":"","loc":"proc/values.html"},{"title":"names – libfdf","text":"public  function names(pline, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip), intent(in), optional :: after Return Value character(len=MAX_LENGTH) Contents","tags":"","loc":"proc/names.html"},{"title":"blocks – libfdf","text":"public  function blocks(pline) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline Return Value character(len=MAX_LENGTH) Contents","tags":"","loc":"proc/blocks.html"},{"title":"endblocks – libfdf","text":"public  function endblocks(pline) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline Return Value character(len=MAX_LENGTH) Contents","tags":"","loc":"proc/endblocks.html"},{"title":"labels – libfdf","text":"public  function labels(pline) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline Return Value character(len=MAX_LENGTH) Contents","tags":"","loc":"proc/labels.html"},{"title":"tokens – libfdf","text":"public  function tokens(pline, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip), intent(in), optional :: after Return Value character(len=MAX_LENGTH) Contents","tags":"","loc":"proc/tokens.html"},{"title":"characters – libfdf","text":"public  function characters(pline, ind_init, ind_final, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind_init integer(kind=ip), intent(in) :: ind_final integer(kind=ip), intent(in), optional :: after Return Value character(len=MAX_LENGTH) Contents","tags":"","loc":"proc/characters.html"},{"title":"digest – libfdf","text":"public  function digest(line) result(pline) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value type( parsed_line ), pointer Contents","tags":"","loc":"proc/digest.html"},{"title":"search_fun – libfdf","text":"public  function search_fun(string, pline_fun, after, eq_func) Arguments Type Intent Optional Attributes Name character(len=*) :: string type( parsed_line ), pointer :: pline_fun integer(kind=ip), intent(in), optional :: after public  function eq_func(s1, s2) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s1 character(len=*), intent(in) :: s2 Return Value logical Return Value integer(kind=ip) Contents","tags":"","loc":"proc/search_fun.html"},{"title":"search_sub – libfdf","text":"public  function search_sub(pline_sub, string, ind, after, eq_func) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline_sub character(len=*) :: string integer(kind=ip), intent(out), optional :: ind integer(kind=ip), intent(in), optional :: after public  function eq_func(s1, s2) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s1 character(len=*), intent(in) :: s2 Return Value logical Return Value logical Contents","tags":"","loc":"proc/search_sub.html"},{"title":"substring_search – libfdf","text":"public  function substring_search(pline_sub, string, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline_sub character(len=*) :: string integer(kind=ip), intent(out), optional :: ind integer(kind=ip), intent(in), optional :: after Return Value logical Contents","tags":"","loc":"proc/substring_search.html"},{"title":"match – libfdf","text":"public  function match(pline, str, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline character(len=*), intent(in) :: str integer(kind=ip), intent(in), optional :: after Return Value logical Contents","tags":"","loc":"proc/match.html"},{"title":"is_integer – libfdf","text":"private  function is_integer(string) Arguments Type Intent Optional Attributes Name character(len=*) :: string Return Value logical Contents","tags":"","loc":"proc/is_integer.html"},{"title":"is_value – libfdf","text":"private  function is_value(string) Arguments Type Intent Optional Attributes Name character(len=*) :: string Return Value logical Contents","tags":"","loc":"proc/is_value.html"},{"title":"create – libfdf","text":"private  subroutine create(pline) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline Contents","tags":"","loc":"proc/create.html"},{"title":"destroy – libfdf","text":"public  subroutine destroy(pline) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline Contents","tags":"","loc":"proc/destroy.html"},{"title":"reallists – libfdf","text":"public  subroutine reallists(pline, ind, nv, list, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip) :: nv real(kind=dp) :: list (nv) integer(kind=ip), intent(in), optional :: after Contents","tags":"","loc":"proc/reallists.html"},{"title":"valuelists – libfdf","text":"public  subroutine valuelists(pline, ind, nv, list, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip) :: nv real(kind=dp) :: list (nv) integer(kind=ip), intent(in), optional :: after Contents","tags":"","loc":"proc/valuelists.html"},{"title":"integerlists – libfdf","text":"public  subroutine integerlists(pline, ind, ni, list, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip) :: ni integer(kind=ip) :: list (ni) integer(kind=ip), intent(in), optional :: after Contents","tags":"","loc":"proc/integerlists.html"},{"title":"parses – libfdf","text":"private  subroutine parses(ntokens, line, first, last) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: ntokens character(len=*) :: line integer(kind=ip) :: first (MAX_NTOKENS) integer(kind=ip) :: last (MAX_NTOKENS) Contents","tags":"","loc":"proc/parses.html"},{"title":"morphol – libfdf","text":"private  subroutine morphol(ntokens, line, first, last, token_id) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: ntokens character(len=*) :: line integer(kind=ip) :: first (MAX_NTOKENS) integer(kind=ip) :: last (MAX_NTOKENS) character(len=1) :: token_id (MAX_NTOKENS) Contents","tags":"","loc":"proc/morphol.html"},{"title":"setmorphol – libfdf","text":"public  subroutine setmorphol(ntoken, token_id, pline) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: ntoken character(len=1) :: token_id type( parsed_line ), pointer :: pline Contents","tags":"","loc":"proc/setmorphol.html"},{"title":"setdebug – libfdf","text":"public  subroutine setdebug(level) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: level Contents","tags":"","loc":"proc/setdebug.html"},{"title":"setlog – libfdf","text":"public  subroutine setlog(unit) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: unit Contents","tags":"","loc":"proc/setlog.html"},{"title":"serialize_pline – libfdf","text":"public  subroutine serialize_pline(pline, string, length) Arguments Type Intent Optional Attributes Name type( parsed_line ) :: pline character(len=*), intent(out) :: string integer, intent(out) :: length Contents","tags":"","loc":"proc/serialize_pline.html"},{"title":"recreate_pline – libfdf","text":"public  subroutine recreate_pline(pline, string) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline character(len=*), intent(in) :: string Contents","tags":"","loc":"proc/recreate_pline.html"},{"title":"search – libfdf","text":"public interface search Contents Module Procedures search_fun search_sub Module Procedures public  function search_fun (string, pline_fun, after, eq_func) Arguments Type Intent Optional Attributes Name character(len=*) :: string type( parsed_line ), pointer :: pline_fun integer(kind=ip), intent(in), optional :: after public  function eq_func(s1, s2) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s1 character(len=*), intent(in) :: s2 Return Value logical Return Value integer(kind=ip) public  function search_sub (pline_sub, string, ind, after, eq_func) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline_sub character(len=*) :: string integer(kind=ip), intent(out), optional :: ind integer(kind=ip), intent(in), optional :: after public  function eq_func(s1, s2) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s1 character(len=*), intent(in) :: s2 Return Value logical Return Value logical","tags":"","loc":"interface/search.html"},{"title":"inquire_unit – libfdf","text":"public  subroutine inquire_unit(unit_str, stat, phys_dim, unit_name, unit_value) Uses prec utils Returns information about a unit in the units table Unit specifications might include an optional 'physical dimension'\nqualifier (e.g. 'bfield:g')\nIn this case, 'phys_dim' returns the physical dimension, and the\nqualifier is used to match the unit.\nThis version is case-insensitive (e.g. 'g' and 'G' could stand for 'Gauss').\nAs the above example indicates, in the absence of a physical dimension qualifier,\n'g' might be ambiguous ('bfield' or 'mass'?). The routine will return 'stat=-1'\nin this case.\nUnits might be ambiguous in a more serious way: 'meV' and 'MeV' could both be\npresent in the table. In this case, it might be advisable to use a case-sensitive\nversion of this routine (replacing 'leqi' by a 'strict' version).\nIf the unit is not found in the table, the routine returns 'stat=-2'. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: unit_str unit specification integer, intent(out) :: stat status code character(len=*), intent(out) :: phys_dim physical dimension (e.g. 'mass') character(len=*), intent(out) :: unit_name unit name (e.g. 'g') real(kind=dp), intent(out) :: unit_value actual value (e.g. 1.e-3) Contents","tags":"","loc":"proc/inquire_unit.html"},{"title":"fdf_readlabel – libfdf","text":"private recursive function fdf_readlabel(nelem, plabel, filein, found) result(readlabel) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: nelem type( parsed_line ), pointer :: plabel character(len=*) :: filein logical :: found (nelem) Return Value logical Contents","tags":"","loc":"proc/fdf_readlabel~2.html"},{"title":"fdf_searchlabel – libfdf","text":"private  function fdf_searchlabel(found, nelem, label, plabel) Arguments Type Intent Optional Attributes Name logical :: found (nelem) integer(kind=ip) :: nelem character(len=*) :: label type( parsed_line ), pointer :: plabel Return Value integer(kind=ip) Contents","tags":"","loc":"proc/fdf_searchlabel~2.html"},{"title":"fdf_readline – libfdf","text":"private  function fdf_readline(line) Arguments Type Intent Optional Attributes Name character(len=*) :: line Return Value logical Contents","tags":"","loc":"proc/fdf_readline~2.html"},{"title":"fdf_getline – libfdf","text":"public  function fdf_getline(mark) Arguments Type Intent Optional Attributes Name type( line_dlist ), pointer :: mark Return Value character(len=MAX_LENGTH) Contents","tags":"","loc":"proc/fdf_getline.html"},{"title":"fdf_integer – libfdf","text":"public  function fdf_integer(label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label integer(kind=ip) :: default type( line_dlist ), optional, pointer :: line Return Value integer(kind=ip) Contents","tags":"","loc":"proc/fdf_integer~2.html"},{"title":"fdf_isphysical – libfdf","text":"public  function fdf_isphysical(label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Return Value logical Contents","tags":"","loc":"proc/fdf_isphysical~2.html"},{"title":"fdf_islist – libfdf","text":"public  function fdf_islist(label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Return Value logical Contents","tags":"","loc":"proc/fdf_islist~2.html"},{"title":"fdf_islinteger – libfdf","text":"public  function fdf_islinteger(label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Return Value logical Contents","tags":"","loc":"proc/fdf_islinteger~2.html"},{"title":"fdf_islreal – libfdf","text":"public  function fdf_islreal(label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Return Value logical Contents","tags":"","loc":"proc/fdf_islreal~2.html"},{"title":"fdf_string – libfdf","text":"public  function fdf_string(label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label character(len=*) :: default type( line_dlist ), optional, pointer :: line Return Value character(len=80) Contents","tags":"","loc":"proc/fdf_string~2.html"},{"title":"fdf_boolean – libfdf","text":"public  function fdf_boolean(label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label logical :: default type( line_dlist ), optional, pointer :: line Return Value logical Contents","tags":"","loc":"proc/fdf_boolean.html"},{"title":"fdf_bboolean – libfdf","text":"public  function fdf_bboolean(pline, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip), intent(in), optional :: after Return Value logical Contents","tags":"","loc":"proc/fdf_bboolean.html"},{"title":"fdf_single – libfdf","text":"public  function fdf_single(label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label real(kind=sp) :: default type( line_dlist ), optional, pointer :: line Return Value real(kind=sp) Contents","tags":"","loc":"proc/fdf_single~2.html"},{"title":"fdf_double – libfdf","text":"public  function fdf_double(label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label real(kind=dp) :: default type( line_dlist ), optional, pointer :: line Return Value real(kind=dp) Contents","tags":"","loc":"proc/fdf_double~2.html"},{"title":"fdf_physical – libfdf","text":"public  function fdf_physical(label, default, defunit, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label real(kind=dp) :: default character(len=*) :: defunit type( line_dlist ), optional, pointer :: line Return Value real(kind=dp) Contents","tags":"","loc":"proc/fdf_physical~2.html"},{"title":"fdf_bphysical – libfdf","text":"public  function fdf_bphysical(pline, defunit, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline character(len=*) :: defunit integer(kind=ip), intent(in), optional :: after Return Value real(kind=dp) Contents","tags":"","loc":"proc/fdf_bphysical~2.html"},{"title":"fdf_convfac – libfdf","text":"public  function fdf_convfac(from, to) result(factor) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: from character(len=*), intent(in) :: to Return Value real(kind=dp) Contents","tags":"","loc":"proc/fdf_convfac~2.html"},{"title":"wrapper_convfac – libfdf","text":"private  function wrapper_convfac(from, to, stat, msg) result(factor) Uses prec utils Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: from character(len=*), intent(in) :: to integer, intent(out) :: stat character(len=*), intent(out) :: msg Return Value real(kind=dp) Contents","tags":"","loc":"proc/wrapper_convfac.html"},{"title":"fdf_locate – libfdf","text":"private  function fdf_locate(label, mark) Arguments Type Intent Optional Attributes Name character(len=*) :: label type( line_dlist ), pointer :: mark Return Value logical Contents","tags":"","loc":"proc/fdf_locate~2.html"},{"title":"fdf_isblock – libfdf","text":"public  function fdf_isblock(label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Return Value logical Contents","tags":"","loc":"proc/fdf_isblock~2.html"},{"title":"fdf_block – libfdf","text":"public  function fdf_block(label, bfdf) Arguments Type Intent Optional Attributes Name character(len=*) :: label type( block_fdf ) :: bfdf Return Value logical Contents","tags":"","loc":"proc/fdf_block~2.html"},{"title":"fdf_bline – libfdf","text":"public  function fdf_bline(bfdf, pline) Arguments Type Intent Optional Attributes Name type( block_fdf ) :: bfdf type( parsed_line ), pointer :: pline Return Value logical Contents","tags":"","loc":"proc/fdf_bline~2.html"},{"title":"fdf_bbackspace – libfdf","text":"public  function fdf_bbackspace(bfdf, pline) Arguments Type Intent Optional Attributes Name type( block_fdf ) :: bfdf type( parsed_line ), optional, pointer :: pline Return Value logical Contents","tags":"","loc":"proc/fdf_bbackspace~2.html"},{"title":"fdf_block_linecount – libfdf","text":"public  function fdf_block_linecount(label, morph) Arguments Type Intent Optional Attributes Name character(len=*) :: label character(len=*), optional :: morph Return Value integer(kind=ip) Contents","tags":"","loc":"proc/fdf_block_linecount~2.html"},{"title":"fdf_defined – libfdf","text":"public  function fdf_defined(label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Return Value logical Contents","tags":"","loc":"proc/fdf_defined~2.html"},{"title":"fdf_init – libfdf","text":"public  subroutine fdf_init(fileInput, fileOutput, unitInput) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: fileInput character(len=*), intent(in), optional :: fileOutput integer, intent(in), optional :: unitInput Contents","tags":"","loc":"proc/fdf_init.html"},{"title":"set_file_names – libfdf","text":"private  subroutine set_file_names(fileIn, fileOut, optFileIn, optFileOut, unitIn) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: fileIn character(len=*), intent(out) :: fileOut character(len=*), intent(in), optional :: optFileIn character(len=*), intent(in), optional :: optFileOut integer, intent(in), optional :: unitIn Contents","tags":"","loc":"proc/set_file_names~2.html"},{"title":"fdf_input – libfdf","text":"private  subroutine fdf_input(filein) Arguments Type Intent Optional Attributes Name character(len=*) :: filein Contents","tags":"","loc":"proc/fdf_input~2.html"},{"title":"fdf_read – libfdf","text":"private recursive subroutine fdf_read(filein, blocklabel) Arguments Type Intent Optional Attributes Name character(len=*) :: filein character(len=*), optional :: blocklabel Contents","tags":"","loc":"proc/fdf_read~2.html"},{"title":"fdf_dump – libfdf","text":"private  subroutine fdf_dump(label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Contents","tags":"","loc":"proc/fdf_dump~2.html"},{"title":"fdf_initdata – libfdf","text":"private  subroutine fdf_initdata() Arguments None Contents None","tags":"","loc":"proc/fdf_initdata~2.html"},{"title":"fdf_addline – libfdf","text":"public  subroutine fdf_addline(line) Arguments Type Intent Optional Attributes Name character(len=*) :: line Contents","tags":"","loc":"proc/fdf_addline~2.html"},{"title":"fdf_removelabel – libfdf","text":"public  subroutine fdf_removelabel(label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Contents","tags":"","loc":"proc/fdf_removelabel~2.html"},{"title":"fdf_overwrite – libfdf","text":"public  subroutine fdf_overwrite(line) Arguments Type Intent Optional Attributes Name character(len=*) :: line Contents","tags":"","loc":"proc/fdf_overwrite~2.html"},{"title":"fdf_addtoken – libfdf","text":"private  subroutine fdf_addtoken(line, pline) Arguments Type Intent Optional Attributes Name character(len=*) :: line type( parsed_line ), pointer :: pline Contents","tags":"","loc":"proc/fdf_addtoken~2.html"},{"title":"fdf_open – libfdf","text":"private  subroutine fdf_open(filename) Arguments Type Intent Optional Attributes Name character(len=*) :: filename Contents","tags":"","loc":"proc/fdf_open~2.html"},{"title":"fdf_close – libfdf","text":"private  subroutine fdf_close() Arguments None Contents None","tags":"","loc":"proc/fdf_close~2.html"},{"title":"fdf_set_output_file – libfdf","text":"private  subroutine fdf_set_output_file(fileout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fileout Contents","tags":"","loc":"proc/fdf_set_output_file~2.html"},{"title":"fdf_shutdown – libfdf","text":"public  subroutine fdf_shutdown() Arguments None Contents None","tags":"","loc":"proc/fdf_shutdown~2.html"},{"title":"fdf_destroy – libfdf","text":"private  subroutine fdf_destroy(fdfp) Arguments Type Intent Optional Attributes Name type( fdf_file ) :: fdfp Contents","tags":"","loc":"proc/fdf_destroy~2.html"},{"title":"fdf_destroy_dl – libfdf","text":"private recursive subroutine fdf_destroy_dl(dlp) Arguments Type Intent Optional Attributes Name type( line_dlist ), pointer :: dlp Contents","tags":"","loc":"proc/fdf_destroy_dl.html"},{"title":"fdf_printfdf – libfdf","text":"public  subroutine fdf_printfdf() Arguments None Contents None","tags":"","loc":"proc/fdf_printfdf~2.html"},{"title":"fdf_linteger – libfdf","text":"public  subroutine fdf_linteger(label, ni, list, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label integer(kind=ip) :: ni integer(kind=ip) :: list (ni) type( line_dlist ), optional, pointer :: line Contents","tags":"","loc":"proc/fdf_linteger~2.html"},{"title":"fdf_ldouble – libfdf","text":"public  subroutine fdf_ldouble(label, nv, list, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label integer(kind=ip) :: nv real(kind=dp) :: list (nv) type( line_dlist ), optional, pointer :: line Contents","tags":"","loc":"proc/fdf_ldouble~2.html"},{"title":"fdf_brewind – libfdf","text":"public  subroutine fdf_brewind(bfdf) Arguments Type Intent Optional Attributes Name type( block_fdf ) :: bfdf Contents","tags":"","loc":"proc/fdf_brewind~2.html"},{"title":"fdf_bclose – libfdf","text":"public  subroutine fdf_bclose(bfdf) Arguments Type Intent Optional Attributes Name type( block_fdf ) :: bfdf Contents","tags":"","loc":"proc/fdf_bclose~2.html"},{"title":"fdf_setoutput – libfdf","text":"public  subroutine fdf_setoutput(level, fileout_in) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: level character(len=*), intent(in) :: fileout_in Contents","tags":"","loc":"proc/fdf_setoutput~2.html"},{"title":"fdf_setdebug – libfdf","text":"public  subroutine fdf_setdebug(level, filedebug) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: level character(len=*) :: filedebug Contents","tags":"","loc":"proc/fdf_setdebug~2.html"},{"title":"fdf_deprecated – libfdf","text":"public  subroutine fdf_deprecated(label, newlabel) Arguments Type Intent Optional Attributes Name character(len=*) :: label character(len=*) :: newlabel Contents","tags":"","loc":"proc/fdf_deprecated~2.html"},{"title":"fdf_obsolete – libfdf","text":"public  subroutine fdf_obsolete(label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Contents","tags":"","loc":"proc/fdf_obsolete~2.html"},{"title":"fdf_serialize_struct – libfdf","text":"public  subroutine fdf_serialize_struct(buffer) Arguments Type Intent Optional Attributes Name character(len=1), intent(inout), allocatable :: buffer (:) Contents","tags":"","loc":"proc/fdf_serialize_struct~2.html"},{"title":"fdf_recreate_struct – libfdf","text":"public  subroutine fdf_recreate_struct(bufferFDF) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: bufferFDF (:) Contents","tags":"","loc":"proc/fdf_recreate_struct~2.html"},{"title":"fdf_set_started – libfdf","text":"public  subroutine fdf_set_started(status) Arguments Type Intent Optional Attributes Name logical, intent(in) :: status Contents","tags":"","loc":"proc/fdf_set_started~2.html"},{"title":"fdf_set_unit_handler – libfdf","text":"public  subroutine fdf_set_unit_handler(func) Arguments Type Intent Optional Attributes Name procedure( inquire_unit_p ) :: func Contents","tags":"","loc":"proc/fdf_set_unit_handler.html"},{"title":"fdf_get_unit_handler – libfdf","text":"public  subroutine fdf_get_unit_handler(func) Arguments Type Intent Optional Attributes Name procedure( inquire_unit_p ), pointer :: func Contents","tags":"","loc":"proc/fdf_get_unit_handler.html"},{"title":"inquire_unit_p – libfdf","text":"interface public  subroutine inquire_unit_p(unit_str, stat, phys_dim, unit_name, unit_value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: unit_str integer, intent(out) :: stat character(len=*), intent(out) :: phys_dim character(len=*), intent(out) :: unit_name real(kind=dp), intent(out) :: unit_value","tags":"","loc":"interface/inquire_unit_p.html"},{"title":"fdf_bnintegers – libfdf","text":"public interface fdf_bnintegers Contents Module Procedures nintegers Module Procedures public  function nintegers (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip)","tags":"","loc":"interface/fdf_bnintegers.html"},{"title":"fdf_bnlists – libfdf","text":"public interface fdf_bnlists Contents Module Procedures nlists Module Procedures public  function nlists (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip)","tags":"","loc":"interface/fdf_bnlists.html"},{"title":"fdf_bnilists – libfdf","text":"public interface fdf_bnilists Contents Module Procedures nintegerlists Module Procedures public  function nintegerlists (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip)","tags":"","loc":"interface/fdf_bnilists.html"},{"title":"fdf_bnrlists – libfdf","text":"public interface fdf_bnrlists Contents Module Procedures nreallists Module Procedures public  function nreallists (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip)","tags":"","loc":"interface/fdf_bnrlists.html"},{"title":"fdf_bnvlists – libfdf","text":"public interface fdf_bnvlists Contents Module Procedures nlists Module Procedures public  function nlists (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip)","tags":"","loc":"interface/fdf_bnvlists.html"},{"title":"fdf_bnreals – libfdf","text":"public interface fdf_bnreals Contents Module Procedures nreals Module Procedures public  function nreals (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip)","tags":"","loc":"interface/fdf_bnreals.html"},{"title":"fdf_bnvalues – libfdf","text":"public interface fdf_bnvalues Contents Module Procedures nvalues Module Procedures public  function nvalues (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip)","tags":"","loc":"interface/fdf_bnvalues.html"},{"title":"fdf_bnnames – libfdf","text":"public interface fdf_bnnames Contents Module Procedures nnames Module Procedures public  function nnames (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip)","tags":"","loc":"interface/fdf_bnnames.html"},{"title":"fdf_bntokens – libfdf","text":"public interface fdf_bntokens Contents Module Procedures ntokens Module Procedures public  function ntokens (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip)","tags":"","loc":"interface/fdf_bntokens.html"},{"title":"fdf_bintegers – libfdf","text":"public interface fdf_bintegers Contents Module Procedures integers Module Procedures public  function integers (pline, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip)","tags":"","loc":"interface/fdf_bintegers.html"},{"title":"fdf_bilists – libfdf","text":"public interface fdf_bilists Contents Module Procedures integerlists Module Procedures public  subroutine integerlists (pline, ind, ni, list, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip) :: ni integer(kind=ip) :: list (ni) integer(kind=ip), intent(in), optional :: after","tags":"","loc":"interface/fdf_bilists.html"},{"title":"fdf_brlists – libfdf","text":"public interface fdf_brlists Contents Module Procedures reallists Module Procedures public  subroutine reallists (pline, ind, nv, list, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip) :: nv real(kind=dp) :: list (nv) integer(kind=ip), intent(in), optional :: after","tags":"","loc":"interface/fdf_brlists.html"},{"title":"fdf_bvlists – libfdf","text":"public interface fdf_bvlists Contents Module Procedures valuelists Module Procedures public  subroutine valuelists (pline, ind, nv, list, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip) :: nv real(kind=dp) :: list (nv) integer(kind=ip), intent(in), optional :: after","tags":"","loc":"interface/fdf_bvlists.html"},{"title":"fdf_breals – libfdf","text":"public interface fdf_breals Contents Module Procedures reals Module Procedures public  function reals (pline, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip), intent(in), optional :: after Return Value real(kind=dp)","tags":"","loc":"interface/fdf_breals.html"},{"title":"fdf_bvalues – libfdf","text":"public interface fdf_bvalues Contents Module Procedures values Module Procedures public  function values (pline, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip), intent(in), optional :: after Return Value real(kind=dp)","tags":"","loc":"interface/fdf_bvalues.html"},{"title":"fdf_bnames – libfdf","text":"public interface fdf_bnames Contents Module Procedures names Module Procedures public  function names (pline, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip), intent(in), optional :: after Return Value character(len=MAX_LENGTH)","tags":"","loc":"interface/fdf_bnames.html"},{"title":"fdf_btokens – libfdf","text":"public interface fdf_btokens Contents Module Procedures tokens Module Procedures public  function tokens (pline, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip), intent(in), optional :: after Return Value character(len=MAX_LENGTH)","tags":"","loc":"interface/fdf_btokens.html"},{"title":"fdf_bmatch – libfdf","text":"public interface fdf_bmatch Contents Module Procedures match Module Procedures public  function match (pline, str, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline character(len=*), intent(in) :: str integer(kind=ip), intent(in), optional :: after Return Value logical","tags":"","loc":"interface/fdf_bmatch.html"},{"title":"fdf_get – libfdf","text":"public interface fdf_get Contents Module Procedures fdf_integer fdf_single fdf_double fdf_boolean fdf_string fdf_physical Module Procedures public  function fdf_integer (label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label integer(kind=ip) :: default type( line_dlist ), optional, pointer :: line Return Value integer(kind=ip) public  function fdf_single (label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label real(kind=sp) :: default type( line_dlist ), optional, pointer :: line Return Value real(kind=sp) public  function fdf_double (label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label real(kind=dp) :: default type( line_dlist ), optional, pointer :: line Return Value real(kind=dp) public  function fdf_boolean (label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label logical :: default type( line_dlist ), optional, pointer :: line Return Value logical public  function fdf_string (label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label character(len=*) :: default type( line_dlist ), optional, pointer :: line Return Value character(len=80) public  function fdf_physical (label, default, defunit, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label real(kind=dp) :: default character(len=*) :: defunit type( line_dlist ), optional, pointer :: line Return Value real(kind=dp)","tags":"","loc":"interface/fdf_get.html"},{"title":"fdf_list – libfdf","text":"public interface fdf_list Contents Module Procedures fdf_linteger fdf_ldouble Module Procedures public  subroutine fdf_linteger (label, ni, list, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label integer(kind=ip) :: ni integer(kind=ip) :: list (ni) type( line_dlist ), optional, pointer :: line public  subroutine fdf_ldouble (label, nv, list, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label integer(kind=ip) :: nv real(kind=dp) :: list (nv) type( line_dlist ), optional, pointer :: line","tags":"","loc":"interface/fdf_list.html"},{"title":"utils – libfdf","text":"Uses prec iso_fortran_env Contents Variables MAX_LENGTH Functions leqi leqi_strict labeleq s2i s2r arr2s s2arr i2s Subroutines packlabel chrcap chrlen convert_string_to_array_of_chars convert_array_of_chars_to_string warn die Variables Type Visibility Attributes Name Initial integer(kind=ip), public, parameter :: MAX_LENGTH = 132 Functions public  function leqi (string1, string2) Arguments Type Intent Optional Attributes Name character(len=*) :: string1 character(len=*) :: string2 Return Value logical public  function leqi_strict (str1, str2) Arguments Type Intent Optional Attributes Name character(len=*) :: str1 character(len=*) :: str2 Return Value logical public  function labeleq (s1, s2, logunit) Arguments Type Intent Optional Attributes Name character(len=*) :: s1 character(len=*) :: s2 integer(kind=ip), optional :: logunit Return Value logical public  function s2i (string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value integer(kind=ip) public  function s2r (string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value real(kind=dp) public  function arr2s (string_arr, string_size) Arguments Type Intent Optional Attributes Name character(len=1) :: string_arr (*) integer(kind=ip) :: string_size Return Value character(len=MAX_LENGTH) public  function s2arr (string) Arguments Type Intent Optional Attributes Name character(len=*) :: string Return Value character(len=1), (MAX_LENGTH) public  function i2s (num) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: num Return Value character(len=5) Subroutines public  subroutine packlabel (s, n) Arguments Type Intent Optional Attributes Name character(len=*) :: s character(len=*) :: n public  subroutine chrcap (string, nchar) Arguments Type Intent Optional Attributes Name character(len=*) :: string integer(kind=ip) :: nchar public  subroutine chrlen (string, nchar, lchar) Arguments Type Intent Optional Attributes Name character(len=*) :: string integer(kind=ip) :: nchar integer(kind=ip) :: lchar public  subroutine convert_string_to_array_of_chars (str, arr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=1), intent(out), dimension(:) :: arr public  subroutine convert_array_of_chars_to_string (arr, str) Arguments Type Intent Optional Attributes Name character(len=1), intent(in), dimension(:) :: arr character(len=*), intent(out) :: str public  subroutine warn (string) Arguments Type Intent Optional Attributes Name character(len=*) :: string public  subroutine die (routine, msg, file, line, unit, rc, cline) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: routine character(len=*), intent(in) :: msg character(len=*), intent(in), optional :: file integer(kind=ip), intent(in), optional :: line integer(kind=ip), intent(in), optional :: unit integer(kind=ip), intent(in), optional :: rc character(len=*), intent(in), optional :: cline","tags":"","loc":"module/utils.html"},{"title":"io_fdf – libfdf","text":"Uses iso_fortran_env prec utils Contents Variables stderr stdout min_lun max_lun nunits lun_is_free Subroutines io_seterr io_setout io_geterr io_getout io_assign io_reserve io_close io_status Variables Type Visibility Attributes Name Initial integer(kind=ip), private :: stderr = 0 integer(kind=ip), private :: stdout = 6 integer(kind=ip), private, parameter :: min_lun = 10 integer(kind=ip), private, parameter :: max_lun = 99 integer(kind=ip), private, parameter :: nunits = max_lun-min_lun+1 logical, private :: lun_is_free (min_lun:max_lun) = .TRUE. Subroutines public  subroutine io_seterr (unit) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout) :: unit public  subroutine io_setout (unit) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout) :: unit public  subroutine io_geterr (unit) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout) :: unit public  subroutine io_getout (unit) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout) :: unit public  subroutine io_assign (lun) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout) :: lun public  subroutine io_reserve (lun) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout) :: lun public  subroutine io_close (lun) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout) :: lun public  subroutine io_status () Arguments None","tags":"","loc":"module/io_fdf.html"},{"title":"prec – libfdf","text":"Contents Variables ip sp dp Variables Type Visibility Attributes Name Initial integer, public, parameter :: ip = selected_int_kind(9) integer, public, parameter :: sp = selected_real_kind(6, 20) integer, public, parameter :: dp = selected_real_kind(14, 100)","tags":"","loc":"module/prec.html"},{"title":"parse – libfdf","text":"Uses prec utils Contents Variables parse_debug parse_log MAX_NTOKENS SERIALIZED_LENGTH Interfaces search Derived Types parsed_line Functions nitems nintegers nreals nvalues nlists nintegerlists nreallists nnames nblocks nendblocks nlabels ntokens integers reals values names blocks endblocks labels tokens characters digest search_fun search_sub substring_search match is_integer is_value Subroutines create destroy reallists valuelists integerlists parses morphol setmorphol setdebug setlog serialize_pline recreate_pline Variables Type Visibility Attributes Name Initial logical, private :: parse_debug = .FALSE. integer(kind=ip), private :: parse_log = 0 integer(kind=ip), private, parameter :: MAX_NTOKENS = 50 integer, public, parameter :: SERIALIZED_LENGTH = MAX_LENGTH+4+10*MAX_NTOKENS Interfaces public        interface search public  function search_fun (string, pline_fun, after, eq_func) Arguments Type Intent Optional Attributes Name character(len=*) :: string type( parsed_line ), pointer :: pline_fun integer(kind=ip), intent(in), optional :: after public  function eq_func(s1, s2) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s1 character(len=*), intent(in) :: s2 Return Value logical Return Value integer(kind=ip) public  function search_sub (pline_sub, string, ind, after, eq_func) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline_sub character(len=*) :: string integer(kind=ip), intent(out), optional :: ind integer(kind=ip), intent(in), optional :: after public  function eq_func(s1, s2) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s1 character(len=*), intent(in) :: s2 Return Value logical Return Value logical Derived Types type, public :: parsed_line Components Type Visibility Attributes Name Initial integer(kind=ip), public :: ntokens character(len=MAX_LENGTH), public :: line integer(kind=ip), public :: first (MAX_NTOKENS) integer(kind=ip), public :: last (MAX_NTOKENS) character(len=1), public :: id (MAX_NTOKENS) Functions public  function nitems (class, pline, after) Arguments Type Intent Optional Attributes Name character(len=1) :: class type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) public  function nintegers (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) public  function nreals (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) public  function nvalues (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) public  function nlists (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) public  function nintegerlists (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) public  function nreallists (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) public  function nnames (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) public  function nblocks (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) public  function nendblocks (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) public  function nlabels (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) public  function ntokens (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) public  function integers (pline, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) public  function reals (pline, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip), intent(in), optional :: after Return Value real(kind=dp) public  function values (pline, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip), intent(in), optional :: after Return Value real(kind=dp) public  function names (pline, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip), intent(in), optional :: after Return Value character(len=MAX_LENGTH) public  function blocks (pline) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline Return Value character(len=MAX_LENGTH) public  function endblocks (pline) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline Return Value character(len=MAX_LENGTH) public  function labels (pline) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline Return Value character(len=MAX_LENGTH) public  function tokens (pline, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip), intent(in), optional :: after Return Value character(len=MAX_LENGTH) public  function characters (pline, ind_init, ind_final, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind_init integer(kind=ip), intent(in) :: ind_final integer(kind=ip), intent(in), optional :: after Return Value character(len=MAX_LENGTH) public  function digest (line) result(pline) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value type( parsed_line ), pointer public  function search_fun (string, pline_fun, after, eq_func) Arguments Type Intent Optional Attributes Name character(len=*) :: string type( parsed_line ), pointer :: pline_fun integer(kind=ip), intent(in), optional :: after public  function eq_func(s1, s2) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s1 character(len=*), intent(in) :: s2 Return Value logical Return Value integer(kind=ip) public  function search_sub (pline_sub, string, ind, after, eq_func) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline_sub character(len=*) :: string integer(kind=ip), intent(out), optional :: ind integer(kind=ip), intent(in), optional :: after public  function eq_func(s1, s2) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s1 character(len=*), intent(in) :: s2 Return Value logical Return Value logical public  function substring_search (pline_sub, string, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline_sub character(len=*) :: string integer(kind=ip), intent(out), optional :: ind integer(kind=ip), intent(in), optional :: after Return Value logical public  function match (pline, str, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline character(len=*), intent(in) :: str integer(kind=ip), intent(in), optional :: after Return Value logical private  function is_integer (string) Arguments Type Intent Optional Attributes Name character(len=*) :: string Return Value logical private  function is_value (string) Arguments Type Intent Optional Attributes Name character(len=*) :: string Return Value logical Subroutines private  subroutine create (pline) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline public  subroutine destroy (pline) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline public  subroutine reallists (pline, ind, nv, list, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip) :: nv real(kind=dp) :: list (nv) integer(kind=ip), intent(in), optional :: after public  subroutine valuelists (pline, ind, nv, list, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip) :: nv real(kind=dp) :: list (nv) integer(kind=ip), intent(in), optional :: after public  subroutine integerlists (pline, ind, ni, list, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip) :: ni integer(kind=ip) :: list (ni) integer(kind=ip), intent(in), optional :: after private  subroutine parses (ntokens, line, first, last) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: ntokens character(len=*) :: line integer(kind=ip) :: first (MAX_NTOKENS) integer(kind=ip) :: last (MAX_NTOKENS) private  subroutine morphol (ntokens, line, first, last, token_id) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: ntokens character(len=*) :: line integer(kind=ip) :: first (MAX_NTOKENS) integer(kind=ip) :: last (MAX_NTOKENS) character(len=1) :: token_id (MAX_NTOKENS) public  subroutine setmorphol (ntoken, token_id, pline) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: ntoken character(len=1) :: token_id type( parsed_line ), pointer :: pline public  subroutine setdebug (level) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: level public  subroutine setlog (unit) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: unit public  subroutine serialize_pline (pline, string, length) Arguments Type Intent Optional Attributes Name type( parsed_line ) :: pline character(len=*), intent(out) :: string integer, intent(out) :: length public  subroutine recreate_pline (pline, string) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline character(len=*), intent(in) :: string","tags":"","loc":"module/parse.html"},{"title":"legacy_units_m – libfdf","text":"Uses prec Contents Variables nu iu dimm name unit Subroutines inquire_unit Variables Type Visibility Attributes Name Initial integer, private, parameter :: nu = 80 integer, private :: iu character(len=8), private :: dimm (nu) character(len=10), private :: name (nu) real(kind=dp), private :: unit (nu) Subroutines public  subroutine inquire_unit (unit_str, stat, phys_dim, unit_name, unit_value) Returns information about a unit in the units table Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: unit_str unit specification integer, intent(out) :: stat status code character(len=*), intent(out) :: phys_dim physical dimension (e.g. 'mass') character(len=*), intent(out) :: unit_name unit name (e.g. 'g') real(kind=dp), intent(out) :: unit_value actual value (e.g. 1.e-3)","tags":"","loc":"module/legacy_units_m.html"},{"title":"fdf – libfdf","text":"Uses prec utils io_fdf parse legacy_units_m Contents Variables inquire_unit fdf_debug fdf_debug2 fdf_started fdf_output maxdepth maxFileNameLength ndepth fdf_in fdf_out fdf_err fdf_log file_in Interfaces inquire_unit_p fdf_bnintegers fdf_bnlists fdf_bnilists fdf_bnrlists fdf_bnvlists fdf_bnreals fdf_bnvalues fdf_bnnames fdf_bntokens fdf_bintegers fdf_bilists fdf_brlists fdf_bvlists fdf_breals fdf_bvalues fdf_bnames fdf_btokens fdf_bmatch fdf_get fdf_list Derived Types block_fdf line_dlist fdf_file Functions fdf_readlabel fdf_searchlabel fdf_readline fdf_getline fdf_integer fdf_isphysical fdf_islist fdf_islinteger fdf_islreal fdf_string fdf_boolean fdf_bboolean fdf_single fdf_double fdf_physical fdf_bphysical fdf_convfac wrapper_convfac fdf_locate fdf_isblock fdf_block fdf_bline fdf_bbackspace fdf_block_linecount fdf_defined Subroutines fdf_init set_file_names fdf_input fdf_read fdf_dump fdf_initdata fdf_addline fdf_removelabel fdf_overwrite fdf_addtoken fdf_open fdf_close fdf_set_output_file fdf_shutdown fdf_destroy fdf_destroy_dl fdf_printfdf fdf_linteger fdf_ldouble fdf_brewind fdf_bclose fdf_setoutput fdf_setdebug fdf_deprecated fdf_obsolete fdf_serialize_struct fdf_recreate_struct fdf_set_started fdf_set_unit_handler fdf_get_unit_handler Variables Type Visibility Attributes Name Initial procedure( inquire_unit_p ), public, pointer :: inquire_unit => null() logical, private :: fdf_debug = .FALSE. logical, private :: fdf_debug2 = .FALSE. logical, private :: fdf_started = .FALSE. logical, private :: fdf_output = .FALSE. integer(kind=ip), private, parameter :: maxdepth = 7 integer(kind=ip), private, parameter :: maxFileNameLength = 300 integer(kind=ip), private :: ndepth integer(kind=ip), private :: fdf_in (maxdepth) integer(kind=ip), private :: fdf_out integer(kind=ip), private :: fdf_err integer(kind=ip), private :: fdf_log type( fdf_file ), private :: file_in Interfaces interface public  subroutine inquire_unit_p(unit_str, stat, phys_dim, unit_name, unit_value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: unit_str integer, intent(out) :: stat character(len=*), intent(out) :: phys_dim character(len=*), intent(out) :: unit_name real(kind=dp), intent(out) :: unit_value public        interface fdf_bnintegers public  function nintegers (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) public        interface fdf_bnlists public  function nlists (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) public        interface fdf_bnilists public  function nintegerlists (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) public        interface fdf_bnrlists public  function nreallists (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) public        interface fdf_bnvlists public  function nlists (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) public        interface fdf_bnreals public  function nreals (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) public        interface fdf_bnvalues public  function nvalues (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) public        interface fdf_bnnames public  function nnames (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) public        interface fdf_bntokens public  function ntokens (pline, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) public        interface fdf_bintegers public  function integers (pline, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip), intent(in), optional :: after Return Value integer(kind=ip) public        interface fdf_bilists public  subroutine integerlists (pline, ind, ni, list, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip) :: ni integer(kind=ip) :: list (ni) integer(kind=ip), intent(in), optional :: after public        interface fdf_brlists public  subroutine reallists (pline, ind, nv, list, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip) :: nv real(kind=dp) :: list (nv) integer(kind=ip), intent(in), optional :: after public        interface fdf_bvlists public  subroutine valuelists (pline, ind, nv, list, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip) :: nv real(kind=dp) :: list (nv) integer(kind=ip), intent(in), optional :: after public        interface fdf_breals public  function reals (pline, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip), intent(in), optional :: after Return Value real(kind=dp) public        interface fdf_bvalues public  function values (pline, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip), intent(in), optional :: after Return Value real(kind=dp) public        interface fdf_bnames public  function names (pline, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip), intent(in), optional :: after Return Value character(len=MAX_LENGTH) public        interface fdf_btokens public  function tokens (pline, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip), intent(in), optional :: after Return Value character(len=MAX_LENGTH) public        interface fdf_bmatch public  function match (pline, str, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline character(len=*), intent(in) :: str integer(kind=ip), intent(in), optional :: after Return Value logical public        interface fdf_get public  function fdf_integer (label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label integer(kind=ip) :: default type( line_dlist ), optional, pointer :: line Return Value integer(kind=ip) public  function fdf_single (label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label real(kind=sp) :: default type( line_dlist ), optional, pointer :: line Return Value real(kind=sp) public  function fdf_double (label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label real(kind=dp) :: default type( line_dlist ), optional, pointer :: line Return Value real(kind=dp) public  function fdf_boolean (label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label logical :: default type( line_dlist ), optional, pointer :: line Return Value logical public  function fdf_string (label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label character(len=*) :: default type( line_dlist ), optional, pointer :: line Return Value character(len=80) public  function fdf_physical (label, default, defunit, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label real(kind=dp) :: default character(len=*) :: defunit type( line_dlist ), optional, pointer :: line Return Value real(kind=dp) public        interface fdf_list public  subroutine fdf_linteger (label, ni, list, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label integer(kind=ip) :: ni integer(kind=ip) :: list (ni) type( line_dlist ), optional, pointer :: line public  subroutine fdf_ldouble (label, nv, list, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label integer(kind=ip) :: nv real(kind=dp) :: list (nv) type( line_dlist ), optional, pointer :: line Derived Types type, public :: block_fdf Components Type Visibility Attributes Name Initial character(len=MAX_LENGTH), public :: label type( line_dlist ), public, pointer :: mark => null() type, public :: line_dlist Components Type Visibility Attributes Name Initial character(len=MAX_LENGTH), public :: str type( parsed_line ), public, pointer :: pline => null() type( line_dlist ), public, pointer :: next => null() type( line_dlist ), public, pointer :: prev => null() type, private :: fdf_file Components Type Visibility Attributes Name Initial integer(kind=ip), public :: nlines type( line_dlist ), public, pointer :: first => null() type( line_dlist ), public, pointer :: last => null() Functions private recursive function fdf_readlabel (nelem, plabel, filein, found) result(readlabel) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: nelem type( parsed_line ), pointer :: plabel character(len=*) :: filein logical :: found (nelem) Return Value logical private  function fdf_searchlabel (found, nelem, label, plabel) Arguments Type Intent Optional Attributes Name logical :: found (nelem) integer(kind=ip) :: nelem character(len=*) :: label type( parsed_line ), pointer :: plabel Return Value integer(kind=ip) private  function fdf_readline (line) Arguments Type Intent Optional Attributes Name character(len=*) :: line Return Value logical public  function fdf_getline (mark) Arguments Type Intent Optional Attributes Name type( line_dlist ), pointer :: mark Return Value character(len=MAX_LENGTH) public  function fdf_integer (label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label integer(kind=ip) :: default type( line_dlist ), optional, pointer :: line Return Value integer(kind=ip) public  function fdf_isphysical (label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Return Value logical public  function fdf_islist (label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Return Value logical public  function fdf_islinteger (label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Return Value logical public  function fdf_islreal (label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Return Value logical public  function fdf_string (label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label character(len=*) :: default type( line_dlist ), optional, pointer :: line Return Value character(len=80) public  function fdf_boolean (label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label logical :: default type( line_dlist ), optional, pointer :: line Return Value logical public  function fdf_bboolean (pline, ind, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline integer(kind=ip), intent(in) :: ind integer(kind=ip), intent(in), optional :: after Return Value logical public  function fdf_single (label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label real(kind=sp) :: default type( line_dlist ), optional, pointer :: line Return Value real(kind=sp) public  function fdf_double (label, default, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label real(kind=dp) :: default type( line_dlist ), optional, pointer :: line Return Value real(kind=dp) public  function fdf_physical (label, default, defunit, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label real(kind=dp) :: default character(len=*) :: defunit type( line_dlist ), optional, pointer :: line Return Value real(kind=dp) public  function fdf_bphysical (pline, defunit, after) Arguments Type Intent Optional Attributes Name type( parsed_line ), pointer :: pline character(len=*) :: defunit integer(kind=ip), intent(in), optional :: after Return Value real(kind=dp) public  function fdf_convfac (from, to) result(factor) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: from character(len=*), intent(in) :: to Return Value real(kind=dp) private  function wrapper_convfac (from, to, stat, msg) result(factor) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: from character(len=*), intent(in) :: to integer, intent(out) :: stat character(len=*), intent(out) :: msg Return Value real(kind=dp) private  function fdf_locate (label, mark) Arguments Type Intent Optional Attributes Name character(len=*) :: label type( line_dlist ), pointer :: mark Return Value logical public  function fdf_isblock (label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Return Value logical public  function fdf_block (label, bfdf) Arguments Type Intent Optional Attributes Name character(len=*) :: label type( block_fdf ) :: bfdf Return Value logical public  function fdf_bline (bfdf, pline) Arguments Type Intent Optional Attributes Name type( block_fdf ) :: bfdf type( parsed_line ), pointer :: pline Return Value logical public  function fdf_bbackspace (bfdf, pline) Arguments Type Intent Optional Attributes Name type( block_fdf ) :: bfdf type( parsed_line ), optional, pointer :: pline Return Value logical public  function fdf_block_linecount (label, morph) Arguments Type Intent Optional Attributes Name character(len=*) :: label character(len=*), optional :: morph Return Value integer(kind=ip) public  function fdf_defined (label) Arguments Type Intent Optional Attributes Name character(len=*) :: label Return Value logical Subroutines public  subroutine fdf_init (fileInput, fileOutput, unitInput) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: fileInput character(len=*), intent(in), optional :: fileOutput integer, intent(in), optional :: unitInput private  subroutine set_file_names (fileIn, fileOut, optFileIn, optFileOut, unitIn) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: fileIn character(len=*), intent(out) :: fileOut character(len=*), intent(in), optional :: optFileIn character(len=*), intent(in), optional :: optFileOut integer, intent(in), optional :: unitIn private  subroutine fdf_input (filein) Arguments Type Intent Optional Attributes Name character(len=*) :: filein private recursive subroutine fdf_read (filein, blocklabel) Arguments Type Intent Optional Attributes Name character(len=*) :: filein character(len=*), optional :: blocklabel private  subroutine fdf_dump (label) Arguments Type Intent Optional Attributes Name character(len=*) :: label private  subroutine fdf_initdata () Arguments None public  subroutine fdf_addline (line) Arguments Type Intent Optional Attributes Name character(len=*) :: line public  subroutine fdf_removelabel (label) Arguments Type Intent Optional Attributes Name character(len=*) :: label public  subroutine fdf_overwrite (line) Arguments Type Intent Optional Attributes Name character(len=*) :: line private  subroutine fdf_addtoken (line, pline) Arguments Type Intent Optional Attributes Name character(len=*) :: line type( parsed_line ), pointer :: pline private  subroutine fdf_open (filename) Arguments Type Intent Optional Attributes Name character(len=*) :: filename private  subroutine fdf_close () Arguments None private  subroutine fdf_set_output_file (fileout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fileout public  subroutine fdf_shutdown () Arguments None private  subroutine fdf_destroy (fdfp) Arguments Type Intent Optional Attributes Name type( fdf_file ) :: fdfp private recursive subroutine fdf_destroy_dl (dlp) Arguments Type Intent Optional Attributes Name type( line_dlist ), pointer :: dlp public  subroutine fdf_printfdf () Arguments None public  subroutine fdf_linteger (label, ni, list, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label integer(kind=ip) :: ni integer(kind=ip) :: list (ni) type( line_dlist ), optional, pointer :: line public  subroutine fdf_ldouble (label, nv, list, line) Arguments Type Intent Optional Attributes Name character(len=*) :: label integer(kind=ip) :: nv real(kind=dp) :: list (nv) type( line_dlist ), optional, pointer :: line public  subroutine fdf_brewind (bfdf) Arguments Type Intent Optional Attributes Name type( block_fdf ) :: bfdf public  subroutine fdf_bclose (bfdf) Arguments Type Intent Optional Attributes Name type( block_fdf ) :: bfdf public  subroutine fdf_setoutput (level, fileout_in) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: level character(len=*), intent(in) :: fileout_in public  subroutine fdf_setdebug (level, filedebug) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: level character(len=*) :: filedebug public  subroutine fdf_deprecated (label, newlabel) Arguments Type Intent Optional Attributes Name character(len=*) :: label character(len=*) :: newlabel public  subroutine fdf_obsolete (label) Arguments Type Intent Optional Attributes Name character(len=*) :: label public  subroutine fdf_serialize_struct (buffer) Arguments Type Intent Optional Attributes Name character(len=1), intent(inout), allocatable :: buffer (:) public  subroutine fdf_recreate_struct (bufferFDF) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: bufferFDF (:) public  subroutine fdf_set_started (status) Arguments Type Intent Optional Attributes Name logical, intent(in) :: status public  subroutine fdf_set_unit_handler (func) Arguments Type Intent Optional Attributes Name procedure( inquire_unit_p ) :: func public  subroutine fdf_get_unit_handler (func) Arguments Type Intent Optional Attributes Name procedure( inquire_unit_p ), pointer :: func","tags":"","loc":"module/fdf.html"},{"title":"utils.F90 – libfdf","text":"Contents Modules utils Source Code utils.F90 Source Code #if defined HAVE_CONFIG_H #  include \"config.h\" #endif !===================================================================== ! ! This file is part of the FDF package. ! ! This module provides useful functions and subroutines for FDF library. ! At this moment this module contains functions for: ! !   a) String manipulation !   b) Warning, Die (Abort/Terminate) operations ! ! ! September 2007 ! ! !===================================================================== MODULE utils USE , INTRINSIC :: iso_fortran_env USE prec implicit none ! String functions public :: leqi , leqi_strict public :: labeleq , packlabel public :: chrcap , chrlen ! Conversors between formats public :: s2i , s2r , arr2s , s2arr , i2s public :: convert_string_to_array_of_chars public :: convert_array_of_chars_to_string ! Warning and Terminate functions public :: warn , die ! Maximum size of a string integer ( ip ), parameter , public :: MAX_LENGTH = 132 CONTAINS ! !   Case-insensitive lexical equal-to comparison ! FUNCTION leqi ( string1 , string2 ) implicit none !--------------------------------------------------------------- Input Variables character ( len =* ) :: string1 , string2 !-------------------------------------------------------------- Output Variables logical :: leqi !--------------------------------------------------------------- Local Variables logical :: completed character :: char1 , char2 integer ( ip ) :: i , len1 , len2 , lenc !------------------------------------------------------------------------- BEGIN len1 = len ( string1 ) len2 = len ( string2 ) lenc = min ( len1 , len2 ) i = 1 leqi = . TRUE . completed = . FALSE . do while ((. not . completed ) . and . ( i . le . lenc )) char1 = string1 ( i : i ) char2 = string2 ( i : i ) call chrcap ( char1 , 1 ) call chrcap ( char2 , 1 ) if ( char1 . ne . char2 ) then leqi = . FALSE . completed = . TRUE . endif i = i + 1 enddo if ( leqi ) then if (( len1 . gt . lenc ) . and . ( string1 ( lenc + 1 : len1 ) . ne . ' ' )) & leqi = . FALSE . if (( len2 . gt . lenc ) . and . ( string2 ( lenc + 1 : len2 ) . ne . ' ' )) & leqi = . FALSE . endif RETURN !--------------------------------------------------------------------------- END END FUNCTION leqi ! !   Examples of eq_func's for search function (Case sensitive) ! FUNCTION leqi_strict ( str1 , str2 ) implicit none !--------------------------------------------------------------- Input Variables character ( len =* ) :: str1 , str2 !-------------------------------------------------------------- Output Variables logical :: leqi_strict !------------------------------------------------------------------------- BEGIN leqi_strict = ( str1 . eq . str2 ) RETURN !--------------------------------------------------------------------------- END END FUNCTION leqi_strict ! !   Compares s1 and s2 without regard for case, or appearance !   of '_', '.', '-'. ! FUNCTION labeleq ( s1 , s2 , logunit ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: s1 , s2 integer ( ip ), optional :: logunit !-------------------------------------------------------------- Output Variables logical :: labeleq !--------------------------------------------------------------- Local Variables character ( max ( len ( s1 ), len ( s2 ))) :: n1 , n2 !------------------------------------------------------------------------- BEGIN call packlabel ( s1 , n1 ) call packlabel ( s2 , n2 ) labeleq = leqi ( n1 , n2 ) if ( PRESENT ( logunit ) . and . labeleq . and . & (. not . leqi ( s1 , s2 ))) then !!        write(logunit,'(a,/,a,/,a)')                                    & !!           '--------- Considered equivalent:', s1, s2 endif RETURN !--------------------------------------------------------------------------- END END FUNCTION labeleq ! !   Removes occurrences of '_ .-'  from s ! SUBROUTINE packlabel ( s , n ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: s !-------------------------------------------------------------- Output Variables character ( * ) :: n !--------------------------------------------------------------- Local Variables character :: c integer ( ip ) :: i , j logical :: is_sep is_sep ( i ) = ( i . eq . 95 ) . or . ( i . eq . 46 ) . or . ( i . eq . 45 ) !------------------------------------------------------------------------- BEGIN n = ' ' j = 0 do i = 1 , len ( s ) c = s ( i : i ) if (. not . is_sep ( ichar ( c ))) then j = j + 1 n ( j : j ) = c endif enddo RETURN !--------------------------------------------------------------------------- END END SUBROUTINE packlabel ! !   CHRCAP accepts a STRING of NCHAR characters and replaces !   any lowercase letters by uppercase ones. ! SUBROUTINE chrcap ( string , nchar ) implicit none !--------------------------------------------------------------- Input Variables integer ( ip ) :: nchar !-------------------------------------------------------------- Output Variables character ( * ) :: string !--------------------------------------------------------------- Local Variables integer ( ip ) :: i , itemp , ncopy !------------------------------------------------------------------------- BEGIN if ( nchar . le . 0 ) then ncopy = LEN ( string ) else ncopy = nchar endif do i = 1 , ncopy if ( LGE ( string ( i : i ), 'a' ) . and . LLE ( string ( i : i ), 'z' )) then itemp = ICHAR ( string ( i : i )) + ICHAR ( 'A' ) - ICHAR ( 'a' ) string ( i : i ) = CHAR ( itemp ) endif enddo RETURN !--------------------------------------------------------------------------- END END SUBROUTINE chrcap ! !   CHRLEN accepts a STRING of NCHAR characters and returns LCHAR, !   the length of the string up to the last NONBLANK, NONNULL. ! SUBROUTINE chrlen ( string , nchar , lchar ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: string integer ( ip ) :: nchar !-------------------------------------------------------------- Output Variables integer ( ip ) :: lchar !------------------------------------------------------------------------- BEGIN lchar = nchar if ( lchar . le . 0 ) lchar = LEN ( string ) do while ((( string ( lchar : lchar ) . eq . ' ' ) . or . ( string ( lchar : lchar ) & . eq . CHAR ( 0 ))) . and . ( lchar . gt . 0 )) lchar = lchar - 1 enddo RETURN !--------------------------------------------------------------------------- END END SUBROUTINE chrlen ! !   String to Integer translator ! FUNCTION s2i ( string ) implicit none !--------------------------------------------------------------- Input Variables character ( * ), intent ( in ) :: string !-------------------------------------------------------------- Output Variables integer ( ip ) :: s2i !--------------------------------------------------------------- Local Variables integer ( ip ) :: ierr !------------------------------------------------------------------------- BEGIN read ( string , fmt =* , iostat = ierr ) s2i if ( ierr . ne . 0 ) then call die ( 'UTILS module: s2i' , 'Integer conversion error' , & 'utils.F90' , __ LINE__ , ERROR_UNIT ) endif RETURN !--------------------------------------------------------------------------- END END FUNCTION s2i ! !   String to Real translator ! FUNCTION s2r ( string ) implicit none !--------------------------------------------------------------- Input Variables character ( * ), intent ( in ) :: string !-------------------------------------------------------------- Output Variables real ( dp ) :: s2r !--------------------------------------------------------------- Local Variables integer ( ip ) :: ierr !------------------------------------------------------------------------- BEGIN read ( string , fmt =* , iostat = ierr ) s2r if ( ierr . ne . 0 ) then call die ( 'UTILS module: s2r' , 'Real conversion error' , & 'utils.F90' , __ LINE__ , ERROR_UNIT ) endif RETURN !--------------------------------------------------------------------------- END END FUNCTION s2r ! !   Converts from Array of Characters to String ! FUNCTION arr2s ( string_arr , string_size ) implicit none !--------------------------------------------------------------- Input Variables character :: string_arr ( * ) integer ( ip ) :: string_size !-------------------------------------------------------------- Output Variables character ( len = MAX_LENGTH ) :: arr2s !--------------------------------------------------------------- Local Variables character ( len = MAX_LENGTH ) :: str character :: str_arr ( MAX_LENGTH ) equivalence ( str , str_arr ) !------------------------------------------------------------------------- BEGIN str = ' ' str_arr ( 1 : string_size ) = string_arr ( 1 : string_size ) arr2s = TRIM ( str ) RETURN !--------------------------------------------------------------------------- END END FUNCTION arr2s ! !   Arbitrary length version of s2arr, but with matching sizes ! subroutine convert_string_to_array_of_chars ( str , arr ) character ( len =* ), intent ( in ) :: str character , dimension (:), intent ( out ) :: arr integer :: n , i n = len ( str ) if ( size ( arr ) /= n ) call die ( \"convert_str_to_arr\" , \"Size mismatch\" ) do i = 1 , n arr ( i ) = str ( i : i ) enddo end subroutine convert_string_to_array_of_chars ! !   Arbitrary length version of arr2s, but with matching sizes ! subroutine convert_array_of_chars_to_string ( arr , str ) character , dimension (:), intent ( in ) :: arr character ( len =* ), intent ( out ) :: str integer :: n , i n = size ( arr ) if ( len ( str ) /= n ) call die ( \"convert_arr_to_str\" , \"Size mismatch\" ) do i = 1 , n str ( i : i ) = arr ( i ) enddo end subroutine convert_array_of_chars_to_string ! !   Converts from String to Array of Characters ! FUNCTION s2arr ( string ) implicit none !--------------------------------------------------------------- Input Variables character ( len =* ) :: string !-------------------------------------------------------------- Output Variables character :: s2arr ( MAX_LENGTH ) !--------------------------------------------------------------- Local Variables character ( len = MAX_LENGTH ) :: str character :: str_arr ( MAX_LENGTH ) equivalence ( str , str_arr ) !------------------------------------------------------------------------- BEGIN str = ' ' str ( 1 : LEN_TRIM ( string )) = string ( 1 : LEN_TRIM ( string )) s2arr = str_arr RETURN !--------------------------------------------------------------------------- END END FUNCTION s2arr ! !   Converts an integer number to string ! FUNCTION i2s ( num ) implicit none !--------------------------------------------------------------- Input Variables integer ( ip ) :: num !-------------------------------------------------------------- Output Variables character ( 5 ) :: i2s !--------------------------------------------------------------- Local Variables integer ( ip ) :: i , ntmp , zero character :: cc ( 5 ) !------------------------------------------------------------------------- BEGIN if ( num > 99999 . OR . num < 0 ) then call die ( 'UTILS module: i2s' , 'Number is out of range' , & 'utils.F90' , __ LINE__ , ERROR_UNIT ) endif zero = ICHAR ( '0' ) ! 48 is the ascii code of zero ntmp = num do i = 5 , 1 , - 1 cc ( i ) = CHAR ( zero + MOD ( ntmp , 10 )) ntmp = ntmp / 10 enddo i2s = cc ( 1 ) // cc ( 2 ) // cc ( 3 ) // cc ( 4 ) // cc ( 5 ) RETURN !--------------------------------------------------------------------------- END END function i2s ! !   Warning routine ! SUBROUTINE warn ( string ) implicit none !--------------------------------------------------------------- Input Variables character ( len =* ) :: string !------------------------------------------------------------------------- BEGIN write ( OUTPUT_UNIT , '(a,a)' ) '*** WARNING: ' , TRIM ( string ) RETURN !--------------------------------------------------------------------------- END END SUBROUTINE warn ! !   Die routine (Abort/Terminate program) ! SUBROUTINE die ( routine , msg , file , line , unit , rc , cline ) implicit none !--------------------------------------------------------------- Input Variables character ( len =* ), intent ( in ) :: routine , msg character ( len =* ), intent ( in ), optional :: file , cline integer ( ip ), intent ( in ), optional :: line , unit , rc !--------------------------------------------------------------- Local Variables integer ( ip ) :: die_unit !------------------------------------------------------------------------- BEGIN if ( PRESENT ( unit )) then die_unit = unit else die_unit = ERROR_UNIT endif write ( die_unit , '(a)' ) '*************************************************************' write ( die_unit , '(a)' ) 'ERROR' write ( die_unit , '(a)' ) ' ' write ( die_unit , '(3a)' ) TRIM ( routine ), ': ' , TRIM ( msg ) write ( die_unit , '(a)' ) ' ' if ( PRESENT ( cline )) write ( die_unit , '(5x,2a)' ) 'Input line: ' , trim ( cline ) if ( PRESENT ( file )) write ( die_unit , '(5x,2a)' ) 'File: ' , trim ( file ) if ( PRESENT ( line )) write ( die_unit , '(5x,a,i5)' ) 'Line: ' , line write ( die_unit , '(a)' ) '*************************************************************' if ( die_unit . ne . ERROR_UNIT ) then write ( die_unit , '(a)' ) 'Stopping Program' endif ! Replace this by a call to a proper handler STOP 'Stopping Program' !--------------------------------------------------------------------------- END END SUBROUTINE die END MODULE utils","tags":"","loc":"sourcefile/utils.f90.html"},{"title":"io_fdf.F90 – libfdf","text":"Contents Modules io_fdf Source Code io_fdf.F90 Source Code #if defined HAVE_CONFIG_H #  include \"config.h\" #endif #define THIS_FILE \"io_fdf.F90\" !===================================================================== ! ! This file is part of the FDF package. ! ! This module implements an interface to the FORTRAN logical unit ! system. Based on code by Richard Maine. ! ! Logical unit management. Units 0 to min_lun-1 are \"reserved\", ! since most of the \"typical\" files (output, etc) use them. ! ! Logical units min_lun to min_max are managed by this module. ! ! ! September 2007 ! ! !===================================================================== #define ERROR_UNIT  0 #define OUTPUT_UNIT 6 MODULE io_fdf USE utils USE prec USE iso_fortran_env implicit none ! General callable functions public :: io_seterr , io_setout public :: io_geterr , io_getout public :: io_assign , io_reserve public :: io_close , io_status ! Error and Output Units integer ( ip ), private :: stderr = ERROR_UNIT , & stdout = OUTPUT_UNIT ! Unit control variables integer ( ip ), parameter , private :: min_lun = 10 , max_lun = 99 integer ( ip ), parameter , private :: nunits = max_lun - min_lun + 1 logical , private :: lun_is_free ( min_lun : max_lun ) = . TRUE . CONTAINS ! !   Set IO error unit ! SUBROUTINE io_seterr ( unit ) implicit none !-------------------------------------------------------------- Output Variables integer ( ip ), intent ( inout ) :: unit !------------------------------------------------------------------------- BEGIN stderr = unit RETURN !--------------------------------------------------------------------------- END END SUBROUTINE io_seterr ! !   Set IO output unit ! SUBROUTINE io_setout ( unit ) implicit none !-------------------------------------------------------------- Output Variables integer ( ip ), intent ( inout ) :: unit !------------------------------------------------------------------------- BEGIN stdout = unit RETURN !--------------------------------------------------------------------------- END END SUBROUTINE io_setout ! !   Get IO error unit ! SUBROUTINE io_geterr ( unit ) implicit none !-------------------------------------------------------------- Output Variables integer ( ip ), intent ( inout ) :: unit !------------------------------------------------------------------------- BEGIN unit = stderr RETURN !--------------------------------------------------------------------------- END END SUBROUTINE io_geterr ! !   Get IO output unit ! SUBROUTINE io_getout ( unit ) implicit none !-------------------------------------------------------------- Output Variables integer ( ip ), intent ( inout ) :: unit !------------------------------------------------------------------------- BEGIN unit = stdout RETURN !--------------------------------------------------------------------------- END END SUBROUTINE io_getout ! !   Looks for a free unit and assigns it to lun ! SUBROUTINE io_assign ( lun ) implicit none !-------------------------------------------------------------- Output Variables integer ( ip ), intent ( inout ) :: lun !--------------------------------------------------------------- Local Variables logical :: used , found integer ( ip ) :: i , iostat !------------------------------------------------------------------------- BEGIN i = min_lun found = . FALSE . do while ((. not . found ) . and . ( i . le . max_lun )) if ( lun_is_free ( i )) then INQUIRE ( unit = i , opened = used , iostat = iostat ) if ( iostat . ne . 0 ) used = . TRUE . if (. not . used ) then lun = i found = . TRUE . endif lun_is_free ( i ) = . FALSE . endif i = i + 1 enddo if (. not . found ) then call die ( 'IO module: io_assign' , 'No LUNs available' , & THIS_FILE , __ LINE__ ) endif RETURN !--------------------------------------------------------------------------- END END SUBROUTINE io_assign ! !   Useful to specify that one needs to use a particular unit number !   for example, assume some legacy code expects to work with unit 15: !   call io_reserve(15)   ! this call at the beginning of the program !   ... !   open(15,....) ! SUBROUTINE io_reserve ( lun ) implicit none !-------------------------------------------------------------- Output Variables integer ( ip ), intent ( inout ) :: lun !--------------------------------------------------------------- Local Variables logical :: used character ( 80 ) :: msg integer ( ip ) :: iostat !------------------------------------------------------------------------- BEGIN INQUIRE ( unit = lun , opened = used , iostat = iostat ) if ( iostat . ne . 0 ) used = . TRUE . if ( used ) then write ( msg , '(a,i3,a)' ) & 'Cannot reserve unit' , lun , '. Already connected' call die ( 'IO module: io_reserve' , msg , THIS_FILE , __ LINE__ ) endif if (( lun . ge . min_lun ) . and . ( lun . le . max_lun )) & lun_is_free ( lun ) = . FALSE . RETURN !--------------------------------------------------------------------------- END END SUBROUTINE io_reserve ! !   Use this routine instead of a simple close ! SUBROUTINE io_close ( lun ) implicit none !-------------------------------------------------------------- Output Variables integer ( ip ), intent ( inout ) :: lun !------------------------------------------------------------------------- BEGIN CLOSE ( lun ) if (( lun . ge . min_lun ) . and . ( lun . le . max_lun )) & lun_is_free ( lun ) = . TRUE . RETURN !--------------------------------------------------------------------------- END END SUBROUTINE io_close ! !   Prints a list of the connected logical units and the names of !   the associated files ! SUBROUTINE io_status () implicit none !--------------------------------------------------------------- Local Variables logical :: opened , named character ( 80 ) :: filename character ( 11 ) :: form integer ( ip ) :: i , iostat !------------------------------------------------------------------------- BEGIN write ( stdout , '(a)' ) '******** io_status ********' do i = 0 , max_lun INQUIRE ( i , opened = opened , named = named , name = filename , & form = form , iostat = iostat ) if ( iostat . eq . 0 ) then if ( opened ) then if ( named ) then write ( stdout , '(i4,5x,a,5x,a)' ) i , form , filename else write ( stdout , '(i4,5x,a,5x,a)' ) i , form , 'No name available' endif endif else write ( stdout , '(i4,5x,a,5x,a)' ) i , 'IOSTAT error' endif enddo write ( stdout , '(a)' ) '********           ********' RETURN !--------------------------------------------------------------------------- END END SUBROUTINE io_status END MODULE io_fdf","tags":"","loc":"sourcefile/io_fdf.f90.html"},{"title":"prec.F90 – libfdf","text":"Contents Modules prec Source Code prec.F90 Source Code #if defined HAVE_CONFIG_H #  include \"config.h\" #endif !===================================================================== ! ! This file is part of the FDF package. ! ! This module provides precision for integer and reals in FDF library. ! At this moment this module contains precision specification for: ! !   a) Integer precision     (ip) !   b) Single Real precision (sp) !   c) Double Real precision (dp) ! ! ! September 2007 ! ! !===================================================================== MODULE prec ! ! Precision handling ! Kind parameters ! integer , parameter :: ip = selected_int_kind ( 9 ) integer , parameter :: sp = selected_real_kind ( 6 , 20 ) integer , parameter :: dp = selected_real_kind ( 14 , 100 ) END MODULE prec","tags":"","loc":"sourcefile/prec.f90.html"},{"title":"parse.F90 – libfdf","text":"Contents Modules parse Source Code parse.F90 Source Code #if defined HAVE_CONFIG_H #  include \"config.h\" #endif #define THIS_FILE \"parse.F90\" !===================================================================== ! ! This file is part of the FDF package. ! ! This module provides a simple yet powerful way to analyze the information ! in a string (such as an input line). ! ! Routine, 'digest' takes as input a string 'line' and returns a pointer ! to a derived type 'parsed_line': ! !   Parsed line info (ntokens, token info and identification) !   Note that the token characters are stored in a single \"line\", !   and addressed using the starting and ending points. !   This avoids the use of dynamic memory without loss of functionality. ! !  type, public :: parsed_line !    integer(ip)               :: ntokens !    character(len=MAX_LENGTH) :: line !    integer(ip)               :: first(MAX_NTOKENS) !    integer(ip)               :: last(MAX_NTOKENS) !    character(len=1)          :: id(MAX_NTOKENS) !  end type parsed_line ! ! which holds a list of tokens and token tags (id). The ! parsing (split string into tokens) is done by a helper routine ! 'parses' which currently behaves according to the FDF standard. ! Each token is classified by helper routine 'morphol' and a token ! id is assigned in the following way: ! ! * Tokens that can be read as real numbers are assigned to class ! 'values' and given a token id 'v'. These are further classified as ! 'integers' (id 'i') or 'reals' (id 'r'). ! * There are two list classes: !    'a' == integer list !    'c' == real list !    'e' == real or integer list ! * All other tokens are tagged as 'names' (id 'n'). ! ! The recommended usage follows the outline: ! !     use parse !     character(len=?) line !     type(parsed_line), pointer :: p !     ... !     p=>digest(line) !     (extract information from p) !     call destroy(p) ! ! Note the pointer assignment and the explicit call to a destroyer ! routine that frees the storage associated to p. ! ! The information is extracted by module procedures that fall into three ! classes: ! ! a) Enquiry functions: 'search' and 'match' ! ! *  'search' determines whether a token in 'line' matches the given !    string, optionally returning an index. The search is !    case-insensitive by default, but this can be changed by supplying !    an extra procedure argument 'eq_func' with interface: ! !       interface !         function eq_func(s1,s2) !           logical eq_func !           character(len=*), intent(in) :: s1,s2 !         end function eq_func !       end interface ! !    We have two different implementations of 'search' function, !    through a wrapper (function overload): ! !       interface search !         module procedure search_fun !         module procedure search_sub !       end interface ! !     1. %FUNCTION search_fun(string, pline_fun, after, eq_func) !       New search implementation. 'search' function returns !       the index of the token that matches with the string or !       -1 if not found. Leaves 'pline_fun' structure pointing !       to the token in the FDF structure. ! !     2. %FUNCTION search_sub(pline_sub, string, ind, after, eq_func) !       This is the old prototype for backward compatibility. !       Returns .TRUE. if the string is found in the parsed line !       else .FALSE. Moreover can return the index of the token !       in the line if 'ind' is specified. ! !    Example:  if (search('Mary', p) .ne. -1) ... !    will return the index of the first token that matches !    \"Mary\", or -1 if not found. ! !    This function can take an optional keyword 'after=' (see below). ! ! *  'substring_search' does not match whole tokens, but substrings in !    tokens. And it uses the *case sensitive* Fortran 'index' function. ! *  'match' is probably the most powerful routine in the module. It !    checks whether the token morphology of 'line' conforms to the !    sequence of characters specified. For example, ! !    if (match(p,'nii')) ... ! !    returns .TRUE. if 'line' contains at least three tokens and they are !    a 'name' and two 'integers'. !    Apart from the 'primitive' one-character ids, there is the !    possibility of using 'compound' virtual ids for generalized matchings: ! !    - A 'v' ('value') is matched by both an 'integer' and a 'real'. !    - A 'j' is matched by both an 'integer' and a 'name'. !    - A 's' is matched by an 'integer', a 'real', and a 'name'. !    - A 'x' is matched by any kind of token. !    - A 'a' is matched by a list with integers !    - A 'c' is matched by a list with reals !    - A 'e' is matched by a list with integers or reals !    - A 'd' is reserved for future dictionaries... !    This function can take an optional keyword 'after=' (see below). ! ! b) Number functions: ntokens ('n|i|r|b|e|l|a'), nnames ('n'), nreals ('r'), !                      nintegers ('i'), nvalues ('i|r'), nblocks ('b'), !                      nendblocks ('e'), nlabels ('l'), nlists('a|c'), !                      nintegerlists ('a'), nreallists('c') ! !    These functions return the number of tokens of each kind in 'line': ! !    number_of_energies = nreals(p) ! !    These functions can take an optional keyword 'after=' (see below). ! ! c) Extraction functions: tokens ('n|i|r|b|e|l|a|c'), names ('n'), reals ('r'), !                          characters, !                          integers ('i'), values ('i|r'), blocks ('b'), !                          endblocks ('e'), labels ('l'), !                          integerlists('a') <- a subroutine !                          reallists('c') <- a subroutine !                          valuelists('a|c') <- a subroutine ! !    These functions return a piece of data which corresponds to a token !    of the specified kind with sequence number matching the index !    provided. For example, ! !    nlevels = integers(p,2) ! !    assigns to variable 'nlevels' the second integer in 'line'. !    Execution stops in the assignment cannot be made. The user should !    call the corresponding 'number' routine to make sure there are !    enough tokens of the given kind. ! !    Function 'characters' returns a string of characters spanning !    several tokens (with the original whitespace) ! !    These functions can take an optional keyword 'after=' (see below). ! ! ! By default, the routines in the module perform any indexing from the ! beginning of 'line', in such a way that the first token is assigned the ! index 1. It is possible to specify a given token as 'origin' by using ! the 'after=' optional keyword. For example: ! !     if (search(p, 'P', ind=jp)) then            # Old implementation !       if (match(p, 'i', after=jp) npol = integers(p, 1, after=jp) !     endif ! ! first checks whether 'P' is found in 'line'. If so, 'match' is used to ! check whether it is followed by at least an 'integer'. If so, its ! valued is assigned to variable 'npol'. ! ! If the 'after=' optional keyword is used in routine 'search', the ! returned index is absolute, not relative. For example, to get the ! real number coming right after the first 'Q' which appears to the ! right of the 'P' found above: ! !     if (search(p, 'Q', ind=jq, after=jp)) then  # Old implementation !       if (match(p, 'r', after=jq) energy = reals(p, 1, after=jq) !     endif ! ! Alberto Garcia, 1995-2007, original implementation ! Raul de la Cruz, September 2007 ! Alberto Garcia, July 2008 ! !======================================================================== #define ERROR_UNIT  0 MODULE parse USE utils USE prec implicit none ! Serialization functions public :: serialize_pline , recreate_pline ! Internal functions: build parsed line and morphology private :: create private :: parses , morphol ! Digest, match and search public :: digest , destroy public :: match , search , substring_search ! Routines to get number and items public :: nintegers , nreals , nvalues , nnames public :: nblocks , nendblocks , nlabels , ntokens public :: integers , reals , values , names public :: blocks , endblocks , labels , tokens , characters public :: nlists , nintegerlists , nreallists public :: integerlists , reallists , valuelists ! Change morphology public :: setmorphol ! Integer|Real check routines private :: is_integer , is_value ! Debugging config routines public :: setdebug , setlog ! Internal constants logical , private :: parse_debug = . FALSE . integer ( ip ), private :: parse_log = ERROR_UNIT integer ( ip ), parameter , private :: MAX_NTOKENS = 50 ! Length of string encoding plines integer , parameter , public :: SERIALIZED_LENGTH = MAX_LENGTH + 4 + 10 * MAX_NTOKENS !   Parsed line info (ntokens, token info and identification) !   Note that the token characters are stored in a single \"line\", !   and addressed using the starting and ending points. !   This avoids the use of dynamic memory without loss of functionality. type , public :: parsed_line integer ( ip ) :: ntokens character ( len = MAX_LENGTH ) :: line integer ( ip ) :: first ( MAX_NTOKENS ) integer ( ip ) :: last ( MAX_NTOKENS ) character ( len = 1 ) :: id ( MAX_NTOKENS ) end type parsed_line ! Search wrapper (return index as function or subroutine) interface search module procedure search_fun module procedure search_sub end interface CONTAINS ! !   Creates parsed_line structure ! SUBROUTINE create ( pline ) implicit none !------------------------------------------------ Output Variables type ( parsed_line ), pointer :: pline !------------------------------------------------- Local Variables integer ( ip ) :: ierr !----------------------------------------------------------- BEGIN if ( ASSOCIATED ( pline )) call destroy ( pline ) ALLOCATE ( pline , stat = ierr ) if ( ierr . ne . 0 ) then call die ( 'PARSE module: create' , 'Error allocating pline' , & THIS_FILE , __ LINE__ , rc = ierr ) endif !------------------------------------------------------------- END END SUBROUTINE create ! !   Frees parsed_line structure ! SUBROUTINE destroy ( pline ) implicit none !------------------------------------------------ Output Variables type ( parsed_line ), pointer :: pline !----------------------------------------------------------- BEGIN if ( ASSOCIATED ( pline )) then DEALLOCATE ( pline ) NULLIFY ( pline ) endif !------------------------------------------------------------- END END SUBROUTINE destroy ! !   Return the number of items of a certain class among the tokens. ! FUNCTION nitems ( class , pline , after ) implicit none !------------------------------------------------- Input Variables character :: class integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables integer ( ip ) :: nitems !------------------------------------------------- Local Variables character ( 80 ) :: msg integer ( ip ) :: i , starting_pos !----------------------------------------------------------- BEGIN if ( PRESENT ( after )) then if ( after . lt . 0 ) then write ( msg , * ) 'Wrong starting position when processing class: ' , & class call die ( 'PARSE module: nitems' , msg , THIS_FILE , __ LINE__ ) endif starting_pos = after else starting_pos = 0 endif nitems = 0 do i = starting_pos + 1 , pline % ntokens if ( leqi ( pline % id ( i ), class )) nitems = nitems + 1 enddo RETURN !------------------------------------------------------------- END END FUNCTION nitems ! !   Return the number of integers in the tokens. ! FUNCTION nintegers ( pline , after ) implicit none !------------------------------------------------- Input Variables integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables integer ( ip ) :: nintegers !----------------------------------------------------------- BEGIN nintegers = nitems ( 'i' , pline , after ) RETURN !------------------------------------------------------------- END END FUNCTION nintegers ! !   Return the number of reals in the tokens. ! FUNCTION nreals ( pline , after ) implicit none !------------------------------------------------- Input Variables integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables integer ( ip ) :: nreals !----------------------------------------------------------- BEGIN nreals = nitems ( 'r' , pline , after ) RETURN !------------------------------------------------------------- END END FUNCTION nreals ! !   Return the number of values in the tokens. ! FUNCTION nvalues ( pline , after ) implicit none !------------------------------------------------- Input Variables integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables integer ( ip ) :: nvalues !----------------------------------------------------------- BEGIN nvalues = nitems ( 'i' , pline , after ) + nitems ( 'r' , pline , after ) RETURN !------------------------------------------------------------- END END FUNCTION nvalues ! !   Return the number of lists in the tokens. ! FUNCTION nlists ( pline , after ) implicit none !------------------------------------------------- Input Variables integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables integer ( ip ) :: nlists !----------------------------------------------------------- BEGIN nlists = nitems ( 'a' , pline , after ) + nitems ( 'c' , pline , after ) RETURN !------------------------------------------------------------- END END FUNCTION nlists ! !   Return the number of integer lists in the tokens. ! FUNCTION nintegerlists ( pline , after ) implicit none !------------------------------------------------- Input Variables integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables integer ( ip ) :: nintegerlists !----------------------------------------------------------- BEGIN nintegerlists = nitems ( 'a' , pline , after ) RETURN !------------------------------------------------------------- END END FUNCTION nintegerlists ! !   Return the number of real lists in the tokens. ! FUNCTION nreallists ( pline , after ) implicit none !------------------------------------------------- Input Variables integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables integer ( ip ) :: nreallists !----------------------------------------------------------- BEGIN nreallists = nitems ( 'c' , pline , after ) RETURN !------------------------------------------------------------- END END FUNCTION nreallists ! !   Return the number of names in the tokens. ! FUNCTION nnames ( pline , after ) implicit none !------------------------------------------------- Input Variables integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables integer ( ip ) :: nnames !----------------------------------------------------------- BEGIN nnames = nitems ( 'n' , pline , after ) RETURN !------------------------------------------------------------- END END FUNCTION nnames ! !   Return the number of blocks in the tokens. ! FUNCTION nblocks ( pline , after ) implicit none !------------------------------------------------- Input Variables integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables integer ( ip ) :: nblocks !----------------------------------------------------------- BEGIN nblocks = nitems ( 'b' , pline , after ) RETURN !------------------------------------------------------------- END END FUNCTION nblocks ! !   Return the number of endblocks in the tokens. ! FUNCTION nendblocks ( pline , after ) implicit none !------------------------------------------------- Input Variables integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables integer ( ip ) :: nendblocks !----------------------------------------------------------- BEGIN nendblocks = nitems ( 'e' , pline , after ) RETURN !------------------------------------------------------------- END END FUNCTION nendblocks ! !   Return the number of labels in the tokens. ! FUNCTION nlabels ( pline , after ) implicit none !------------------------------------------------- Input Variables integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables integer ( ip ) :: nlabels !----------------------------------------------------------- BEGIN nlabels = nitems ( 'l' , pline , after ) RETURN !------------------------------------------------------------- END END FUNCTION nlabels ! !   Return the number of tokens. ! FUNCTION ntokens ( pline , after ) implicit none !------------------------------------------------- Input Variables integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables integer ( ip ) :: ntokens !------------------------------------------------- Local Variables integer ( ip ) :: starting_pos !----------------------------------------------------------- BEGIN if ( PRESENT ( after )) then if ( after . lt . 0 ) then call die ( 'PARSE module: ntokens' , 'Wrong starting position' , & THIS_FILE , __ LINE__ ) endif starting_pos = after else starting_pos = 0 endif ntokens = pline % ntokens - starting_pos if ( ntokens . lt . 0 ) then call die ( 'PARSE module: ntokens' , 'Wrong starting position' , & THIS_FILE , __ LINE__ ) endif RETURN !------------------------------------------------------------- END END FUNCTION ntokens ! !   Return a given integer token, specifying it by its sequence !   number. It is also possible to make the sequence start after !   a given token number in the line. ! FUNCTION integers ( pline , ind , after ) implicit none !------------------------------------------------- Input Variables integer ( ip ), intent ( in ) :: ind integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables integer ( ip ) :: integers !------------------------------------------------- Local Variables logical :: found integer ( ip ) :: i , j , starting_pos !----------------------------------------------------------- BEGIN if ( PRESENT ( after )) then if ( after . lt . 0 ) then call die ( 'PARSE module: integers' , 'Wrong starting position' , & THIS_FILE , __ LINE__ , cline = characters ( pline , 1 , - 1 )) endif starting_pos = after else starting_pos = 0 endif i = starting_pos + 1 j = 0 found = . FALSE . do while ((. not . found ) . and . ( i . le . pline % ntokens )) if ( leqi ( pline % id ( i ), 'i' )) j = j + 1 if ( j . eq . ind ) then integers = s2i ( tokens ( pline , i )) found = . TRUE . endif i = i + 1 enddo if (. not . found ) then call die ( 'PARSE module: integers' , 'Not enough integers in line' , & THIS_FILE , __ LINE__ , cline = characters ( pline , 1 , - 1 )) endif RETURN !------------------------------------------------------------- END END FUNCTION integers ! !   Return a given real token, specifying it by its sequence !   number. It is also possible to make the sequence start after !   a given token number in the line. ! FUNCTION reals ( pline , ind , after ) implicit none !------------------------------------------------- Input Variables integer ( ip ), intent ( in ) :: ind integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables real ( dp ) :: reals !------------------------------------------------- Local Variables logical :: found integer ( ip ) :: i , j , starting_pos !----------------------------------------------------------- BEGIN if ( PRESENT ( after )) then if ( after . lt . 0 ) then call die ( 'PARSE module: reals' , 'Wrong starting position' , & THIS_FILE , __ LINE__ , cline = characters ( pline , 1 , - 1 )) endif starting_pos = after else starting_pos = 0 endif i = starting_pos + 1 j = 0 found = . FALSE . do while ((. not . found ) . and . ( i . le . pline % ntokens )) if ( leqi ( pline % id ( i ), 'r' )) j = j + 1 if ( j . eq . ind ) then reals = s2r ( tokens ( pline , i )) found = . TRUE . endif i = i + 1 enddo if (. not . found ) then call die ( 'PARSE module: reals' , 'Not enough reals in line' , & THIS_FILE , __ LINE__ , cline = characters ( pline , 1 , - 1 )) endif RETURN !------------------------------------------------------------- END END FUNCTION reals ! !   Return a given list token, specifying it by its sequence !   number. It is also possible to make the sequence start after !   a given token number in the line. ! SUBROUTINE reallists ( pline , ind , nv , list , after ) implicit none !------------------------------------------------- Input Variables integer ( ip ), intent ( in ) :: ind integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables integer ( ip ) :: nv real ( dp ) :: list ( nv ) !------------------------------------------------- Local Variables logical :: found integer ( ip ) :: i , j , starting_pos character ( len = MAX_LENGTH ) :: llist , sep type ( parsed_line ), pointer :: lpline integer ( ip ) :: iR real ( dp ) :: lR , uR , sR integer ( ip ) :: ri integer ( ip ) :: ti , lprev , li logical :: count , is_del !----------------------------------------------------------- BEGIN if ( PRESENT ( after )) then if ( after . lt . 0 ) then call die ( 'PARSE module: reallists' , 'Wrong starting position' , & THIS_FILE , __ LINE__ ) endif starting_pos = after else starting_pos = 0 endif i = starting_pos + 1 j = 0 found = . FALSE . count = . FALSE . do while ((. not . found ) . and . ( i . le . pline % ntokens )) if ( leqi ( pline % id ( i ), 'c' )) j = j + 1 if ( j . eq . ind ) then found = . TRUE . ! Parse token list llist = tokens ( pline , i ) ! The list does have the markers attached (remove them) li = len_trim ( llist ) - 1 llist = trim ( llist ( 2 : li )) lpline => digest ( llist ) ! We now have converted the list into a ! parseable line ! Does the user request length? count = nv <= 0 li = 0 ! counter for the number of items in the list ti = 1 ! the current token iterator is_del = . false . do while ( ti < lpline % ntokens ) ! First we need to check whether we have a list delimiter next if ( leqi ( lpline % id ( ti + 1 ), 'n' )) then sep = names ( lpline , 1 , after = ti ) is_del = leqi ( sep , ',' ) ! apparently ',' is not a token end if if ( leqi ( lpline % id ( ti + 1 ), 'n' ). and . . not . is_del ) then ! We have a range if ( lpline % ntokens <= ti + 1 ) then call die ( 'PARSE module: reallists' , 'Missing end range' , & THIS_FILE , __ LINE__ ) end if if ( . not . scan ( lpline % id ( ti ), 'ir' ) > 0 . or . & . not . scan ( lpline % id ( ti + 2 ), 'ir' ) > 0 ) then call die ( 'PARSE module: reallists' , 'Range is not well-defined' , & THIS_FILE , __ LINE__ ) end if ! grab the seperator sep = names ( lpline , 1 , after = ti ) if ( leqi ( sep , 'to' ) . or . leqi ( sep , ':' ) . or . & leqi ( sep , '--' ) . or . leqi ( sep , '---' ) ) then ! Sort the range lR = values ( lpline , 1 , after = ti - 1 ) uR = values ( lpline , 1 , after = ti + 1 ) sR = 1._dp ! Figure out if we have a step in the range if ( ti + 3 < lpline % ntokens ) then if ( leqi ( lpline % id ( ti + 3 ), 'n' ) . and . & scan ( lpline % id ( ti + 4 ), 'ir' ) > 0 ) then sep = names ( lpline , 1 , after = ti + 2 ) if ( leqi ( sep , 'step' ) ) then sR = values ( lpline , 1 , after = ti + 3 ) ! step after the 'step <val>' ti = ti + 2 end if end if end if ! Correct sign of stepper if ( lR <= uR ) sR = abs ( sR ) if ( uR < lR ) sR = - abs ( sR ) if ( sR == 0._dp ) call die ( 'PARSE module: reallists' , & 'Stepping a list cannot be stepped by 0' , & THIS_FILE , __ LINE__ ) ! By adding 0.01 % we should capture a large ! percentage of ill-defined ranges !    lR = 1. ; uR = 1.9999 ; sR = 0.5 do iR = 0 , int ( ( uR - lR ) / sR + sR * 0.0001_dp ) call add_exit ( count , li , nv , lR + sR * iR ) end do ! jump across the range ti = ti + 2 else call die ( 'PARSE module: reallists' , 'Unknown token in list' , & THIS_FILE , __ LINE__ ) end if elseif ( scan ( lpline % id ( ti ), 'ir' ) > 0 ) then call add_exit ( count , li , nv , values ( lpline , 1 , after = ti - 1 )) end if ti = ti + 1 if ( is_del ) then ti = ti + 1 is_del = . false . end if end do ! Read last element (or the only element if one is given) if ( ti == lpline % ntokens ) then if ( leqi ( lpline % id ( ti ), 'v' )) then call add_exit ( count , li , nv , values ( lpline , 1 , after = ti - 1 )) end if end if ! Clean-up parsed list-line call destroy ( lpline ) if ( count ) then ! User explicitly asked for acount nv = li else if ( nv /= li ) then ! Update the number of elements returned nv = li end if endif i = i + 1 enddo if (. not . found ) then call die ( 'PARSE module: reallists' , 'Not enough lists in line' , & THIS_FILE , __ LINE__ ) end if RETURN !------------------------------------------------------------- END contains subroutine add_exit ( is_counting , idx , nv , val ) logical , intent ( in ) :: is_counting integer , intent ( inout ) :: idx integer , intent ( in ) :: nv real ( dp ), intent ( in ) :: val idx = idx + 1 if ( . not . is_counting ) then if ( idx > nv ) then found = . false . else list ( idx ) = val end if end if end subroutine add_exit END SUBROUTINE reallists ! !   Return a given list token, specifying it by its sequence !   number. It is also possible to make the sequence start after !   a given token number in the line. ! SUBROUTINE valuelists ( pline , ind , nv , list , after ) implicit none !------------------------------------------------- Input Variables integer ( ip ), intent ( in ) :: ind integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables integer ( ip ) :: nv real ( dp ) :: list ( nv ) !------------------------------------------------- Local Variables logical :: found integer ( ip ) :: i , j , starting_pos character ( len = MAX_LENGTH ) :: llist , sep type ( parsed_line ), pointer :: lpline integer ( ip ) :: iR real ( dp ) :: lR , uR , sR integer ( ip ) :: ri integer ( ip ) :: ti , lprev , li logical :: count , is_del !----------------------------------------------------------- BEGIN if ( PRESENT ( after )) then if ( after . lt . 0 ) then call die ( 'PARSE module: valuelists' , 'Wrong starting position' , & THIS_FILE , __ LINE__ ) endif starting_pos = after else starting_pos = 0 endif i = starting_pos + 1 j = 0 found = . FALSE . count = . FALSE . do while ((. not . found ) . and . ( i . le . pline % ntokens )) if ( scan ( pline % id ( i ), 'ac' ) > 0 ) j = j + 1 if ( j . eq . ind ) then found = . TRUE . ! Parse token list llist = tokens ( pline , i ) ! The list does have the markers attached (remove them) li = len_trim ( llist ) - 1 llist = trim ( llist ( 2 : li )) lpline => digest ( llist ) ! We now have converted the list into a ! parseable line ! Does the user request length? count = nv <= 0 li = 0 ! counter for the number of items in the list ti = 1 ! the current token iterator is_del = . false . do while ( ti < lpline % ntokens ) ! First we need to check whether we have a list delimiter next if ( leqi ( lpline % id ( ti + 1 ), 'n' )) then sep = names ( lpline , 1 , after = ti ) is_del = leqi ( sep , ',' ) ! apparently ',' is not a token end if if ( leqi ( lpline % id ( ti + 1 ), 'n' ). and . . not . is_del ) then ! We have a range if ( lpline % ntokens <= ti + 1 ) then call die ( 'PARSE module: valuelists' , 'Missing end range' , & THIS_FILE , __ LINE__ ) end if if ( . not . scan ( lpline % id ( ti ), 'ir' ) > 0 . or . & . not . scan ( lpline % id ( ti + 2 ), 'ir' ) > 0 ) then call die ( 'PARSE module: valuelists' , 'Range is not well-defined' , & THIS_FILE , __ LINE__ ) end if ! grab the seperator sep = names ( lpline , 1 , after = ti ) if ( leqi ( sep , 'to' ) . or . leqi ( sep , ':' ) . or . & leqi ( sep , '--' ) . or . leqi ( sep , '---' ) ) then ! Sort the range lR = values ( lpline , 1 , after = ti - 1 ) uR = values ( lpline , 1 , after = ti + 1 ) sR = 1._dp ! Figure out if we have a step in the range if ( ti + 3 < lpline % ntokens ) then if ( leqi ( lpline % id ( ti + 3 ), 'n' ) . and . & scan ( lpline % id ( ti + 4 ), 'ir' ) > 0 ) then sep = names ( lpline , 1 , after = ti + 2 ) if ( leqi ( sep , 'step' ) ) then sR = values ( lpline , 1 , after = ti + 3 ) ! step after the 'step <val>' ti = ti + 2 end if end if end if ! Correct sign of stepper if ( lR <= uR ) sR = abs ( sR ) if ( uR < lR ) sR = - abs ( sR ) if ( sR == 0._dp ) call die ( 'PARSE module: valuelists' , & 'Stepping a list cannot be stepped by 0' , & THIS_FILE , __ LINE__ ) ! By adding 0.01 % we should capture a large ! percentage of ill-defined ranges !    lR = 1. ; uR = 1.9999 ; sR = 0.5 do iR = 0 , int ( ( uR - lR ) / sR + sR * 0.0001_dp ) call add_exit ( count , li , nv , lR + sR * iR ) end do ! jump across the range ti = ti + 2 else call die ( 'PARSE module: valuelists' , 'Unknown token in list' , & THIS_FILE , __ LINE__ ) end if elseif ( scan ( lpline % id ( ti ), 'ir' ) > 0 ) then call add_exit ( count , li , nv , values ( lpline , 1 , after = ti - 1 )) end if ti = ti + 1 if ( is_del ) then ti = ti + 1 is_del = . false . end if end do ! Read last element (or the only element if one is given) if ( ti == lpline % ntokens ) then if ( scan ( lpline % id ( ti ), 'ir' ) > 0 ) then call add_exit ( count , li , nv , values ( lpline , 1 , after = ti - 1 )) end if end if ! Clean-up parsed list-line call destroy ( lpline ) if ( count ) then ! User explicitly asked for acount nv = li else if ( nv /= li ) then ! Update the number of elements returned nv = li end if endif i = i + 1 enddo if (. not . found ) then call die ( 'PARSE module: valuelists' , 'Not enough lists in line' , & THIS_FILE , __ LINE__ ) end if RETURN !------------------------------------------------------------- END contains subroutine add_exit ( is_counting , idx , nv , val ) logical , intent ( in ) :: is_counting integer , intent ( inout ) :: idx integer , intent ( in ) :: nv real ( dp ), intent ( in ) :: val idx = idx + 1 if ( . not . is_counting ) then if ( idx > nv ) then found = . false . else list ( idx ) = val end if end if end subroutine add_exit END SUBROUTINE valuelists ! !   Return a given integer list token, specifying it by its sequence !   number. It is also possible to make the sequence start after !   a given token number in the line. ! SUBROUTINE integerlists ( pline , ind , ni , list , after ) implicit none !------------------------------------------------- Input Variables integer ( ip ), intent ( in ) :: ind integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables integer ( ip ) :: ni , list ( ni ) !------------------------------------------------- Local Variables logical :: found integer ( ip ) :: i , j , starting_pos character ( len = MAX_LENGTH ) :: llist , sep type ( parsed_line ), pointer :: lpline integer ( ip ) :: iR , lR , uR , sR integer ( ip ) :: ti , lprev , li logical :: count , is_del !----------------------------------------------------------- BEGIN if ( PRESENT ( after )) then if ( after . lt . 0 ) then call die ( 'PARSE module: integerlists' , & 'Wrong starting position' , THIS_FILE , __ LINE__ ) endif starting_pos = after else starting_pos = 0 endif i = starting_pos + 1 j = 0 found = . FALSE . count = . FALSE . do while ((. not . found ) . and . ( i . le . pline % ntokens )) if ( leqi ( pline % id ( i ), 'a' )) j = j + 1 if ( j . eq . ind ) then found = . TRUE . ! Parse token list llist = tokens ( pline , i ) ! The list does have the markers attached (remove them) li = len_trim ( llist ) - 1 llist = trim ( llist ( 2 : li )) lpline => digest ( llist ) ! We now have converted the list into a ! parseable line ! Does the user request length? count = ni <= 0 li = 0 ! counter for the number of items in the list ti = 1 ! the current token iterator is_del = . false . do while ( ti < lpline % ntokens ) ! First we need to check whether we have a list delimiter next if ( leqi ( lpline % id ( ti + 1 ), 'n' )) then sep = names ( lpline , 1 , after = ti ) is_del = leqi ( sep , ',' ) ! apparently ',' is not a token end if if ( leqi ( lpline % id ( ti + 1 ), 'n' ). and . . not . is_del ) then ! We have a range if ( lpline % ntokens <= ti + 1 ) then call die ( 'PARSE module: integerlists' , & 'Missing end range' , THIS_FILE , __ LINE__ ) end if if ( . not . leqi ( lpline % id ( ti ), 'i' ). or . & . not . leqi ( lpline % id ( ti + 2 ), 'i' ) ) then call die ( 'PARSE module: integerlists' , & 'Range is not well-defined' , THIS_FILE , __ LINE__ ) end if ! grab the seperator sep = names ( lpline , 1 , after = ti ) if ( leqi ( sep , 'to' ) . or . leqi ( sep , ':' ) . or . & leqi ( sep , '--' ) . or . leqi ( sep , '---' ) ) then ! Sort the range lR = integers ( lpline , 1 , after = ti - 1 ) uR = integers ( lpline , 1 , after = ti + 1 ) sR = 1 ! Figure out if we have a step in the range if ( ti + 3 < lpline % ntokens ) then if ( leqi ( lpline % id ( ti + 3 ), 'n' ) . and . & leqi ( lpline % id ( ti + 4 ), 'i' ) ) then sep = names ( lpline , 1 , after = ti + 2 ) if ( leqi ( sep , 'step' ) ) then sR = integers ( lpline , 1 , after = ti + 3 ) ! step after the 'step <val>' ti = ti + 2 end if end if end if ! Correct sign of stepper if ( lR <= uR ) sR = abs ( sR ) if ( uR < lR ) sR = - abs ( sR ) if ( sR == 0 ) call die ( 'PARSE module: integerlists' , & 'Stepping a list cannot be stepped by 0' , & THIS_FILE , __ LINE__ ) do iR = lR , uR , sR call add_exit ( count , li , ni , iR ) end do ! jump across the range ti = ti + 2 else call die ( 'PARSE module: integerlists' , & 'Unknown token in list' , THIS_FILE , __ LINE__ ) end if elseif ( leqi ( lpline % id ( ti ), 'i' )) then call add_exit ( count , li , ni , integers ( lpline , 1 , after = ti - 1 )) end if ti = ti + 1 if ( is_del ) then ti = ti + 1 is_del = . false . end if end do ! Read last element (or the only element if one is given) if ( ti == lpline % ntokens ) then if ( leqi ( lpline % id ( ti ), 'i' )) then call add_exit ( count , li , ni , integers ( lpline , 1 , after = ti - 1 )) end if end if ! Clean-up parsed list-line call destroy ( lpline ) if ( count ) then ! User explicitly asked for acount ni = li else if ( ni /= li ) then ! Update the number of elements returned ni = li end if endif i = i + 1 enddo if (. not . found ) then call die ( 'PARSE module: integerlists' , & 'Not enough lists in line' , THIS_FILE , __ LINE__ ) end if RETURN !------------------------------------------------------------- END contains subroutine add_exit ( is_counting , idx , ni , val ) logical , intent ( in ) :: is_counting integer , intent ( inout ) :: idx integer , intent ( in ) :: ni , val idx = idx + 1 if ( . not . is_counting ) then if ( idx > ni ) then found = . false . else list ( idx ) = val end if end if end subroutine add_exit END SUBROUTINE integerlists ! !   Return a given [integer|real] token, specifying it by its sequence !   number. It is also possible to make the sequence start after !   a given token number in the line. ! FUNCTION values ( pline , ind , after ) implicit none !------------------------------------------------- Input Variables integer ( ip ), intent ( in ) :: ind integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables real ( dp ) :: values !------------------------------------------------- Local Variables logical :: found integer ( ip ) :: i , j , starting_pos !----------------------------------------------------------- BEGIN if ( PRESENT ( after )) then if ( after . lt . 0 ) then call die ( 'PARSE module: values' , 'Wrong starting position' , & THIS_FILE , __ LINE__ , cline = characters ( pline , 1 , - 1 )) endif starting_pos = after else starting_pos = 0 endif i = starting_pos + 1 j = 0 found = . FALSE . do while ((. not . found ) . and . ( i . le . pline % ntokens )) if (( leqi ( pline % id ( i ), 'i' )) . or . ( leqi ( pline % id ( i ), 'r' ))) & j = j + 1 if ( j . eq . ind ) then values = s2r ( tokens ( pline , i )) found = . TRUE . endif i = i + 1 enddo if (. not . found ) then call die ( 'PARSE module: values' , 'Not enough values in line' , & THIS_FILE , __ LINE__ , cline = characters ( pline , 1 , - 1 )) endif RETURN !------------------------------------------------------------- END END FUNCTION values ! !   Return a given name token, specifying it by its sequence !   number. It is also possible to make the sequence start after !   a given token number in the line. ! FUNCTION names ( pline , ind , after ) implicit none !------------------------------------------------- Input Variables integer ( ip ), intent ( in ) :: ind integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables character ( len = MAX_LENGTH ) :: names !------------------------------------------------- Local Variables logical :: found integer ( ip ) :: i , j , starting_pos !----------------------------------------------------------- BEGIN if ( PRESENT ( after )) then if ( after . lt . 0 ) then call die ( 'PARSE module: names' , 'Wrong starting position' , & THIS_FILE , __ LINE__ , cline = characters ( pline , 1 , - 1 )) endif starting_pos = after else starting_pos = 0 endif i = starting_pos + 1 j = 0 found = . FALSE . do while ((. not . found ) . and . ( i . le . pline % ntokens )) if ( leqi ( pline % id ( i ), 'n' )) j = j + 1 if ( j . eq . ind ) then names = trim ( tokens ( pline , i )) found = . TRUE . endif i = i + 1 enddo if (. not . found ) then call die ( 'PARSE module: names' , 'Not enough names in line' , & THIS_FILE , __ LINE__ , cline = characters ( pline , 1 , - 1 )) endif RETURN !------------------------------------------------------------- END END FUNCTION names ! !   Return a given block label if it is found, else returns '' !   Syntax must be: '%block Label' (bl) as stored in fdf structure ! FUNCTION blocks ( pline ) implicit none !------------------------------------------------- Input Variables type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables character ( len = MAX_LENGTH ) :: blocks !----------------------------------------------------------- BEGIN if ( match ( pline , 'bl' )) then blocks = tokens ( pline , 2 ) else blocks = ' ' endif RETURN !------------------------------------------------------------- END END FUNCTION blocks ! !   Return a given endblock label if it is found, else returns '' !   Syntax must be: '%endblock Label' (el) as stored in fdf structure ! FUNCTION endblocks ( pline ) implicit none !------------------------------------------------- Input Variables type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables character ( len = MAX_LENGTH ) :: endblocks !----------------------------------------------------------- BEGIN if ( match ( pline , 'el' )) then endblocks = tokens ( pline , 2 ) else endblocks = ' ' endif RETURN !------------------------------------------------------------- END END FUNCTION endblocks ! !   Return a given label name if it is found, else returns '' !   Syntax must be: 'Label Value' (li|lr|ln|l) as stored in fdf structure ! FUNCTION labels ( pline ) implicit none !------------------------------------------------- Input Variables type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables character ( len = MAX_LENGTH ) :: labels !----------------------------------------------------------- BEGIN if ( match ( pline , 'l' )) then labels = tokens ( pline , 1 ) else labels = ' ' endif RETURN !------------------------------------------------------------- END END FUNCTION labels ! !   Return a given token as character, specifying it by its sequence !   number. It is also possible to make the sequence start after !   a given token number in the line. ! FUNCTION tokens ( pline , ind , after ) implicit none !------------------------------------------------- Input Variables integer ( ip ), intent ( in ) :: ind integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables character ( len = MAX_LENGTH ) :: tokens !------------------------------------------------- Local Variables integer ( ip ) :: starting_pos , loc !----------------------------------------------------------- BEGIN if ( PRESENT ( after )) then if (( after . lt . 0 ) . or . ( after . ge . pline % ntokens )) & call die ( 'PARSE module: tokens' , 'Wrong starting position' , & THIS_FILE , __ LINE__ , cline = characters ( pline , 1 , - 1 )) starting_pos = after else starting_pos = 0 endif if ( starting_pos + ind . gt . pline % ntokens ) & call die ( 'PARSE module: tokens' , 'Wrong starting position' , & THIS_FILE , __ LINE__ , cline = characters ( pline , 1 , - 1 )) loc = starting_pos + ind tokens = pline % line ( pline % first ( loc ): pline % last ( loc )) RETURN !------------------------------------------------------------- END END FUNCTION tokens ! !   Return a piece of the input line, given specifying it by the sequence !   numbers of the initial and final tokens. !   A negative final index means that it is counted from the end, e.g. !   ind_final=-1 refers to the last token. !   It is also possible to make the sequence start after !   a given token number in the line. ! FUNCTION characters ( pline , ind_init , ind_final , after ) implicit none !------------------------------------------------- Input Variables integer ( ip ), intent ( in ) :: ind_init integer ( ip ), intent ( in ) :: ind_final integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables character ( len = MAX_LENGTH ) :: characters !------------------------------------------------- Local Variables integer ( ip ) :: starting_pos integer ( ip ) :: loc_init , loc_final !----------------------------------------------------------- BEGIN if ( PRESENT ( after )) then if (( after . lt . 0 ) . or . ( after . ge . pline % ntokens )) & call die ( 'PARSE module: tokens' , 'Wrong starting position' , & THIS_FILE , __ LINE__ ) starting_pos = after else starting_pos = 0 endif loc_init = starting_pos + ind_init if ( ind_final < 0 ) then loc_final = pline % ntokens + ind_final + 1 else loc_final = starting_pos + ind_final endif if ( ( loc_init . lt . 0 ) & . OR . ( loc_init . gt . pline % ntokens ) & . OR . ( loc_final . lt . 0 ) & . OR . ( loc_final . gt . pline % ntokens ) & . OR . ( loc_final . lt . loc_init ) & ) then call die ( 'PARSE module: characters' , 'Wrong limits' , & THIS_FILE , __ LINE__ ) endif characters = pline % line ( pline % first ( loc_init ): pline % last ( loc_final )) RETURN !------------------------------------------------------------- END END FUNCTION characters ! !   Main processing function. Digest a character line array !   building a digested parsed_line structure. ! FUNCTION digest ( line ) result ( pline ) implicit none !------------------------------------------------- Input Variables character ( len =* ), intent ( in ) :: line !------------------------------------------------ Output Variables type ( parsed_line ), pointer :: pline !------------------------------------------------- Local Variables character :: token_id ( MAX_NTOKENS ) integer ( ip ) :: i , ntokens integer ( ip ) :: first ( MAX_NTOKENS ), last ( MAX_NTOKENS ) !----------------------------------------------------------- BEGIN !     Parse line, and get morphology call parses ( ntokens , line , first , last ) call morphol ( ntokens , line , first , last , token_id ) !     Build parsed_line structure NULLIFY ( pline ) call create ( pline ) pline % ntokens = ntokens if ( ntokens . gt . MAX_NTOKENS ) then call die ( 'PARSE module: digest' , 'Too many tokens' , & THIS_FILE , __ LINE__ , rc = 666 ) endif pline % line = line do i = 1 , ntokens pline % first ( i ) = first ( i ) pline % last ( i ) = last ( i ) pline % id ( i ) = token_id ( i ) enddo RETURN !------------------------------------------------------------- END END FUNCTION digest ! !   Parses a character line, filling ntokens (# of tokens) !   first and last (beginning and ending of each one token) ! SUBROUTINE parses ( ntokens , line , first , last ) implicit none !------------------------------------------------- Input Variables character ( len =* ) :: line !------------------------------------------------ Output Variables integer ( ip ) :: ntokens integer ( ip ) :: first ( MAX_NTOKENS ), last ( MAX_NTOKENS ) !------------------------------------------------- Local Variables logical :: intoken , instring , completed logical :: inlist integer ( ip ) :: i , c , stringdel , length !     Character statement functions logical :: is_digit , is_upper , is_lower , is_alpha , & is_alnum , is_extra , is_tokch logical :: is_comment , is_delstr , is_dellist , is_special is_digit ( i ) = ( i . ge . 48 ) . and . ( i . le . 57 ) is_upper ( i ) = ( i . ge . 65 ) . and . ( i . le . 90 ) is_lower ( i ) = ( i . ge . 97 ) . and . ( i . le . 122 ) is_alpha ( i ) = is_upper ( i ) . or . is_lower ( i ) is_alnum ( i ) = is_digit ( i ) . or . is_alpha ( i ) !     Extra characters allowed in tokens:  $ % * + & - . / @ &#94; _ | ~ is_extra ( i ) = (( i . ge . 36 ) . and . ( i . le . 38 )) & . or . ( i . eq . 42 ) . or . ( i . eq . 43 ) . or . ( i . eq . 45 ) & . or . ( i . eq . 46 ) . or . ( i . eq . 47 ) . or . ( i . eq . 64 ) & . or . ( i . eq . 94 ) . or . ( i . eq . 95 ) . or . ( i . eq . 124 )& . or . ( i . eq . 126 ) . or . ( i . eq . 58 ) is_tokch ( i ) = is_alnum ( i ) . or . is_extra ( i ) !     Comments are signaled by:  !  #  ; is_comment ( i ) = ( i . eq . 33 ) . or . ( i . eq . 35 ) . or . ( i . eq . 59 ) !     String delimiters: \"  '  ` is_delstr ( i ) = ( i . eq . 34 ) . or . ( i . eq . 39 ) . or . ( i . eq . 96 ) !     List delimiters: [ ] is_dellist ( i ) = ( i . eq . 91 ) . or . ( i . eq . 93 ) !     Dictionary delimiters: { } !      is_deldict(i)  = (i .eq. 123) .or. (i .eq. 125) !     Special characters which are tokens by themselves: < is_special ( i ) = ( i . eq . 60 ) !----------------------------------------------------------- BEGIN ntokens = 0 intoken = . FALSE . instring = . FALSE . inlist = . FALSE . stringdel = 0 ! Trim space at the end (not from the left) length = len_trim ( line ) i = 1 completed = . FALSE . do while ( i <= length . and . (. not . completed ) ) c = ichar ( line ( i : i )) !       Possible comment... if ( is_comment ( c )) then if ( instring . or . inlist ) then last ( ntokens ) = i else completed = . TRUE . endif !       Character allowed in a token... elseif ( is_tokch ( c )) then if (. not . intoken ) then intoken = . TRUE . ntokens = ntokens + 1 first ( ntokens ) = i endif last ( ntokens ) = i !       Character that forms a token by itself... elseif ( is_special ( c )) then if (. not . instring . and . . not . inlist ) then ntokens = ntokens + 1 first ( ntokens ) = i intoken = . FALSE . endif last ( ntokens ) = i !      List delimiter... We only allow single lists, not nested lists elseif ( is_dellist ( c )) then if (. not . instring . and . . not . inlist ) then inlist = . TRUE . intoken = . TRUE . ntokens = ntokens + 1 first ( ntokens ) = i elseif ( inlist ) then ! end list (skip last token) intoken = . FALSE . inlist = . FALSE . last ( ntokens ) = i else last ( ntokens ) = i end if !       String delimiter... make sure it is the right one before closing. !       If we are currently in a token, the delimiter is appended to it. elseif ( is_delstr ( c )) then if ( instring ) then if ( c . eq . stringdel ) then instring = . FALSE . intoken = . FALSE . stringdel = 0 else last ( ntokens ) = i endif else if ( intoken ) then last ( ntokens ) = i else instring = . TRUE . intoken = . TRUE . stringdel = c ntokens = ntokens + 1 first ( ntokens ) = i + 1 last ( ntokens ) = i + 1 endif endif !       Token delimiter... else if ( instring . or . inlist ) then last ( ntokens ) = i else if ( intoken ) intoken = . FALSE . endif endif i = i + 1 ! Check whether the parsing is correctly handled if ( i > MAX_LENGTH ) then ! Because we will limit search to the len_trim length, ! then this should only be found when the line has \"content\" too long. ! Note that this will *never* be executed if a comment is too ! long because it is checked as the first requirement and then ! completes parsing the line. call die ( 'PARSE module: parses' , 'Too long line (132 char): ' // & trim ( line ), THIS_FILE , __ LINE__ ) end if enddo if ( parse_debug ) then write ( parse_log , * ) 'PARSER:' , ntokens , 'token(s)' do i = 1 , ntokens write ( parse_log , * ) '   Token:' , '|' , line ( first ( i ): last ( i )), '|' enddo write ( parse_log , * ) ' ' endif !------------------------------------------------------------- END END SUBROUTINE parses ! !   Classifies the tokens according to their morphology ! SUBROUTINE morphol ( ntokens , line , first , last , token_id ) implicit none !------------------------------------------------- Input Variables character ( len =* ) :: line integer ( ip ) :: ntokens integer ( ip ) :: first ( MAX_NTOKENS ), last ( MAX_NTOKENS ) !------------------------------------------------ Output Variables character :: token_id ( MAX_NTOKENS ) !------------------------------------------------- Local Variables character ( len = MAX_LENGTH ) :: token , msg integer ( ip ) :: i , j , ierr real ( dp ) :: real_value !----------------------------------------------------------- BEGIN do i = 1 , ntokens token = line ( first ( i ): last ( i )) j = last ( i ) - first ( i ) + 1 if ( ichar ( token ( 1 : 1 )) . eq . 91 . and . & ichar ( token ( j : j )) . eq . 93 ) then ! if the token starts with [ and ends with ], it will be a list ! We do a simple check for the list type. ! Since we are only dealing with integer/real lists ! we can simply check for a . (comma separation) which ! will enable an easy distinguishment between integers and reals. if ( index ( token ( 1 : j ), '.' ) > 0 ) then token_id ( i ) = 'c' else token_id ( i ) = 'a' end if !        else if ( ichar(token(1:1)) .eq. 123 .and. & !             ichar(token(j:j)) .eq. 125 ) then ! if the token starts with { and ends with }, it will be a dictionary !           token_id(i) = 'd' elseif ( is_value ( token )) then !         This read also serves to double check the token for !         real meaning (for example, \".d0\" should give an error) read ( token , fmt =* , iostat = ierr ) real_value if ( ierr . ne . 0 ) then write ( msg , '(a,i3,1x,a,/,a)' ) 'Error in numeric conversion ' , & 'at token number' , i , ' in line ''' , TRIM ( line ), '''' call die ( 'PARSE module: morphol' , msg , THIS_FILE , __ LINE__ ) endif if ( is_integer ( token )) then token_id ( i ) = 'i' else token_id ( i ) = 'r' endif else token_id ( i ) = 'n' endif enddo if ( parse_debug ) then write ( parse_log , * ) 'MORPHOL:' , ntokens , 'token(s)' do i = 1 , ntokens write ( parse_log , * ) '   Token:' , '|' , token_id ( i ), '|' enddo write ( parse_log , * ) ' ' endif !------------------------------------------------------------- END END SUBROUTINE morphol ! !   Set the morphology of a specific token in a parsed line ! SUBROUTINE setmorphol ( ntoken , token_id , pline ) implicit none !------------------------------------------------- Input Variables character :: token_id integer ( ip ) :: ntoken !------------------------------------------------ Output Variables type ( parsed_line ), pointer :: pline !------------------------------------------------- Local Variables character ( len = MAX_LENGTH ) :: msg !----------------------------------------------------------- BEGIN !     Check if token_id is a valid morphology id !     'a' -> List (integers) !     'c' -> List (reals) !     'l' -> Label !     'b' -> BeginBlock !     'e' -> EndBlock !     'i' -> Integer !     'r' -> Real !     'n' -> Name if (( token_id . ne . 'a' ) . and . ( token_id . ne . 'c' ) . and . & ( token_id . ne . 'l' ) . and . ( token_id . ne . 'b' ) . and . & ( token_id . ne . 'e' ) . and . ( token_id . ne . 'i' ) . and . & ( token_id . ne . 'r' ) . and . ( token_id . ne . 'n' )) then write ( msg , * ) 'Morphology id = ''' , token_id , & ''' not valid for token = ''' , tokens ( pline , ntoken ), '''' call die ( 'PARSE module: setmorphol' , msg , THIS_FILE , __ LINE__ ) endif pline % id ( ntoken ) = token_id !------------------------------------------------------------- END END SUBROUTINE setmorphol ! !   Search a string along a parsed line tokens. If found, it returns !   the index in the list of the token that matches with the string. !   Otherwise it returns -1. ! FUNCTION search_fun ( string , pline_fun , after , eq_func ) implicit none !------------------------------------------------- Input Variables character ( len =* ) :: string integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline_fun optional :: eq_func interface function eq_func ( s1 , s2 ) logical :: eq_func character ( len =* ), intent ( in ) :: s1 , s2 end function eq_func end interface !------------------------------------------------ Output Variables integer ( ip ) :: search_fun !------------------------------------------------- Local Variables integer ( ip ) :: i , starting_pos !----------------------------------------------------------- BEGIN if ( PRESENT ( after )) then if ( after . lt . 0 ) then call die ( 'PARSE module: search_fun' , 'Wrong starting position' , & THIS_FILE , __ LINE__ ) endif starting_pos = after else starting_pos = 0 endif search_fun = - 1 if (. not . ASSOCIATED ( pline_fun )) then call die ( 'PARSE module: search_fun' , 'parsed_line not associated' , & THIS_FILE , __ LINE__ ) endif !     The default comparison routine is 'leqi' (case-insensitive) if ( PRESENT ( eq_func )) then i = starting_pos + 1 do while (( search_fun . eq . - 1 ) . and . ( i . le . pline_fun % ntokens )) if ( eq_func ( string , tokens ( pline_fun , i ))) search_fun = i i = i + 1 enddo else i = starting_pos + 1 do while (( search_fun . eq . - 1 ) . and . ( i . le . pline_fun % ntokens )) if ( leqi ( string , tokens ( pline_fun , i ))) search_fun = i i = i + 1 enddo endif RETURN !------------------------------------------------------------- END END FUNCTION search_fun ! !   Search a string along a parsed line tokens. If found, leaves !   in 'ind' the index token in the list that matches with the string !   and it returns .TRUE. Otherwise it returns .FALSE. and -1 in 'ind' ! FUNCTION search_sub ( pline_sub , string , ind , after , eq_func ) implicit none !------------------------------------------------- Input Variables character ( len =* ) :: string integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline_sub optional :: eq_func interface function eq_func ( s1 , s2 ) logical :: eq_func character ( len =* ), intent ( in ) :: s1 , s2 end function eq_func end interface !------------------------------------------------ Output Variables logical :: search_sub integer ( ip ), intent ( out ), optional :: ind !------------------------------------------------- Local Variables integer ( ip ) :: i , starting_pos !----------------------------------------------------------- BEGIN if ( PRESENT ( after )) then if ( after . lt . 0 ) then call die ( 'PARSE module: search_sub' , 'Wrong starting position' , & THIS_FILE , __ LINE__ ) endif starting_pos = after else starting_pos = 0 endif if ( PRESENT ( ind )) ind = - 1 search_sub = . FALSE . if (. not . ASSOCIATED ( pline_sub )) then call die ( 'PARSE module: search_sub' , 'parsed_line not associated' , & THIS_FILE , __ LINE__ ) endif !     The default comparison routine is 'leqi' (case-insensitive) if ( PRESENT ( eq_func )) then i = starting_pos + 1 do while ((. not . search_sub ) . and . ( i . le . pline_sub % ntokens )) if ( eq_func ( string , tokens ( pline_sub , i ))) then if ( PRESENT ( ind )) ind = i search_sub = . TRUE . endif i = i + 1 enddo else i = starting_pos + 1 do while ((. not . search_sub ) . and . ( i . le . pline_sub % ntokens )) if ( leqi ( string , tokens ( pline_sub , i ))) then if ( PRESENT ( ind )) ind = i search_sub = . TRUE . endif i = i + 1 enddo endif RETURN !------------------------------------------------------------- END END FUNCTION search_sub ! !   Search a sub-string along a parsed line tokens. If found, leaves !   in 'ind' (if present) the index token in the list that has the !   string as a substring and it returns .TRUE. Otherwise it returns !   .FALSE. and -1 in 'ind' ! FUNCTION substring_search ( pline_sub , string , ind , after ) implicit none !------------------------------------------------- Input Variables character ( len =* ) :: string integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline_sub !------------------------------------------------ Output Variables logical :: substring_search integer ( ip ), intent ( out ), optional :: ind !------------------------------------------------- Local Variables integer ( ip ) :: i , starting_pos !----------------------------------------------------------- BEGIN if ( PRESENT ( after )) then if ( after . lt . 0 ) then call die ( 'PARSE module: substring_search' , & 'Wrong starting position' , & THIS_FILE , __ LINE__ ) endif starting_pos = after else starting_pos = 0 endif if ( PRESENT ( ind )) ind = - 1 substring_search = . FALSE . if (. not . ASSOCIATED ( pline_sub )) then call die ( 'PARSE module: substring_search' , & 'parsed_line not associated' , & THIS_FILE , __ LINE__ ) endif !     NOTE that the we use the case-sensitive Fortran 'index' function i = starting_pos + 1 do while ((. not . substring_search ) . and . ( i . le . pline_sub % ntokens )) if ( index ( tokens ( pline_sub , i ), string ) > 0 ) then if ( PRESENT ( ind )) ind = i substring_search = . TRUE . endif i = i + 1 enddo RETURN !------------------------------------------------------------- END END FUNCTION substring_search ! !   Checks whether the morphology of the line or part of it !   matches the 'signature' string str. !   If 'after' is present, try to match the 'signature' after !   that number of tokens. ! FUNCTION match ( pline , str , after ) implicit none !------------------------------------------------- Input Variables character ( * ), intent ( in ) :: str integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline !------------------------------------------------ Output Variables logical :: match !------------------------------------------------- Local Variables character :: c , id integer ( ip ) :: i , nids , shift !----------------------------------------------------------- BEGIN if ( PRESENT ( after )) then if ( after . lt . 0 ) then call die ( 'PARSE module: match' , 'Wrong starting position' , & THIS_FILE , __ LINE__ , cline = characters ( pline , 1 , - 1 )) endif shift = after else shift = 0 endif nids = LEN_TRIM ( str ) if ( pline % ntokens - shift . lt . nids ) then match = . FALSE . else i = 1 match = . TRUE . do while ( match . and . ( i . le . nids )) c = str ( i : i ) id = pline % id ( shift + i ) if (. not . leqi ( c , id )) then !  x: matches anything if ( leqi ( c , 'x' )) then ! do nothing -- match stays .true. !  v: integer or real else if ( leqi ( c , 'v' )) then if (. not .( leqi ( id , 'i' ) . or . leqi ( id , 'r' ))) then match = . false . endif !  s: integer or real or name (symbol) else if ( leqi ( c , 's' )) then if (. not .( leqi ( id , 'i' ) . or . & leqi ( id , 'r' ) . or . & leqi ( id , 'n' ) )) then match = . false . endif !  a: array (integer list) else if ( leqi ( c , 'a' )) then if (. not .( leqi ( id , 'a' )) ) then match = . false . endif !  c: array (real list) else if ( leqi ( c , 'c' )) then if (. not .( leqi ( id , 'c' )) ) then match = . false . endif !  e: array (list) else if ( leqi ( c , 'e' )) then if (. not .( leqi ( id , 'a' ) . or . & leqi ( id , 'c' ) )) then match = . false . endif !  j: integer or name (integer-symbol) else if ( leqi ( c , 'j' )) then if (. not .( leqi ( id , 'i' ) . or . leqi ( id , 'n' ))) then match = . false . endif !  cannot find a match else match = . false . endif endif i = i + 1 enddo endif RETURN !------------------------------------------------------------- END END FUNCTION match ! !   Checks if the string has a valid integer format ! FUNCTION is_integer ( string ) implicit none !------------------------------------------------- Input Variables character ( len =* ) :: string !------------------------------------------------ Output Variables logical :: is_integer !------------------------------------------------- Local Variables character :: c integer ( ip ) :: i , length logical :: is_digit , is_sign is_digit ( c ) = (( ichar ( c ) . ge . 48 ) . and . ( ichar ( c ) . le . 57 )) is_sign ( c ) = (( c . eq . '+' ) . or . ( c . eq . '-' )) !----------------------------------------------------------- BEGIN length = LEN_TRIM ( string ) if ( length . gt . 0 ) then c = string ( 1 : 1 ) if (( is_digit ( c )) . or . ( is_sign ( c ))) then i = 2 is_integer = . TRUE . do while ( is_integer . and . ( i . le . length )) c = string ( i : i ) if (. not . ( is_digit ( c ))) then is_integer = . FALSE . endif i = i + 1 enddo else is_integer = . FALSE . endif else is_integer = . FALSE . endif RETURN !------------------------------------------------------------- END END FUNCTION is_integer ! !   Checks if the string has a valid value format [real|integer] ! FUNCTION is_value ( string ) implicit none !------------------------------------------------- Input Variables character ( len =* ) :: string !------------------------------------------------ Output Variables logical :: is_value !------------------------------------------------- Local Variables character :: c logical :: dotsok integer ( ip ) :: i , length , exp_mark logical :: is_digit , is_sign , is_dot , is_expmark is_digit ( c ) = (( ichar ( c ) . ge . 48 ) . and . ( ichar ( c ) . le . 57 )) is_sign ( c ) = (( c . eq . '+' ) . or . ( c . eq . '-' )) is_dot ( c ) = (( c . eq . '.' ) . and . dotsok ) is_expmark ( c ) = (( c . eq . 'e' ) . or . ( c . eq . 'E' ) . or . & ( c . eq . 'd' ) . or . ( c . eq . 'D' )) !----------------------------------------------------------- BEGIN length = LEN_TRIM ( string ) is_value = . FALSE . dotsok = . TRUE . !     Find the starting point of a possible exponent exp_mark = length + 1 do i = 1 , length c = string ( i : i ) if ( is_expmark ( c )) exp_mark = i enddo if ( exp_mark . eq . length ) return ! Form: XXXXXd c = string ( 1 : 1 ) if (. not . ( is_digit ( c ) . or . is_sign ( c ))) then if ( is_dot ( c )) then dotsok = . FALSE . else return endif endif do i = 2 , exp_mark - 1 c = string ( i : i ) if (. not . ( is_digit ( c ))) then if ( is_dot ( c )) then dotsok = . FALSE . else return endif endif enddo !     Is the exponent an integer? if ( exp_mark . lt . length ) then if (. not . is_integer ( string ( exp_mark + 1 : length ))) return endif !     Here we could do some extra checks to see if the string still makes !     sense... For example, \".\" and \".d0\" pass the above tests but are not !     readable as numbers. I believe this should be reported by the !     conversion routine, to warn the user of a mis-typed number, instead !     of reporting it as a string and break havoc somewhere else. !     This cases should not be accepted, since !     now we are scanning the whole input file blindly if ( length == 1 ) then if ( is_sign ( string ( 1 : 1 ))) return ! Remove '+' and '-' if ( string ( 1 : 1 ) == \".\" ) return ! Remove '.' endif is_value = . TRUE . RETURN !------------------------------------------------------------- END END FUNCTION is_value ! !   Set debugging level for parses/morphol routines ! SUBROUTINE setdebug ( level ) implicit none !------------------------------------------------- Input Variables integer ( ip ) :: level !----------------------------------------------------------- BEGIN parse_debug = ( level . eq . 1 ) RETURN !------------------------------------------------------------- END END SUBROUTINE setdebug ! !   Set log unit for parses/morphol routines ! SUBROUTINE setlog ( unit ) implicit none !------------------------------------------------- Input Variables integer ( ip ) :: unit !----------------------------------------------------------- BEGIN parse_log = unit RETURN !------------------------------------------------------------- END END SUBROUTINE setlog ! subroutine serialize_pline ( pline , string , length ) type ( parsed_line ) :: pline character ( len =* ), intent ( out ) :: string integer , intent ( out ) :: length integer :: pos , i character ( len = 10 ) buffer length = SERIALIZED_LENGTH if ( len ( string ) < length ) then call die ( 'PARSE module: serialize_pline' , & \"String too short\" , & THIS_FILE , __ LINE__ ) endif string = \"\" string ( 1 : MAX_LENGTH ) = pline % line pos = MAX_LENGTH write ( string ( pos + 1 : pos + 4 ), \"(i4)\" ) pline % ntokens pos = pos + 4 do i = 1 , pline % ntokens write ( buffer , \"(1x,a1,2i4)\" ) pline % id ( i ), pline % first ( i ), pline % last ( i ) string ( pos + 1 : pos + 10 ) = buffer pos = pos + 10 enddo end subroutine serialize_pline subroutine recreate_pline ( pline , string ) type ( parsed_line ), pointer :: pline character ( len =* ), intent ( in ) :: string integer :: pos , i if ( len ( string ) < SERIALIZED_LENGTH ) then call die ( 'PARSE module: recreate_pline' , & \"String too short\" , & THIS_FILE , __ LINE__ , cline = characters ( pline , 1 , - 1 )) endif pline % line = string ( 1 : MAX_LENGTH ) pos = MAX_LENGTH read ( string ( pos + 1 : pos + 4 ), \"(i4)\" ) pline % ntokens pos = pos + 4 do i = 1 , pline % ntokens read ( string ( pos + 1 : pos + 10 ), \"(1x,a1,2i4)\" ) pline % id ( i ), pline % first ( i ), pline % last ( i ) pos = pos + 10 enddo end subroutine recreate_pline END MODULE parse","tags":"","loc":"sourcefile/parse.f90.html"},{"title":"legacy_units.F90 – libfdf","text":"Contents Modules legacy_units_m Source Code legacy_units.F90 Source Code module legacy_units_m use prec , only : dp implicit none public :: inquire_unit private integer , parameter :: nu = 80 integer :: iu character ( 8 ) :: dimm ( nu ) character ( 10 ) :: name ( nu ) real ( dp ) :: unit ( nu ) data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 1 , 3 ) / & 'mass    ' , 'g         ' , 1.d-3 , & 'mass    ' , 'kg        ' , 1.d0 , & 'mass    ' , 'amu       ' , 1.66054d-27 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 4 , 9 ) / & 'length  ' , 'm         ' , 1.d0 , & 'length  ' , 'cm        ' , 1.d-2 , & 'length  ' , 'nm        ' , 1.d-9 , & 'length  ' , 'pm        ' , 1.d-12 , & 'length  ' , 'ang       ' , 1.d-10 , & 'length  ' , 'bohr      ' , 0.529177d-10 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 10 , 19 ) / & 'energy  ' , 'j         ' , 1.d0 , & 'energy  ' , 'kj        ' , 1.d3 , & 'energy  ' , 'erg       ' , 1.d-7 , & 'energy  ' , 'mev       ' , 1.60219d-22 , & 'energy  ' , 'ev        ' , 1.60219d-19 , & 'energy  ' , 'mry       ' , 2.17991d-21 , & 'energy  ' , 'ry        ' , 2.17991d-18 , & 'energy  ' , 'mha       ' , 4.35982d-21 , & 'energy  ' , 'mhartree  ' , 4.35982d-21 , & 'energy  ' , 'ha        ' , 4.35982d-18 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 20 , 29 ) / & 'energy  ' , 'hartree   ' , 4.35982d-18 , & 'energy  ' , 'k         ' , 1.38066d-23 , & 'energy  ' , 'kelvin    ' , 1.38066d-23 , & 'energy  ' , 'kcal/mol  ' , 6.94780d-21 , & 'energy  ' , 'kj/mol    ' , 1.6606d-21 , & 'energy  ' , 'hz        ' , 6.6262d-34 , & 'energy  ' , 'thz       ' , 6.6262d-22 , & 'energy  ' , 'cm-1      ' , 1.986d-23 , & 'energy  ' , 'cm&#94;-1     ' , 1.986d-23 , & 'energy  ' , 'cm**-1    ' , 1.986d-23 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 30 , 39 ) / & 'time    ' , 's         ' , 1.d0 , & 'time    ' , 'ns        ' , 1.d-9 , & 'time    ' , 'ps        ' , 1.d-12 , & 'time    ' , 'fs        ' , 1.d-15 , & 'time    ' , 'min       ' , 6 0.d0 , & 'time    ' , 'mins      ' , 6 0.d0 , & 'time    ' , 'hour      ' , 360 0.d0 , & 'time    ' , 'hours     ' , 360 0.d0 , & 'time    ' , 'day       ' , 8640 0.d0 , & 'time    ' , 'days      ' , 8640 0.d0 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 40 , 43 ) / & 'force   ' , 'n         ' , 1.d0 , & 'force   ' , 'ev/ang    ' , 1.60219d-9 , & 'force   ' , 'ry/bohr   ' , 4.11943d-8 , & 'force   ' , 'ha/bohr   ' , 8.23886d-08 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 44 , 52 ) / & 'pressure' , 'pa        ' , 1.d0 , & 'pressure' , 'gpa       ' , 1.d9 , & 'pressure' , 'atm       ' , 1.01325d5 , & 'pressure' , 'bar       ' , 1.d5 , & 'pressure' , 'mbar      ' , 1.d11 , & 'pressure' , 'ev/ang**3 ' , 1.60219d11 , & 'pressure' , 'ev/ang&#94;3  ' , 1.60219d11 , & 'pressure' , 'ry/bohr**3' , 1.47108d13 , & 'pressure' , 'ry/bohr&#94;3 ' , 1.47108d13 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 53 , 54 ) / & 'charge  ' , 'c         ' , 1.d0 , & 'charge  ' , 'e         ' , 1.602177d-19 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 55 , 59 ) / & 'dipole  ' , 'c*m       ' , 1.d0 , & 'dipole  ' , 'd         ' , 3.33564d-30 , & 'dipole  ' , 'debye     ' , 3.33564d-30 , & 'dipole  ' , 'e*bohr    ' , 8.47835d-30 , & 'dipole  ' , 'e*ang     ' , 1.602177d-29 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 60 , 61 ) / & 'mominert' , 'kg*m**2   ' , 1.d0 , & 'mominert' , 'ry*fs**2  ' , 2.17991d-48 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 62 , 68 ) / & 'efield  ' , 'v/m       ' , 1.d0 , & 'efield  ' , 'v/nm      ' , 1.d9 , & 'efield  ' , 'v/ang     ' , 1.d10 , & 'efield  ' , 'v/bohr    ' , 1.8897268d10 , & 'efield  ' , 'ry/bohr/e ' , 2.5711273d11 , & 'efield  ' , 'ha/bohr/e ' , 5.1422546d11 , & 'efield  ' , 'har/bohr/e' , 5.1422546d11 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 69 , 70 ) / & 'angle   ' , 'deg       ' , 1.d0 , & 'angle   ' , 'rad       ' , 5.72957795d1 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 71 , 78 ) / & 'torque  ' , 'mev/deg   ' , 1.0d-3 , & 'torque  ' , 'mev/rad   ' , 1.745533d-5 , & 'torque  ' , 'ev/deg    ' , 1.0d0 , & 'torque  ' , 'ev/rad    ' , 1.745533d-2 , & 'torque  ' , 'mry/deg   ' , 1 3.6058d-3 , & 'torque  ' , 'mry/rad   ' , 0.237466d-3 , & 'torque  ' , 'ry/deg    ' , 1 3.6058d0 , & 'torque  ' , 'ry/rad    ' , 0.237466d0 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 79 , 80 ) / & 'bfield  ' , 'Tesla     ' , 1.0d0 , & 'bfield  ' , 'G         ' , 1.0d-4 / CONTAINS !< ! Returns information about a unit in the units table ! ! Unit specifications might include an optional 'physical dimension' ! qualifier (e.g. 'bfield:g') ! In this case, 'phys_dim' returns the physical dimension, and the ! qualifier is used to match the unit. ! This version is case-insensitive (e.g. 'g' and 'G' could stand for 'Gauss'). ! As the above example indicates, in the absence of a physical dimension qualifier, ! 'g' might be ambiguous ('bfield' or 'mass'?). The routine will return 'stat=-1' ! in this case. ! Units might be ambiguous in a more serious way: 'meV' and 'MeV' could both be ! present in the table. In this case, it might be advisable to use a case-sensitive ! version of this routine (replacing 'leqi' by a 'strict' version). ! If the unit is not found in the table, the routine returns 'stat=-2'. subroutine inquire_unit ( unit_str , stat , phys_dim , unit_name , unit_value ) use utils , only : leqi use prec , only : dp character ( len =* ), intent ( in ) :: unit_str !+ unit specification character ( len =* ), intent ( out ) :: phys_dim !+ physical dimension (e.g. 'mass') character ( len =* ), intent ( out ) :: unit_name !+ unit name (e.g. 'g') real ( dp ), intent ( out ) :: unit_value !+ actual value (e.g. 1.e-3) integer , intent ( out ) :: stat !+ status code integer :: idx_colon , iu , idx logical :: phys_dim_specified , match idx_colon = index ( unit_str , \":\" ) if ( idx_colon /= 0 ) then ! spec includes dimension prefix phys_dim = unit_str ( 1 : idx_colon - 1 ) unit_name = unit_str ( idx_colon + 1 :) phys_dim_specified = . true . else phys_dim = \"\" unit_name = unit_str phys_dim_specified = . false . endif stat = 0 idx = 0 do iu = 1 , nu match = . false . if ( leqi ( name ( iu ), unit_name )) then if ( phys_dim_specified ) then if ( leqi ( dimm ( iu ), phys_dim )) then match = . true . endif else match = . true . endif endif if ( match ) then if ( idx /= 0 ) then ! ambiguous stat = 1 RETURN endif idx = iu endif enddo if ( idx == 0 ) then stat = - 2 ! not found else phys_dim = trim ( dimm ( idx )) unit_value = unit ( idx ) endif end subroutine inquire_unit end module legacy_units_m","tags":"","loc":"sourcefile/legacy_units.f90.html"},{"title":"fdf.F90 – libfdf","text":"Contents Modules fdf Source Code fdf.F90 Source Code #if defined HAVE_CONFIG_H #  include \"config.h\" #endif #define THIS_FILE \"fdf.F90\" !===================================================================== ! ! This file is part of the FDF package. ! ! This module implements an extended Fortran 90/95 interface ! to the Flexible Data Format library of A. Garcia and J.M. Soler, ! originally written in Fortran 77. ! ! FEATURES: ! ! a) Block pointers. ! ! Block content can be flexibly handled by means of a pointer ! to a derived type 'block_fdf'. Typical usage: ! !     use fdf !     type(block_fdf)            :: bfdf !     type(parsed_line), pointer :: pline ! !     if (fdf_block('SomeBlock', bfdf)) then !       do while(fdf_bline(bfdf, pline)) !         (process line 'integers|reals|values|names ...') !       enddo !       call fdf_bclose(bfdf) !     endif ! ! The subroutine 'fdf_block' returns in 'bfdf' a structure used ! to read the contents of the block. ! ! Routine fdf_bline returns in 'pline' the next non-blank parsed ! line, non-comment line from the block, unless there are no more ! lines, in which case it returns .FALSE. and 'pline' is undefined. ! ! Routine fdf_bclose runs the remaining lines in the block and ensures ! the log may be used as input in subsequent entries. ! ! Routine 'backspace' moves the internal pointer of 'block_fdf' ! structure to the previous line returned. ! ! Routine 'rewind' moves the internal pointer of 'block_fdf' structure ! to the beginning of the block. ! ! b) Generic interface to scalar routines. ! ! The generic function 'fdf_get' can be used instead of any of the ! scalar routines. The specific names are also accepted. ! ! c) Architecture support: this FDF implementation supports the following !    architectures environments. ! !    1) Thread-safe: The new implementation is thread-safe and will support !       calling it from several OMP-threads executing in the same node. ! !       The implementation is as follows: fdf_init and fdf_shutdown are !       SINGLE/CRITICAL sections that only one thread must execute. !       On the other hand 'get'/'test' routines in FDF library are !       thread-safe because each thread keeps its relative information !       about the search/query that the caller program requests. ! ! Alberto Garcia, 1996-2007 ! Raul de la Cruz (BSC), September 2007 ! ! !======================================================================== MODULE fdf USE io_fdf USE parse , only : parsed_line USE parse , only : nintegers , nreals USE parse , only : nvalues , nnames , ntokens USE parse , only : integers , reals USE parse , only : values , names , tokens , characters USE parse , only : match USE parse , only : digest , blocks , endblocks , labels USE parse , only : destroy , setdebug , setlog , setmorphol USE parse , only : nlists , nintegerlists , nreallists USE parse , only : integerlists , reallists , valuelists USE parse , only : search USE parse , only : fdf_bsearch => search USE parse , only : fdf_substring_search => substring_search USE parse , only : serialize_pline , recreate_pline USE parse , only : SERIALIZED_LENGTH USE utils USE prec USE legacy_units_m , only : fdf_legacy_unit_handler => inquire_unit implicit none interface subroutine inquire_unit_p ( unit_str , stat , phys_dim , unit_name , unit_value ) import :: dp character ( len =* ), intent ( in ) :: unit_str character ( len =* ), intent ( out ) :: phys_dim character ( len =* ), intent ( out ) :: unit_name real ( dp ), intent ( out ) :: unit_value integer , intent ( out ) :: stat end subroutine inquire_unit_p end interface procedure ( inquire_unit_p ), pointer :: inquire_unit => null () ! User callable routines in FDF library ! Start, stop FDF system public :: fdf_init , fdf_shutdown ! Reading label functions public :: fdf_get public :: fdf_integer , fdf_single , fdf_double public :: fdf_string , fdf_boolean public :: fdf_physical ! Lists public :: fdf_islist , fdf_islinteger , fdf_islreal public :: fdf_list , fdf_linteger , fdf_ldouble ! Returns the string associated with a mark line public :: fdf_getline ! Test if label is defined public :: fdf_defined , fdf_isphysical , fdf_isblock ! Allow to overwrite things in the FDF public :: fdf_overwrite , fdf_removelabel , fdf_addline ! Test if a label is used in obsolete or a deprecated state public :: fdf_deprecated , fdf_obsolete ! %block reading (processing each line) public :: fdf_block , fdf_block_linecount public :: fdf_bline , fdf_bbackspace , fdf_brewind , fdf_bclose public :: fdf_bnintegers , fdf_bnreals , fdf_bnvalues , fdf_bnnames , fdf_bntokens public :: fdf_bintegers , fdf_breals , fdf_bvalues , fdf_bnames , fdf_btokens public :: fdf_bboolean , fdf_bphysical public :: fdf_bnlists , fdf_bnilists , fdf_bnrlists , fdf_bnvlists public :: fdf_bilists , fdf_brlists , fdf_bvlists ! Match, search over blocks, and destroy block structure public :: fdf_bmatch , fdf_bsearch , fdf_substring_search public :: fdf_setoutput , fdf_setdebug ! Units handling ! The legacy name fdf_convfac is still exported, but ! it is only useful after having set the ! unit conversion function public :: fdf_convfac public :: fdf_legacy_unit_handler public :: fdf_set_unit_handler public :: fdf_get_unit_handler ! Private functions, non-callable ! Main functions to build FDF structure (called in fdf_init) private :: fdf_initdata , fdf_addtoken , fdf_readline private :: fdf_read , fdf_readlabel , fdf_searchlabel private :: fdf_open , fdf_close ! Input/Output configuration private :: fdf_input !  private :: fdf_set_output_file ! Destroy dynamic list of FDF structure (called in fdf_shutdown) private :: fdf_destroy , fdf_destroy_dl ! Debugging functions, level and prints debugging info public :: fdf_printfdf ! Finds a label in the FDF herarchy private :: fdf_locate ! Dump function (for blocks) private :: fdf_dump ! Wrappers functions for block access, search, matching, ! number and elements in the block (call to parse module) interface fdf_bnintegers module procedure nintegers end interface interface fdf_bnlists module procedure nlists end interface interface fdf_bnilists module procedure nintegerlists end interface interface fdf_bnrlists module procedure nreallists end interface interface fdf_bnvlists module procedure nlists end interface interface fdf_bnreals module procedure nreals end interface interface fdf_bnvalues module procedure nvalues end interface interface fdf_bnnames module procedure nnames end interface interface fdf_bntokens module procedure ntokens end interface interface fdf_bintegers module procedure integers end interface interface fdf_bilists module procedure integerlists end interface interface fdf_brlists module procedure reallists end interface interface fdf_bvlists module procedure valuelists end interface interface fdf_breals module procedure reals end interface interface fdf_bvalues module procedure values end interface interface fdf_bnames module procedure names end interface interface fdf_btokens module procedure tokens end interface interface fdf_bmatch module procedure match end interface ! fdf_get wrapper for label functions interface fdf_get module procedure fdf_integer module procedure fdf_single module procedure fdf_double module procedure fdf_boolean module procedure fdf_string module procedure fdf_physical end interface ! fdf_list wrapper for integer/real list functions interface fdf_list module procedure fdf_linteger module procedure fdf_ldouble end interface ! Unit numbers for input, output, error notification, and ! debugging output (the latter active if fdf_debug is true) logical , private :: fdf_debug = . FALSE ., & fdf_debug2 = . FALSE ., & fdf_started = . FALSE ., & fdf_output = . FALSE . integer ( ip ), parameter , private :: maxdepth = 7 integer ( ip ), parameter , private :: maxFileNameLength = 300 integer ( ip ), private :: ndepth integer ( ip ), private :: fdf_in ( maxdepth ) integer ( ip ), private :: fdf_out , fdf_err , fdf_log ! Structure for searching inside fdf blocks type , public :: block_fdf character ( len = MAX_LENGTH ) :: label type ( line_dlist ), pointer :: mark => null () end type block_fdf ! Dynamic list for parsed_line structures type , public :: line_dlist character ( len = MAX_LENGTH ) :: str type ( parsed_line ), pointer :: pline => null () ! type ( line_dlist ), pointer :: next => null () type ( line_dlist ), pointer :: prev => null () end type line_dlist ! FDF data structure (first and last lines) type , private :: fdf_file integer ( ip ) :: nlines type ( line_dlist ), pointer :: first => null () type ( line_dlist ), pointer :: last => null () end type fdf_file ! Input FDF file type ( fdf_file ), private :: file_in ! Export the following to enable serialization by clients of the library public :: fdf_serialize_struct public :: fdf_recreate_struct public :: fdf_set_started ! Define by default all the others inherit module entities as privated ! avoiding redefinitions of entities in several module files with same name public :: parsed_line ! Structure for searching inside fdf blocks public :: leqi ! For legacy support (old codes) private CONTAINS ! !   Initialization for fdf. ! SUBROUTINE fdf_init ( fileInput , fileOutput , unitInput ) implicit none !------------------------------------------------------------- Input Variables character ( len =* ), optional , intent ( in ) :: fileInput , fileOutput integer , optional , intent ( in ) :: unitInput #ifndef FDF_DEBUG !------------------------------------------------------------- Local Variables integer ( ip ) :: debug_level , output_level #endif character ( len = 256 ) :: filedebug character ( len = maxFileNameLength ) :: filein , fileout !----------------------------------------------------------------------- BEGIN !$OMP SINGLE ! Prevent the user from opening two head files if ( fdf_started ) then call die ( 'FDF module: fdf_init' , 'Head file already set' , & THIS_FILE , __ LINE__ , fdf_err ) endif call fdf_initdata () call io_geterr ( fdf_err ) ! Set in/out file names, if fileInput and fileOutput are not present call set_file_names ( filein , fileout , & fileInput , fileOutput , unitInput ) filedebug = trim ( fileout ) // \".debug\" call fdf_input ( filein ) fdf_started = . TRUE . ! Set the legacy unit handler by default ! Client codes should make sure that they use an updated units table and handler call fdf_set_unit_handler ( fdf_legacy_unit_handler ) ! Flags within the fdf file itself. ! At this point only the final fdf data structure will be shown, ! for level >= 2 debug_level = fdf_get ( 'fdf-debug' , 0 ) call fdf_setdebug ( debug_level , filedebug ) ! The default is to have output only in the master node output_level = fdf_get ( 'fdf-output' , 1 ) call fdf_setoutput ( output_level , fileout ) if ( debug_level >= 2 ) call fdf_printfdf () !$OMP END SINGLE RETURN !------------------------------------------------------------------------- END END SUBROUTINE fdf_init SUBROUTINE set_file_names ( fileIn , fileOut , & optFileIn , optFileOut , unitIn ) ! If present, copies input arguments optFileIn/Out to fileIn/Out. ! If absent, generates In/Out file names. If unitIn is present, and it is ! a named file, returns it as fileIn. If not, it copies input to a new ! file and returns its name. If .not.present(unitIn) => unitIn=5. ! If optFileIn is present, unitIn is ignored. implicit none character ( len =* ), intent ( out ) :: & fileIn , & ! Name of file to be used as input fileOut ! Name of file to be used as output character ( len =* ), optional , intent ( in ) :: & optFileIn , & ! Optional argument with input file name optFileOut ! Optional argument with output file name integer , optional , intent ( in ) :: & unitIn ! Optional input file unit (not used if present(optFileIn)) integer :: count , ierr , iostat , iu , iuIn logical :: named , opened character ( len = MAX_LENGTH * 2 ) line character ( len = maxFileNameLength ) fileName !------------------------------------------------------------------------- BEGIN ! Find a job-specific number call system_clock ( count ) count = mod ( count , 100000 ) ! Set output file name if ( present ( optFileOut )) then if ( len ( trim ( optFileOut )) > len ( fileOut )) & call die ( 'FDF module: set_file_names' , & 'Parameter maxFileNameLength too small.' // & 'Terminating.' , THIS_FILE , __ LINE__ , fdf_err , rc = ierr ) fileOut = optFileOut else ! set a job-specific file name write ( fileOut , '(a,i5.5,a)' ) 'fdf_' , count , '.log' endif ! Set input file if ( present ( optFileIn )) then ! just copy the file name if ( len ( trim ( optFileIn )) > len ( fileIn )) & call die ( 'FDF module: set_file_names' , & 'Parameter maxFileNameLength too small.' // & 'Terminating.' , THIS_FILE , __ LINE__ , fdf_err , rc = ierr ) fileIn = optFileIn else ! find or set a file name ! Find input file unit if ( present ( unitIn )) then ! use given unit (possibly 5) iuIn = unitIn else ! assume standard input iuIn = 5 endif ! Find file name associated with given unit if ( iuIn == 5 ) then ! no valid file name fileName = ' ' else ! check if this is a named file inquire ( unit = iuIn , opened = opened ) if ( opened ) then inquire ( unit = iuIn , named = named ) if ( named ) then ! inquire file name inquire ( unit = iuIn , name = fileName ) else ! no valid file name fileName = ' ' endif ! (named) else call die ( 'FDF module: set_file_names' , 'Input unit not opened.' // & 'Terminating.' , THIS_FILE , __ LINE__ , fdf_err , rc = ierr ) endif ! (opened) endif ! (iuIn==5) ! Set input file name, possibly after copying input to it if ( fileName == ' ' ) then ! not a valid file write ( fileIn , '(a,i5.5,a)' ) & 'INPUT_TMP_' , count , '.fdf' ! new file's name call io_assign ( iu ) ! new file's unit open ( iu , file = trim ( fileIn ), form = 'formatted' ) ! open new file do read ( iuIn , iostat = iostat , fmt = '(a)' ) line ! read line from old unit if ( iostat /= 0 ) exit write ( iu , '(a)' ) trim ( line ) ! write line to new file enddo call io_close ( iu ) ! close new file else ! valid file fileIn = fileName endif ! (fileName=='stdin') endif ! (present(optFileIn)) !--------------------------------------------------------------------------- END END SUBROUTINE set_file_names ! !   Reads the input file ! SUBROUTINE fdf_input ( filein ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: filein !------------------------------------------------------------------------- BEGIN call fdf_read ( filein ) if ( fdf_output ) write ( fdf_out , '(a,a,a,i3)' ) '#FDF module: Opened ' , filein , & ' for input. Unit:' , fdf_in ( 1 ) RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_input !   Read an input file (and include files) and builds memory !   structure that will contain the data and will help in searching ! RECURSIVE SUBROUTINE fdf_read ( filein , blocklabel ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: filein character ( * ), optional :: blocklabel !--------------------------------------------------------------- Local Variables logical :: dump logical , allocatable :: found (:) character ( 80 ) :: msg character ( len = MAX_LENGTH ) :: label , inc_file character ( len = MAX_LENGTH * 2 ) :: line integer ( ip ) :: i , ierr , ntok , ind_less , nlstart type ( parsed_line ), pointer :: pline !------------------------------------------------------------------------- BEGIN !     Open reading input file call fdf_open ( filein ) !     Read each input data line if ( PRESENT ( blocklabel )) then label = blocklabel else label = ' ' endif do while ( fdf_readline ( line )) !       Check if valid data (tokens, non-blank) pline => digest ( line ) ntok = ntokens ( pline ) if ( ntok . ne . 0 ) then !         Find different special cases in the input files !         (%block, %endblock, %include, Label1 Label2 ... < Filename) !         %block directive ind_less = search ( '<' , pline ) if ( search ( '%block' , pline ) . eq . 1 ) then !           No label found in %block directive if ( ntok . eq . 1 ) then write ( msg , * ) '%block label not found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_read' , msg , & THIS_FILE , __ LINE__ , fdf_err ) endif !           %block Label < Filename [ %dump ] if ( ind_less . eq . 3 ) then if ( ntok . ge . 4 ) then !               Test if %dump is present if ( search ( '%dump' , pline ) . eq . 5 ) then dump = . TRUE . else dump = . FALSE . endif !               Add begin, body and end sections of block label = tokens ( pline , 2 ) inc_file = tokens ( pline , 4 ) call destroy ( pline ) line = '%block ' // label pline => digest ( line ) call setmorphol ( 1 , 'b' , pline ) call setmorphol ( 2 , 'l' , pline ) call fdf_addtoken ( line , pline ) nullify ( pline ) ! it is stored in line nlstart = file_in % nlines call fdf_read ( inc_file , label ) !               Warn if block 'label' is empty if (( nlstart - file_in % nlines ) . eq . 0 ) then write ( msg , * ) 'FDF module: fdf_read: block ' , & TRIM ( label ), ' is empty...' call warn ( msg ) endif line = '%endblock ' // label pline => digest ( line ) call setmorphol ( 1 , 'e' , pline ) call setmorphol ( 2 , 'l' , pline ) call fdf_addtoken ( line , pline ) nullify ( pline ) ! it is stored in line !               Dump included file to fileout if ( dump ) call fdf_dump ( label ) label = ' ' !             Filename not found in %block directive else write ( msg , * ) '%block filename not found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_read' , msg , & THIS_FILE , __ LINE__ , fdf_err ) endif !           %block Label elseif ( ind_less . eq . - 1 ) then label = tokens ( pline , 2 ) call setmorphol ( 1 , 'b' , pline ) call setmorphol ( 2 , 'l' , pline ) call fdf_addtoken ( line , pline ) nullify ( pline ) ! it is stored in line nlstart = file_in % nlines !           Bad format in %block directive else write ( msg , * ) 'Bad ''<'' %block format in ' , TRIM ( filein ) call die ( 'FDF module: fdf_read' , msg , & THIS_FILE , __ LINE__ , fdf_err ) endif !         %endblock directive elseif ( search ( '%endblock' , pline ) . eq . 1 ) then !           Check if %block exists before %endblock if ( label . eq . ' ' ) then write ( msg , * ) 'Bad %endblock found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_read' , msg , & THIS_FILE , __ LINE__ , fdf_err ) else !             Warn if block 'label' is empty if (( nlstart - file_in % nlines ) . eq . 0 ) then write ( msg , * ) 'FDF module: fdf_read: block ' , & TRIM ( label ), ' is empty...' call warn ( msg ) endif call destroy ( pline ) line = '%endblock ' // label pline => digest ( line ) call setmorphol ( 1 , 'e' , pline ) call setmorphol ( 2 , 'l' , pline ) call fdf_addtoken ( line , pline ) nullify ( pline ) ! it is stored in line label = ' ' endif !         %include Filename directive elseif ( search ( '%include' , pline ) . eq . 1 ) then !           Check if include filename is specified if ( ntok . eq . 1 ) then write ( msg , * ) 'Filename on %include not found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_read' , msg , & THIS_FILE , __ LINE__ , fdf_err ) else inc_file = tokens ( pline , 2 ) call fdf_read ( inc_file ) endif ! Clean pline (we simply insert the next file) call destroy ( pline ) !         Label1 Label2 ... < Filename directive elseif ( ind_less . ne . - 1 ) then !           Check if '<' is in a valid position if ( ind_less . eq . 1 ) then write ( msg , * ) 'Bad ''<'' found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_read' , msg , & THIS_FILE , __ LINE__ , fdf_err ) !           Check if '<' filename is specified elseif ( ind_less . eq . ntok ) then write ( msg , * ) 'Filename not found after ''<'' in ' , TRIM ( filein ) call die ( 'FDF module: fdf_read' , msg , & THIS_FILE , __ LINE__ , fdf_err ) else !             Search label(s) in Filename inc_file = tokens ( pline , ind_less + 1 ) ALLOCATE ( found ( ind_less - 1 ), stat = ierr ) if ( ierr . ne . 0 ) then call die ( 'FDF module: fdf_read' , 'Error allocating found' , & THIS_FILE , __ LINE__ , fdf_err , rc = ierr ) endif !             If label(s) not found in such Filename throw an error found = . FALSE . if (. not . fdf_readlabel ( ind_less - 1 , pline , & inc_file , found )) then i = 1 do while (( i . le . ind_less - 1 ) . and . ( found ( i ))) i = i + 1 enddo label = tokens ( pline , i ) write ( msg , * ) 'Label ' , TRIM ( label ), & ' not found in ' , TRIM ( inc_file ) call die ( 'FDF module: fdf_read' , msg , & THIS_FILE , __ LINE__ , fdf_err ) endif call destroy ( pline ) DEALLOCATE ( found ) endif !         Add remaining kind of tokens to dynamic list as labels else if ( label . eq . ' ' ) call setmorphol ( 1 , 'l' , pline ) call fdf_addtoken ( line , pline ) nullify ( pline ) ! it is stored in line endif else !         Destroy parsed_line structure if no elements call destroy ( pline ) endif enddo !     Close one level of input file if ((. not . PRESENT ( blocklabel )) . and . ( label . ne . ' ' )) then write ( msg , * ) '%endblock ' , TRIM ( label ), & ' not found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_read' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif call fdf_close () RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_read ! !   Read an input file (and include files) searching labels to !   include them in memory structure that will contain the data ! RECURSIVE FUNCTION fdf_readlabel ( nelem , plabel , filein , found ) result ( readlabel ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: filein integer ( ip ) :: nelem type ( parsed_line ), pointer :: plabel !-------------------------------------------------------------- Output Variables logical :: readlabel logical :: found ( nelem ) !--------------------------------------------------------------- Local Variables logical :: dump , found_elem logical , pointer :: found_loc (:) character ( 80 ) :: msg character ( len = MAX_LENGTH * 2 ) :: line character ( len = MAX_LENGTH ) :: label , inc_file integer ( ip ) :: i , ierr , ntok , ind_less , nlstart integer ( ip ) :: elem , nelem_loc integer ( ip ), pointer :: found_index (:) type ( parsed_line ), pointer :: pline !------------------------------------------------------------------------- BEGIN !     Open input file with labels call fdf_open ( filein ) !     While not reach to end of file and found all labels do while ( fdf_readline ( line ) . and . (. not . ALL ( found ))) !       Check if valid data (tokens, non-blank) pline => digest ( line ) ntok = ntokens ( pline ) if ( ntok . ne . 0 ) then !         Find different special cases in the input files !         (%block, %endblock, %include, Label1 Label2 ... < Filename) !         %block directive ind_less = search ( '<' , pline ) if ( search ( '%block' , pline ) . eq . 1 ) then !           No label found in %block directive if ( ntok . eq . 1 ) then write ( msg , * ) '%block label not found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_readlabel' , msg , & THIS_FILE , __ LINE__ , fdf_err ) endif !           %block Label < Filename [ %dump ] if ( ind_less . eq . 3 ) then if ( ntok . ge . 4 ) then !               Test if %dump is present if ( search ( '%dump' , pline ) . eq . 5 ) then dump = . TRUE . else dump = . FALSE . endif label = tokens ( pline , 2 ) elem = fdf_searchlabel ( found , nelem , label , plabel ) inc_file = tokens ( pline , 4 ) call destroy ( pline ) !               If match with any label add [begin, body, end] of block if ( elem . ne . - 1 ) then line = '%block ' // label pline => digest ( line ) call setmorphol ( 1 , 'b' , pline ) call setmorphol ( 2 , 'l' , pline ) call fdf_addtoken ( line , pline ) nlstart = file_in % nlines call fdf_read ( inc_file , label ) !                 Warn if block 'label' is empty if (( nlstart - file_in % nlines ) . eq . 0 ) then write ( msg , * ) 'FDF module: fdf_readlabel: block ' , & TRIM ( label ), ' is empty...' call warn ( msg ) endif line = '%endblock ' // label pline => digest ( line ) call setmorphol ( 1 , 'e' , pline ) call setmorphol ( 2 , 'l' , pline ) call fdf_addtoken ( line , pline ) !                 Dump included file to fileout if ( dump ) call fdf_dump ( label ) found ( elem ) = . TRUE . label = ' ' endif !             Filename not found in %block directive else write ( msg , * ) 'Filename on %block not found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_readlabel' , msg , & THIS_FILE , __ LINE__ , fdf_err ) endif !           %block Label elseif ( ind_less . eq . - 1 ) then label = tokens ( pline , 2 ) elem = fdf_searchlabel ( found , nelem , label , plabel ) found_elem = . TRUE . !             If match with any label add [begin,body,end] of block if ( elem . ne . - 1 ) then call setmorphol ( 1 , 'b' , pline ) call setmorphol ( 2 , 'l' , pline ) call fdf_addtoken ( line , pline ) nlstart = file_in % nlines found_elem = . FALSE . do while ( fdf_readline ( line ) . and . (. not . found_elem )) pline => digest ( line ) if ( ntokens ( pline ) . ne . 0 ) then if ( search ( '%endblock' , pline ) . eq . 1 ) then !                     Warn if block 'label' is empty if (( nlstart - file_in % nlines ) . eq . 0 ) then write ( msg , * ) 'FDF module: fdf_readlabel: block ' , & TRIM ( label ), ' is empty...' call warn ( msg ) endif call destroy ( pline ) line = '%endblock ' // label pline => digest ( line ) call setmorphol ( 1 , 'e' , pline ) call setmorphol ( 2 , 'l' , pline ) label = ' ' found_elem = . TRUE . found ( elem ) = . TRUE . endif call fdf_addtoken ( line , pline ) endif enddo !             Move to the end of the block else call destroy ( pline ) found_elem = . FALSE . do while ( fdf_readline ( line ) . and . (. not . found_elem )) pline => digest ( line ) if ( search ( '%endblock' , pline ) . eq . 1 ) then label = ' ' found_elem = . TRUE . endif call destroy ( pline ) enddo endif !             Error due to %endblock not found if (. not . found_elem ) then write ( msg , * ) '%endblock ' , TRIM ( label ), & ' not found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_readlabel' , msg , & THIS_FILE , __ LINE__ , fdf_err ) endif !           Bad format in %block directive else write ( msg , * ) 'Bad ''<'' %block format in ' , TRIM ( filein ) call die ( 'FDF module: fdf_readlabel' , msg , & THIS_FILE , __ LINE__ , fdf_err ) endif !         %endblock directive elseif ( search ( '%endblock' , pline ) . eq . 1 ) then !           Bad if %endblock exists before %block write ( msg , * ) 'Bad %endblock found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_readlabel' , msg , & THIS_FILE , __ LINE__ , fdf_err ) !         %include Filename directive elseif ( search ( '%include' , pline ) . eq . 1 ) then !           Check if include filename is specified if ( ntok . eq . 1 ) then write ( msg , * ) 'Filename on %include not found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_readlabel' , msg , & THIS_FILE , __ LINE__ , fdf_err ) else inc_file = tokens ( pline , 2 ) call destroy ( pline ) readlabel = fdf_readlabel ( nelem , plabel , inc_file , found ) endif !         Label1 Label2 ... < Filename directive elseif ( ind_less . ne . - 1 ) then !           Check if '<' is in a valid position if ( ind_less . eq . 1 ) then write ( msg , * ) 'Bad ''<'' found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_readlabel' , msg , & THIS_FILE , __ LINE__ , fdf_err ) !           Check if '<' filename is specified elseif ( ind_less . eq . ntok ) then write ( msg , * ) 'Filename not found after ''<'' in ' , TRIM ( filein ) call die ( 'FDF module: fdf_readlabel' , msg , & THIS_FILE , __ LINE__ , fdf_err ) else !             Search label(s) in Filename line = ' ' nelem_loc = 0 ALLOCATE ( found_index ( ind_less - 1 ), stat = ierr ) if ( ierr . ne . 0 ) then call die ( 'FDF module: fdf_readlabel' , 'Error allocating found_index' , & THIS_FILE , __ LINE__ , fdf_err , rc = ierr ) endif do i = 1 , ind_less - 1 label = tokens ( pline , i ) elem = fdf_searchlabel ( found , nelem , label , plabel ) if ( elem . ne . - 1 ) then line = TRIM ( line ) // ' ' // TRIM ( label ) nelem_loc = nelem_loc + 1 found_index ( nelem_loc ) = elem endif enddo !             Process Filename if any label found if ( nelem_loc . ge . 1 ) then inc_file = tokens ( pline , ind_less + 1 ) call destroy ( pline ) ALLOCATE ( found_loc ( nelem_loc ), stat = ierr ) if ( ierr . ne . 0 ) then call die ( 'FDF module: fdf_readlabel' , 'Error allocating found_loc' , & THIS_FILE , __ LINE__ , fdf_err , rc = ierr ) endif found_loc = . FALSE . !               If label(s) not found in such Filename throw an error pline => digest ( line ) if (. not . fdf_readlabel ( nelem_loc , pline , & inc_file , found_loc )) then i = 1 do while (( i . le . nelem_loc ) . and . ( found_loc ( i ))) i = i + 1 enddo label = tokens ( pline , i ) write ( msg , * ) 'Label ' , TRIM ( label ), ' not found in ' , TRIM ( inc_file ) call die ( 'FDF module: fdf_readlabel' , msg , & THIS_FILE , __ LINE__ , fdf_err ) else !                 Merge results if all labels found do i = 1 , nelem_loc found ( found_index ( i )) = found_loc ( i ) enddo endif DEALLOCATE ( found_index ) endif DEALLOCATE ( found_loc ) call destroy ( pline ) endif !         Label [ Value ] directive else elem = fdf_searchlabel ( found , nelem , tokens ( pline , 1 ), plabel ) !           If match with any label add it if ( elem . ne . - 1 ) then call setmorphol ( 1 , 'l' , pline ) call fdf_addtoken ( line , pline ) found ( elem ) = . TRUE . else !             Destroy parsed_line structure if no label found call destroy ( pline ) endif endif else !         Destroy parsed_line structure if no label found call destroy ( pline ) endif enddo !     Close input file with labels call fdf_close () readlabel = ALL ( found ) RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_readlabel ! !   Search a label in a set of not 'found' tokens given by plabel and nelem. !   Returns the index on plabel of the token that matches with label. ! FUNCTION fdf_searchlabel ( found , nelem , label , plabel ) implicit none !--------------------------------------------------------------- Input Variables integer ( ip ) :: nelem logical :: found ( nelem ) character ( * ) :: label type ( parsed_line ), pointer :: plabel !-------------------------------------------------------------- Output Variables integer ( ip ) :: fdf_searchlabel !--------------------------------------------------------------- Local Variables logical :: found_elem integer ( ip ) :: i !------------------------------------------------------------------------- BEGIN i = 1 found_elem = . FALSE . fdf_searchlabel = - 1 do while (( i . le . nelem ) . and . (. not . found_elem )) if (. not . found ( i )) then if ( labeleq ( label , tokens ( plabel , i ))) then found_elem = . TRUE . fdf_searchlabel = i endif endif i = i + 1 enddo RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_searchlabel ! !   Dumps the content of a block ! SUBROUTINE fdf_dump ( label ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label !--------------------------------------------------------------- Local Variables character ( 80 ) :: msg type ( block_fdf ) :: bfdf type ( parsed_line ), pointer :: pline !------------------------------------------------------------------------- BEGIN fdf_started = . TRUE . if (. not . fdf_block ( label , bfdf )) then write ( msg , * ) 'block ' , label , 'to dump not found' call die ( 'FDF module: fdf_dump' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif !     fdf_bline prints each block line in fdf_out do while ( fdf_bline ( bfdf , pline )) enddo fdf_started = . FALSE . RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_dump ! !   Init FDF file structure ! SUBROUTINE fdf_initdata () implicit none !--------------------------------------------------------------- Local Variables integer ( ip ) :: ierr !------------------------------------------------------------------------- BEGIN ndepth = 0 file_in % nlines = 0 NULLIFY ( file_in % first ) NULLIFY ( file_in % last ) RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_initdata ! !   Add a line individually to the dynamic list of parsed lines !   This can not include block's and is restricted to key values ! SUBROUTINE fdf_addline ( line ) implicit none !--------------------------------------------------------------- Input Variables character ( len =* ) :: line !--------------------------------------------------------------- Local Variables integer ( ip ) :: ntok type ( parsed_line ), pointer :: pline !------------------------------------------------------------------------- BEGIN !     Check if valid data (tokens, non-blank) pline => digest ( line ) call setmorphol ( 1 , 'l' , pline ) call fdf_addtoken ( line , pline ) if ( fdf_debug2 ) then write ( fdf_log , * ) '***FDF_ADDLINE********************************' write ( fdf_log , * ) 'Line:' , TRIM ( line ) write ( fdf_log , * ) '**********************************************' endif END SUBROUTINE fdf_addline ! !   Remove a line from the dynamic list of parsed lines !   This can not include block's and is restricted to key values ! SUBROUTINE fdf_removelabel ( label ) implicit none !--------------------------------------------------------------- Input Variables character ( len =* ) :: label !--------------------------------------------------------------- Local Variables type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN do while ( fdf_locate ( label , mark ) ) if ( fdf_debug2 ) then write ( fdf_log , * ) '***FDF_REMOVELABEL*******************************' write ( fdf_log , * ) 'Line:' , TRIM ( mark % str ) write ( fdf_log , * ) 'Label:' , trim ( label ) write ( fdf_log , * ) '**********************************************' endif ! To circumvent the first/last line in the fdf-file ! we have to check for the existence of the ! first/last mark being the one removed. ! That special case *must* correct the first/last ! tokens. if ( associated ( mark , target = file_in % first ) ) then file_in % first => mark % next end if if ( associated ( mark , target = file_in % last ) ) then file_in % last => mark % prev end if ! Remove the label from the dynamic list call destroy ( mark % pline ) if ( associated ( mark % prev ) ) then mark % prev % next => mark % next end if if ( associated ( mark % next ) ) then mark % next % prev => mark % prev end if DEALLOCATE ( mark ) NULLIFY ( mark ) end do END SUBROUTINE fdf_removelabel ! !   Overwrite label line in dynamic list of parsed lines ! SUBROUTINE fdf_overwrite ( line ) !--------------------------------------------------------------- Input Variables character ( len =* ) :: line !--------------------------------------------------------------- Local Variables type ( parsed_line ), pointer :: pline character ( len = MAX_LENGTH ) :: label integer :: ierr pline => digest ( line ) if ( search ( '%block' , pline ) == 1 . or . & search ( '%endblock' , pline ) == 1 ) then ! We do not allow this in a single line call die ( 'FDF module: fdf_overwrite' , 'Error overwriting block (not implemented)' , & THIS_FILE , __ LINE__ , fdf_err , rc = ierr ) else if ( search ( '%include' , pline ) == 1 ) then ! We do not allow this in a single line call die ( 'FDF module: fdf_overwrite' , 'Error overwriting flags from input file (not implemented)' , & THIS_FILE , __ LINE__ , fdf_err , rc = ierr ) else if ( search ( '<' , pline ) /= - 1 ) then ! We do not allow this in a single line call die ( 'FDF module: fdf_overwrite' , 'Error piping in overwriting (not implemented)' , & THIS_FILE , __ LINE__ , fdf_err , rc = ierr ) else label = tokens ( pline , 1 ) call setmorphol ( 1 , 'l' , pline ) call fdf_removelabel ( label ) ! Add token to the list of fdf-flags ! Since we add it directly we shouldn't destroy the pline call fdf_addtoken ( line , pline ) if ( fdf_debug ) then write ( fdf_log , '(2a)' ) '---> Overwriting token: ' , trim ( label ) end if end if END SUBROUTINE fdf_overwrite ! !   Add a token to the dynamic list of parsed lines ! SUBROUTINE fdf_addtoken ( line , pline ) implicit none !--------------------------------------------------------------- Input Variables character ( len =* ) :: line type ( parsed_line ), pointer :: pline !--------------------------------------------------------------- Local Variables integer ( ip ) :: i , ierr type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN ALLOCATE ( mark , stat = ierr ) if ( ierr . ne . 0 ) then call die ( 'FDF module: fdf_addtoken' , 'Error allocating mark' , & THIS_FILE , __ LINE__ , fdf_err , rc = ierr ) endif mark % str = line mark % pline => pline NULLIFY ( mark % next ) ! Add entry at the END of structure if ( ASSOCIATED ( file_in % first )) then mark % prev => file_in % last file_in % last % next => mark else NULLIFY ( mark % prev ) file_in % first => mark endif file_in % last => mark file_in % nlines = file_in % nlines + 1 if ( fdf_debug2 ) then write ( fdf_log , * ) '***FDF_ADDTOKEN*******************************' write ( fdf_log , * ) 'Line:' , TRIM ( mark % str ) write ( fdf_log , * ) 'Ntokens:' , mark % pline % ntokens do i = 1 , mark % pline % ntokens write ( fdf_log , * ) '  Token:' , trim ( tokens ( pline , i )), & ' (' , mark % pline % id ( i ), ')' enddo write ( fdf_log , * ) '**********************************************' endif RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_addtoken ! !   Opens a file for FDF processing. ! SUBROUTINE fdf_open ( filename ) implicit none !-------------------------------------------------------------- Output Variables character ( * ) :: filename !--------------------------------------------------------------- Local Variables logical :: file_exists character ( 80 ) :: msg integer ( ip ) :: lun !------------------------------------------------------------------------- BEGIN ndepth = ndepth + 1 if ( ndepth . gt . maxdepth ) then call die ( 'FDF module: fdf_open' , 'Too many nested fdf files...' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( leqi ( filename , 'stdin' )) then lun = INPUT_UNIT if ( fdf_debug ) write ( fdf_log , '(a,i1,a)' ) & '---> Reading from standard input [DEPTH:' , ndepth , '] ' else call io_assign ( lun ) INQUIRE ( file = filename , exist = file_exists ) if ( file_exists ) then open ( unit = lun , file = filename , status = 'old' , form = 'formatted' ) REWIND ( lun ) if ( fdf_debug ) write ( fdf_log , '(a,i1,a,a)' ) & '---> Opened [DEPTH:' , ndepth , '] ' , TRIM ( filename ) else write ( msg , '(a,a)' ) 'Cannot open ' , TRIM ( filename ) call die ( 'FDF module: fdf_open' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif endif fdf_in ( ndepth ) = lun REWIND ( fdf_in ( ndepth )) RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_open ! !   Closes currently opened fdf file ! SUBROUTINE fdf_close () implicit none !------------------------------------------------------------------------- BEGIN if ( ndepth . ge . 1 ) then call io_close ( fdf_in ( ndepth )) if ( fdf_debug ) & write ( fdf_log , '(a,i1,a)' ) '---> Closed [DEPTH:' , ndepth , ']' ndepth = ndepth - 1 endif RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_close ! !   Set output file for FDF subsystem ! SUBROUTINE fdf_set_output_file ( fileout ) implicit none !----------------------------------------------------- Input Variables character ( len =* ), intent ( in ) :: fileout !----------------------------------------------------- Local Variables character ( 256 ) :: fileouttmp !----------------------------------------------------- BEGIN call io_assign ( fdf_out ) open ( unit = fdf_out , file = TRIM ( fileout ), form = 'formatted' , & access = 'sequential' , status = 'replace' ) RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_set_output_file ! !   Frees and shutdown FDF system ! SUBROUTINE fdf_shutdown () implicit none !------------------------------------------------------------------------- BEGIN !$OMP SINGLE if ( fdf_started ) then call fdf_destroy ( file_in ) fdf_started = . FALSE . call io_close ( fdf_out ) inquire_unit => null () endif !$OMP END SINGLE RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_shutdown ! !   Destroy the fdf_file structure for the input file ! SUBROUTINE fdf_destroy ( fdfp ) implicit none !-------------------------------------------------------------- Output Variables type ( fdf_file ) :: fdfp !------------------------------------------------------------------------- BEGIN if ( ASSOCIATED ( fdfp % first )) call fdf_destroy_dl ( fdfp % first ) RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_destroy ! !   Destroy recursively the dynamic list of parsed lines ! RECURSIVE SUBROUTINE fdf_destroy_dl ( dlp ) implicit none !-------------------------------------------------------------- Output Variables type ( line_dlist ), pointer :: dlp !! Use for tail recursion later:      type(line_dlist), pointer :: pnext !------------------------------------------------------------------------- BEGIN ! This is NOT tail-recursive!! if ( ASSOCIATED ( dlp % next )) call fdf_destroy_dl ( dlp % next ) call destroy ( dlp % pline ) DEALLOCATE ( dlp ) RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_destroy_dl ! !   Read a line of the 'ndepth' input file, returning .TRUE. if !   there are more lines to read from input file, .FALSE. otherwise. ! FUNCTION fdf_readline ( line ) implicit none !-------------------------------------------------------------- Output Variables logical :: fdf_readline character ( * ) :: line !--------------------------------------------------------------- Local Variables integer ( ip ) :: stat !------------------------------------------------------------------------- BEGIN read ( fdf_in ( ndepth ), '(a)' , iostat = stat ) line if ( stat . eq . 0 ) then fdf_readline = . TRUE . if ( fdf_debug2 ) write ( fdf_log , '(a,a76)' ) 'fdf_readline > ' , line else fdf_readline = . FALSE . endif RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_readline ! !   Returns the string line associated with the mark pointer !   in the FDF herarchy. If mark is not associated returns ''. ! FUNCTION fdf_getline ( mark ) implicit none !--------------------------------------------------------------- Input Variables type ( line_dlist ), pointer :: mark !-------------------------------------------------------------- Output Variables character ( len = MAX_LENGTH ) :: fdf_getline !------------------------------------------------------------------------- BEGIN if ( ASSOCIATED ( mark )) then fdf_getline = mark % str else fdf_getline = ' ' endif RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_getline ! !   Prints all the fdf_file structure of the input file(s) ! SUBROUTINE fdf_printfdf () implicit none !--------------------------------------------------------------- Local Variables integer ( ip ) :: i , ntokens character * 1 :: id type ( line_dlist ), pointer :: dlp character ( len = MAX_LENGTH ) :: tok !------------------------------------------------------------------------- BEGIN dlp => file_in % first write ( fdf_log , * ) '*** FDF Memory Structure Summary: ************' do while ( ASSOCIATED ( dlp )) ntokens = dlp % pline % ntokens write ( fdf_log , * ) 'Line:' , TRIM ( dlp % str ) write ( fdf_log , * ) 'Ntokens:' , ntokens do i = 1 , ntokens tok = tokens ( dlp % pline , i ) id = dlp % pline % id ( i ) write ( fdf_log , * ) '  Token:' , trim ( tok ), '(' , dlp % pline % id ( i ), ')' enddo dlp => dlp % next enddo write ( fdf_log , * ) '**********************************************' RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_printfdf ! !   Returns an integer associated with label 'label', or the default !   value if label is not found in the fdf file. !   Optionally can return a pointer to the line found. ! FUNCTION fdf_integer ( label , default , line ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label integer ( ip ) :: default !-------------------------------------------------------------- Output Variables integer ( ip ) :: fdf_integer type ( line_dlist ), pointer , optional :: line !--------------------------------------------------------------- Local Variables character ( 80 ) :: msg type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_integer' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( fdf_locate ( label , mark )) then if (. not . match ( mark % pline , 'li' )) then write ( msg , * ) 'no integer value for ' , label call die ( 'FDF module: fdf_integer' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif fdf_integer = integers ( mark % pline , 1 , 1 ) if ( fdf_output ) write ( fdf_out , '(a,5x,i10)' ) label , fdf_integer else fdf_integer = default if ( fdf_output ) write ( fdf_out , '(a,i10,5x,a)' ) label , default , '# default value' endif if ( PRESENT ( line )) line = mark RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_integer ! !   Returns true or false whether or not the label 'label' is !   a value with units or not. !   I.e. it returns true if the line has the form lvn, if not found, or not lvn, !   it returns false. ! FUNCTION fdf_isphysical ( label ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label !-------------------------------------------------------------- Output Variables logical :: fdf_isphysical !--------------------------------------------------------------- Local Variables type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_isphysical' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( fdf_locate ( label , mark )) then fdf_isphysical = match ( mark % pline , 'lvn' ) else fdf_isphysical = . false . endif if ( fdf_output ) write ( fdf_out , '(a,5x,l10)' ) \"#:physical? \" // label , fdf_isphysical RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_isphysical ! !   Returns true or false whether or not the label 'label' is !   a list or not, you cannot get the line out from this routine ! FUNCTION fdf_islist ( label ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label !-------------------------------------------------------------- Output Variables logical :: fdf_islist !--------------------------------------------------------------- Local Variables type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_islist' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( fdf_locate ( label , mark )) then ! if it is a list: fdf_islist = match ( mark % pline , 'le' ) else fdf_islist = . false . endif if ( fdf_output ) write ( fdf_out , '(a,5x,l10)' ) \"#:list? \" // label , fdf_islist RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_islist FUNCTION fdf_islinteger ( label ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label !-------------------------------------------------------------- Output Variables logical :: fdf_islinteger !--------------------------------------------------------------- Local Variables type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_islinteger' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( fdf_locate ( label , mark )) then ! if it is an integer list: fdf_islinteger = match ( mark % pline , 'la' ) else fdf_islinteger = . false . endif if ( fdf_output ) write ( fdf_out , '(a,5x,l10)' ) \"#:linteger? \" // label , & fdf_islinteger RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_islinteger FUNCTION fdf_islreal ( label ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label !-------------------------------------------------------------- Output Variables logical :: fdf_islreal !--------------------------------------------------------------- Local Variables type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_islreal' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( fdf_locate ( label , mark )) then ! if it is a reallist: fdf_islreal = match ( mark % pline , 'lc' ) else fdf_islreal = . false . endif if ( fdf_output ) write ( fdf_out , '(a,5x,l10)' ) \"#:lreal? \" // label , & fdf_islreal RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_islreal ! !   Returns a list with label 'label', or the default !   value if label is not found in the fdf file. ! SUBROUTINE fdf_linteger ( label , ni , list , line ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label integer ( ip ) :: ni !-------------------------------------------------------------- Output Variables integer ( ip ) :: list ( ni ) type ( line_dlist ), pointer , optional :: line !--------------------------------------------------------------- Local Variables character ( 80 ) :: msg type ( line_dlist ), pointer :: mark integer ( ip ) :: lni , llist ( 1 ) !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_linteger' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( fdf_locate ( label , mark )) then if (. not . match ( mark % pline , 'la' )) then write ( msg , * ) 'no list value for ' , label call die ( 'FDF module: fdf_linteger' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif ! Retrieve length of list lni = - 1 call integerlists ( mark % pline , 1 , lni , llist ) if ( ni <= 0 ) then ! the user has requested size... ni = lni else ! the list is not long enough if ( ni < lni ) then write ( msg , '(2a,2(a,i0))' ) 'List ' , trim ( label ), & ' container too small: ' , ni , ' versus ' , lni call die ( 'FDF module: fdf_linteger' , trim ( msg ), & THIS_FILE , __ LINE__ , fdf_err ) end if call integerlists ( mark % pline , 1 , ni , list ) end if ! find a way to write out the list anyway if ( fdf_output ) write ( fdf_out , '(a,5x,i10)' ) label , lni else write ( msg , * ) 'no list value for ' , label call die ( 'FDF module: fdf_linteger' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif if ( PRESENT ( line )) line = mark RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_linteger ! !   Returns a list with label 'label', or the default !   value if label is not found in the fdf file. ! SUBROUTINE fdf_ldouble ( label , nv , list , line ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label integer ( ip ) :: nv !-------------------------------------------------------------- Output Variables real ( dp ) :: list ( nv ) type ( line_dlist ), pointer , optional :: line !--------------------------------------------------------------- Local Variables character ( 80 ) :: msg type ( line_dlist ), pointer :: mark integer ( ip ) :: lnv real ( dp ) :: llist ( 1 ) !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_ldouble' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( fdf_locate ( label , mark )) then if (. not . match ( mark % pline , 'le' )) then write ( msg , * ) 'no list value for ' , label call die ( 'FDF module: fdf_ldouble' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif ! Retrieve length of list lnv = - 1 call valuelists ( mark % pline , 1 , lnv , llist ) if ( nv <= 0 ) then ! the user has requested size... nv = lnv else ! the list is not long enough if ( nv < lnv ) then write ( msg , '(2a,2(a,i0))' ) 'List ' , trim ( label ), & ' container too small: ' , nv , ' versus ' , lnv call die ( 'FDF module: fdf_ldouble' , trim ( msg ), & THIS_FILE , __ LINE__ , fdf_err ) end if call valuelists ( mark % pline , 1 , nv , list ) end if if ( fdf_output ) write ( fdf_out , '(a,5x,i10)' ) label , lnv else write ( msg , * ) 'no list value for ' , label call die ( 'FDF module: fdf_ldouble' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif if ( PRESENT ( line )) line = mark RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_ldouble ! !   Returns a string associated with label 'label', or the default !   string if label is not found in the fdf file. !   Optionally can return a pointer to the line found. ! FUNCTION fdf_string ( label , default , line ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label character ( * ) :: default !-------------------------------------------------------------- Output Variables character ( 80 ) :: fdf_string type ( line_dlist ), pointer , optional :: line !--------------------------------------------------------------- Local Variables type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_string' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( fdf_locate ( label , mark )) then if ( ntokens ( mark % pline ) < 2 ) then fdf_string = \"\" if ( fdf_output ) write ( fdf_out , '(a,5x,a)' ) label , & \"#  *** Set to empty string *** \" else ! Get all the characters spanning the space from the second to ! the last token fdf_string = characters ( mark % pline , ind_init = 2 , ind_final =- 1 ) if ( fdf_output ) write ( fdf_out , '(a,5x,a)' ) label , fdf_string endif else fdf_string = default if ( fdf_output ) write ( fdf_out , '(a,5x,a,5x,a)' ) label , default , '# default value' endif if ( PRESENT ( line )) line = mark RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_string ! !   Returns true if label 'label' appears by itself or in the form !   label {yes,true,.true.,t,y} (case insensitive). ! !   Returns false if label 'label' appears in the form !   label {no,false,.false.,f,n} (case insensitive). ! !   If label is not found in the fdf file, fdf_boolean returns the !   LOGICAL variable default. ! !   Optionally can return a pointer to the line found. ! FUNCTION fdf_boolean ( label , default , line ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label logical :: default !-------------------------------------------------------------- Output Variables logical :: fdf_boolean type ( line_dlist ), pointer , optional :: line !--------------------------------------------------------------- Local Variables character ( 80 ) :: msg , valstr type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_boolean' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( fdf_locate ( label , mark )) then !       If the label appears by itself, we interpret it as .true. if ( ntokens ( mark % pline ) . ne . 1 ) then !         Look for second word valstr = names ( mark % pline , 1 , 1 ) if ( is_true ( valstr )) then fdf_boolean = . TRUE . if ( fdf_output ) write ( fdf_out , '(a,5x,l10)' ) label , fdf_boolean elseif ( is_false ( valstr )) then fdf_boolean = . FALSE . if ( fdf_output ) write ( fdf_out , '(a,5x,l10)' ) label , fdf_boolean else write ( msg , * ) 'unexpected logical value ' , label , ' = ' , valstr call die ( 'FDF module: fdf_boolean' , msg , & THIS_FILE , __ LINE__ , fdf_err ) endif else fdf_boolean = . TRUE . if ( fdf_output ) write ( fdf_out , '(a,5x,l10,5x,a)' ) label , fdf_boolean , & '# label by itself' endif else fdf_boolean = default if ( fdf_output ) write ( fdf_out , '(a,5x,l10,5x,a)' ) label , default , '# default value' endif if ( PRESENT ( line )) line = mark RETURN CONTAINS logical function is_true ( valstr ) result ( a ) character ( len =* ), intent ( in ) :: valstr a = leqi ( valstr , 'yes' ) . or . leqi ( valstr , 'true' ) . or . & leqi ( valstr , '.true.' ) . or . leqi ( valstr , 't' ) . or . & leqi ( valstr , 'y' ) end function is_true logical function is_false ( valstr ) result ( a ) character ( len =* ), intent ( in ) :: valstr a = leqi ( valstr , 'no' ) . or . leqi ( valstr , 'false' ) . or . & leqi ( valstr , '.false.' ) . or . leqi ( valstr , 'f' ) . or . & leqi ( valstr , 'n' ) end function is_false !--------------------------------------------------------------------------- END END FUNCTION fdf_boolean !   Block version of fdf_boolean !   Returns true if the token in position (ind+after) has the form !   {yes,true,.true.,t,y} (case insensitive). ! !   Returns false if the token has the form !   {no,false,.false.,f,n} (case insensitive). ! FUNCTION fdf_bboolean ( pline , ind , after ) implicit none !--------------------------------------------------------------- Input Variables integer ( ip ), intent ( in ) :: ind integer ( ip ), intent ( in ), optional :: after type ( parsed_line ), pointer :: pline !-------------------------------------------------------------- Output Variables logical :: fdf_bboolean !--------------------------------------------------------------- Local Variables character ( 80 ) :: msg , valstr !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_bboolean' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( ind <= nnames ( pline , after = after )) then valstr = names ( pline , ind , after = after ) if ( is_true ( valstr )) then fdf_bboolean = . TRUE . elseif ( is_false ( valstr )) then fdf_bboolean = . FALSE . else write ( msg , * ) 'unexpected logical value ' , valstr call die ( 'FDF module: fdf_bboolean' , msg , & THIS_FILE , __ LINE__ , fdf_err ) endif else write ( msg , * ) ' index value beyond number of name tokens. ' call die ( 'FDF module: fdf_bboolean:' , msg , & THIS_FILE , __ LINE__ , fdf_err ) endif RETURN CONTAINS logical function is_true ( valstr ) result ( a ) character ( len =* ), intent ( in ) :: valstr a = leqi ( valstr , 'yes' ) . or . leqi ( valstr , 'true' ) . or . & leqi ( valstr , '.true.' ) . or . leqi ( valstr , 't' ) . or . & leqi ( valstr , 'y' ) end function is_true logical function is_false ( valstr ) result ( a ) character ( len =* ), intent ( in ) :: valstr a = leqi ( valstr , 'no' ) . or . leqi ( valstr , 'false' ) . or . & leqi ( valstr , '.false.' ) . or . leqi ( valstr , 'f' ) . or . & leqi ( valstr , 'n' ) end function is_false !--------------------------------------------------------------------------- END END FUNCTION fdf_bboolean ! !   Returns a single precision value associated with label 'label', !   or the default value if label is not found in the fdf file. !   Optionally can return a pointer to the line found. !   Note that integers on the line are also accepted ! FUNCTION fdf_single ( label , default , line ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label real ( sp ) :: default !-------------------------------------------------------------- Output Variables real ( sp ) :: fdf_single type ( line_dlist ), pointer , optional :: line !--------------------------------------------------------------- Local Variables character ( 80 ) :: msg type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_single' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( fdf_locate ( label , mark )) then if (. not . match ( mark % pline , 'lv' )) then write ( msg , * ) 'no real value for ' , label call die ( 'FDF module: fdf_single' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif fdf_single = values ( mark % pline , 1 , 1 ) if ( fdf_output ) write ( fdf_out , '(a,5x,g20.10)' ) label , fdf_single else fdf_single = default if ( fdf_output ) write ( fdf_out , '(a,5x,g20.10,5x,a)' ) label , default , '# default value' endif if ( PRESENT ( line )) line = mark RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_single ! !   Returns a double precision value associated with label 'label', !   or the default value if label is not found in the fdf file. !   Optionally can return a pointer to the line found. !   Note that integers on the line are also accepted ! FUNCTION fdf_double ( label , default , line ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label real ( dp ) :: default !-------------------------------------------------------------- Output Variables real ( dp ) :: fdf_double type ( line_dlist ), pointer , optional :: line !--------------------------------------------------------------- Local Variables character ( 80 ) :: msg type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_double' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( fdf_locate ( label , mark )) then if (. not . match ( mark % pline , 'lv' )) then write ( msg , * ) 'no real value for ' , label call die ( 'FDF module: fdf_double' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif fdf_double = values ( mark % pline , 1 , 1 ) if ( fdf_output ) write ( fdf_out , '(a,5x,g20.10)' ) label , fdf_double else fdf_double = default if ( fdf_output ) write ( fdf_out , '(a,5x,g20.10,5x,a)' ) label , default , '# default value' endif if ( PRESENT ( line )) line = mark RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_double ! !   Returns a double precision value associated with label 'label', !   or the default value if label is not found in the fdf file. !   Converts the units to defunit. !   Optionally can return a pointer to the line found. ! FUNCTION fdf_physical ( label , default , defunit , line ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label , defunit real ( dp ) :: default !-------------------------------------------------------------- Output Variables real ( dp ) :: fdf_physical type ( line_dlist ), pointer , optional :: line !--------------------------------------------------------------- Local Variables character ( 50 ) :: unitstr character ( 80 ) :: msg real ( dp ) :: value type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_physical' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif !     Label found if ( fdf_locate ( label , mark )) then if (. not . match ( mark % pline , 'lv' )) then write ( msg , * ) 'no real value for ' , label call die ( 'FDF module: fdf_physical' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif !       Label with value value = values ( mark % pline , 1 , 1 ) fdf_physical = value !       Look for unit if (. not . match ( mark % pline , 'lvn' )) then write ( msg , * ) 'no unit specified for ' , label call die ( 'FDF module: fdf_physical' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif unitstr = names ( mark % pline , 1 , 2 ) !!        if (.not. leqi(unitstr, defunit)) then ! The enclosing 'if' might not be adequate if ! at some point we want to demand case-sensitivity ! or physical dimension qualifiers fdf_physical = value * fdf_convfac ( unitstr , defunit ) !!        endif if ( fdf_output ) write ( fdf_out , '(a,5x,g20.10,1x,a10)' ) label , fdf_physical , defunit if ( fdf_output ) write ( fdf_out , '(a,a,5x,g20.10,1x,a10)' ) & '# above item originally: ' , label , value , unitstr else fdf_physical = default if ( fdf_output ) write ( fdf_out , '(a,5x,g20.10,1x,a,5x,a)' ) & label , default , defunit , '# default value' endif if ( PRESENT ( line )) line = mark RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_physical !   Block version !   Returns a double precision value from a block-line !    (possibly after a certain token index) !   Converts the units to defunit. ! FUNCTION fdf_bphysical ( pline , defunit , after ) implicit none !--------------------------------------------------------------- Input Variables type ( parsed_line ), pointer :: pline character ( * ) :: defunit integer ( ip ), intent ( in ), optional :: after !-------------------------------------------------------------- Output Variables real ( dp ) :: fdf_bphysical !--------------------------------------------------------------- Local Variables character ( 10 ) :: unitstr character ( 80 ) :: msg real ( dp ) :: value type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_bphysical' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if (. not . match ( pline , 'vn' , after )) then write ( msg , * ) 'no vn spec in line: ' // trim ( pline % line ) call die ( 'FDF module: fdf_bphysical' , msg , THIS_FILE , & __ LINE__ , fdf_err ) endif ! get value in block-line value = values ( pline , 1 , after ) ! get unit in block-line unitstr = names ( pline , 1 , after ) if ( leqi ( unitstr , defunit ) ) then fdf_bphysical = value else ! The enclosing 'if' might not be adequate if ! at some point we want to demand case-sensitivity fdf_bphysical = value * fdf_convfac ( unitstr , defunit ) end if !--------------------------------------------------------------------------- END END FUNCTION fdf_bphysical function fdf_convfac ( from , to ) result ( factor ) character ( len =* ), intent ( in ) :: from , to real ( dp ) :: factor integer :: stat character ( len = 256 ) :: msg factor = wrapper_convfac ( from , to , stat , msg ) if ( stat /= 0 ) then call die ( 'FDF module: fdf_convfac' , trim ( msg ), THIS_FILE , __ LINE__ , fdf_err ) endif end function fdf_convfac function wrapper_convfac ( from , to , stat , msg ) result ( factor ) use utils , only : leqi use prec , only : dp implicit none character ( len =* ), intent ( in ) :: from , to integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: msg real ( dp ) :: factor character ( len = 20 ) :: phys_dim_to , phys_dim_from character ( len = 20 ) :: unit_name_to , unit_name_from character ( len = 40 ) :: new_from real ( dp ) :: value_to , value_from if (. not . associated ( inquire_unit )) then msg = 'no unit conversion table specified' call die ( 'FDF module: fdf_convfac' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif call inquire_unit ( to , stat , phys_dim_to , unit_name_to , value_to ) if ( stat == - 1 ) then msg = 'Unknown unit = ' // trim ( to ) RETURN else if ( stat == 1 ) then msg = 'Ambiguous unit (please fix the code to specify physical dimension) = ' // trim ( to ) RETURN endif call inquire_unit ( from , stat , phys_dim_from , unit_name_from , value_from ) if ( stat == - 1 ) then msg = 'Unknown unit = ' // trim ( from ) RETURN else if ( stat == 1 ) then ! \"from\" unit is ambiguous. if ( len_trim ( phys_dim_from ) > 0 ) then msg = 'Unit name ' // trim ( from ) // & ' is ambiguous, even with qualification.' RETURN else ! Try casting the physical dimension to that of 'to' new_from = trim ( phys_dim_to ) // \":\" // trim ( from ) call inquire_unit ( new_from , stat , phys_dim_from , unit_name_from , value_from ) if ( stat == - 1 ) then msg = 'Unit name ' // trim ( from ) // & ' is ambiguous and cast to target (' // trim ( new_from ) // ') does not exist' RETURN else if ( stat == 1 ) then msg = 'Ambiguous unit even after casting! (case sensitivity needed?) = ' & // trim ( new_from ) RETURN else ! Do nothing. endif endif else ! Do nothing. endif ! Final checks if (. not . leqi ( phys_dim_to , phys_dim_from )) then msg = \"Incompatible dimensions: \" & // trim ( phys_dim_to ) // \":\" // trim ( unit_name_to ) // \" , \" & // trim ( phys_dim_from ) // \":\" // trim ( unit_name_from ) stat = - 1 RETURN endif factor = value_from / value_to END FUNCTION wrapper_convfac ! !   Searches for label in the fdf hierarchy. If it appears the function !   returns .TRUE. and leaves mark pointer positioned at the line. !   Otherwise, it returns .FALSE. and mark points to NULL. ! FUNCTION fdf_locate ( label , mark ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label !-------------------------------------------------------------- Output Variables logical :: fdf_locate type ( line_dlist ), pointer :: mark !--------------------------------------------------------------- Local Variables character ( 80 ) :: strlabel !------------------------------------------------------------------------- BEGIN fdf_locate = . FALSE . !      if (fdf_donothing) return mark => file_in % first do while ((. not . fdf_locate ) . and . ( ASSOCIATED ( mark ))) if ( match ( mark % pline , 'l' )) then strlabel = labels ( mark % pline ) if ( labeleq ( strlabel , label , fdf_log )) then fdf_locate = . TRUE . else mark => mark % next endif else mark => mark % next endif enddo if (. not . fdf_locate ) NULLIFY ( mark ) RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_locate ! !   Returns true or false whether or not the label 'label' is !   a block. !   I.e. it returns true if the line has the form bl, if not found, or not bl !   it returns false. ! FUNCTION fdf_isblock ( label ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label !-------------------------------------------------------------- Output Variables logical :: fdf_isblock !--------------------------------------------------------------- Local Variables type ( line_dlist ), pointer :: mark character ( 80 ) :: strlabel !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_isblock' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif fdf_isblock = . false . mark => file_in % first do while ( associated ( mark ) ) !!$        if ( match(mark%pline, 'l') ) then !!$          strlabel = labels(mark%pline) !!$ !!$          if ( labeleq(strlabel, label, fdf_log) ) then !!$            ! fdf has first-encounter acceptance. !!$            ! I.e. for an input !!$            !   Label_Name 1 !!$            !   %block Label_Name !!$            !     1 !!$            !   %endblock Label_Name !!$            ! the former will be accepted first. !!$            exit !!$          end if if ( match ( mark % pline , 'bl' ) ) then strlabel = blocks ( mark % pline ) if ( labeleq ( strlabel , label , fdf_log ) ) then fdf_isblock = . true . exit end if end if mark => mark % next end do if ( fdf_output ) write ( fdf_out , '(a,5x,l10)' ) \"#:block? \" // label , fdf_isblock RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_isblock ! !   Searches for block label in the fdf hierarchy. If it appears returns !   .TRUE. and leaves block mark pointer positioned at the first line. !   Otherwise, it returns .FALSE. and block mark points to NULL. ! FUNCTION fdf_block ( label , bfdf ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label !-------------------------------------------------------------- Output Variables logical :: fdf_block type ( block_fdf ) :: bfdf !--------------------------------------------------------------- Local Variables character ( 80 ) :: strlabel !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_block' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif fdf_block = . FALSE . bfdf % mark => file_in % first do while ((. not . fdf_block ) . and . ( ASSOCIATED ( bfdf % mark ))) if ( match ( bfdf % mark % pline , 'bl' )) then strlabel = blocks ( bfdf % mark % pline ) if ( labeleq ( strlabel , label , fdf_log )) then fdf_block = . TRUE . bfdf % label = label if ( fdf_output ) write ( fdf_out , '(a,a)' ) '%block ' , TRIM ( label ) endif endif bfdf % mark => bfdf % mark % next enddo if (. not . fdf_block ) NULLIFY ( bfdf % mark ) RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_block ! !   Get successive parsed lines from block returning !   .TRUE. while more lines exist in the block bfdf. ! FUNCTION fdf_bline ( bfdf , pline ) implicit none !--------------------------------------------------------------- Input Variables type ( block_fdf ) :: bfdf !-------------------------------------------------------------- Output Variables logical :: fdf_bline type ( parsed_line ), pointer :: pline !--------------------------------------------------------------- Local Variables character ( 80 ) :: strlabel !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_bline' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if (. not . ASSOCIATED ( bfdf % mark )) then call die ( 'FDF module: fdf_bline' , 'block_fdf structure not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif fdf_bline = . TRUE . !     If we are in the head of the block move to the content if ( match ( bfdf % mark % pline , 'bl' )) then strlabel = blocks ( bfdf % mark % pline ) if ( labeleq ( strlabel , bfdf % label , fdf_log )) then bfdf % mark => bfdf % mark % next if ( fdf_output ) write ( fdf_out , '(a,a)' ) '%block ' , TRIM ( bfdf % label ) endif endif if ( match ( bfdf % mark % pline , 'el' )) then strlabel = endblocks ( bfdf % mark % pline ) if ( labeleq ( strlabel , bfdf % label , fdf_log )) then fdf_bline = . FALSE . NULLIFY ( pline ) if ( fdf_output ) write ( fdf_out , '(a,a)' ) '%endblock ' , TRIM ( bfdf % label ) endif endif if ( fdf_bline ) then if ( fdf_output ) write ( fdf_out , '(1x,a)' ) TRIM ( bfdf % mark % str ) pline => bfdf % mark % pline bfdf % mark => bfdf % mark % next endif RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_bline ! !   Backspace to the previous physical line in the block !   returning .TRUE. while more lines exist in the block bfdf. ! FUNCTION fdf_bbackspace ( bfdf , pline ) implicit none !--------------------------------------------------------------- Input Variables type ( block_fdf ) :: bfdf !-------------------------------------------------------------- Output Variables logical :: fdf_bbackspace type ( parsed_line ), pointer , optional :: pline !--------------------------------------------------------------- Local Variables character ( 80 ) :: strlabel !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_bbackspace' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if (. not . ASSOCIATED ( bfdf % mark )) then call die ( 'FDF module: fdf_bbackspace' , 'block_fdf structure not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif fdf_bbackspace = . TRUE . !     If we are in the bottom of the block move to the content if ( match ( bfdf % mark % pline , 'el' )) then strlabel = endblocks ( bfdf % mark % pline ) if ( labeleq ( strlabel , bfdf % label , fdf_log )) then bfdf % mark => bfdf % mark % prev if ( fdf_output ) write ( fdf_out , '(1x,a)' ) \"#:(Backspace to) \" // \"|\" // & TRIM ( bfdf % mark % str ) // \"|\" endif !     If we are at the head we cannot backspace else if ( match ( bfdf % mark % pline , 'bl' )) then strlabel = blocks ( bfdf % mark % pline ) if ( labeleq ( strlabel , bfdf % label , fdf_log )) then fdf_bbackspace = . FALSE . if ( fdf_output ) write ( fdf_out , '(1x,a)' ) \"#:(Cannot backspace) \" // \"|\" // & TRIM ( bfdf % mark % str ) // \"|\" endif else bfdf % mark => bfdf % mark % prev if ( fdf_output ) write ( fdf_out , '(1x,a)' ) \"#:(Backspace to) \" // \"|\" // & TRIM ( bfdf % mark % str ) // \"|\" endif if ( present ( pline ) ) pline => bfdf % mark % pline RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_bbackspace ! !   Moves the pointer of the working line (bfdf%mark) !   to the beginning of the block 'label' structure. ! SUBROUTINE fdf_brewind ( bfdf ) implicit none !-------------------------------------------------------------- Output Variables type ( block_fdf ) :: bfdf !--------------------------------------------------------------- Local Variables character ( 80 ) :: msg !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_brewind' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if (. not . ASSOCIATED ( bfdf % mark )) then call die ( 'FDF module: fdf_brewind' , 'block_fdf structure not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if (. not . fdf_block ( bfdf % label , bfdf )) then write ( msg , * ) 'Block ' , bfdf % label , ' not found in FDF structure' call die ( 'FDF module: fdf_brewind' , msg , & THIS_FILE , __ LINE__ , fdf_err ) endif RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_brewind ! !   Closes the opened block by looping the remaining lines of the working line. !   This is only needed to complete the fdf-*.log files output for direct !   usage later. It does nothing internally. ! SUBROUTINE fdf_bclose ( bfdf ) implicit none !-------------------------------------------------------------- Output Variables type ( block_fdf ) :: bfdf !--------------------------------------------------------------- Local Variables type ( parsed_line ), pointer :: pline integer ( ip ) :: i character ( 80 ) :: msg !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_bclose' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif ! Quick return (no need for errors) if ( . not . associated ( bfdf % mark ) ) return ! This should hopefully discourage compilers to optimize the loop away... i = 0 do while ( fdf_bline ( bfdf , pline ) ) i = i + fdf_bnvalues ( pline ) end do write ( msg , '(a,i10)' ) 'Block ' , i RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_bclose ! !   Count number of lines with an optional specification. !   I.e. this will read through the block and return the number of lines in the !   block which matches the morphology (morph) !   This may be used to easily digest number of non-empty lines in the block. !   Note that a match on the morphology only compares the number of ID's in !   morph. I.e. a line with 'vvvil' will match 'vvvi'. ! FUNCTION fdf_block_linecount ( label , morph ) implicit none !--------------------------------------------------------------- Input Variables character ( len =* ) :: label character ( len =* ), optional :: morph !-------------------------------------------------------------- Output Variables integer ( ip ) :: fdf_block_linecount !--------------------------------------------------------------- Local Variables type ( block_fdf ) :: bfdf type ( parsed_line ), pointer :: pline logical :: orig_fdf_output !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_block_linecount' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif ! Store the fdf_output variable (suppress writing to log) orig_fdf_output = fdf_output fdf_output = . false . ! Find the block and search for morhp fdf_block_linecount = 0 if ( fdf_block ( label , bfdf ) ) then do while ( fdf_bline ( bfdf , pline ) ) if ( present ( morph ) ) then if ( fdf_bmatch ( pline , morph ) ) then fdf_block_linecount = fdf_block_linecount + 1 end if else fdf_block_linecount = fdf_block_linecount + 1 end if end do call fdf_bclose ( bfdf ) end if ! Restore output fdf_output = orig_fdf_output if ( fdf_output ) then if ( present ( morph ) ) then write ( fdf_out , '(3a,3x,i0)' ) \"#:block-line-count? \" , & trim ( label ), ' (' // trim ( morph ) // ')' , fdf_block_linecount else write ( fdf_out , '(2a,3x,i0)' ) \"#:block-line-count? \" , & trim ( label ), fdf_block_linecount end if end if RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_block_linecount ! !   Check if label is defined ! logical FUNCTION fdf_defined ( label ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label !--------------------------------------------------------------- Local Variables type ( line_dlist ), pointer :: mark !--------------------------------------------------------------------- BEGIN ! First, check whether a single label exists: fdf_defined = fdf_locate ( label , mark ) if (. not . fdf_defined ) then ! Check whether there is a block with that label fdf_defined = fdf_isblock ( label ) endif if ( fdf_output ) then write ( fdf_out , '(a,5x,l10)' ) '#:defined? ' // label , fdf_defined endif RETURN !----------------------------------------------------------------------- END END FUNCTION fdf_defined ! !   Output levels: !   level <= 0: nothing !   level  = 1: standard ! SUBROUTINE fdf_setoutput ( level , fileout_in ) implicit none !------------------------------------------------------------- Input Variables integer ( ip ) :: level character ( len =* ), intent ( in ) :: fileout_in character ( len = 256 ) :: fileout fileout = fileout_in if ( level . le . 0 ) then if ( fdf_output ) then call io_close ( fdf_out ) fdf_output = . FALSE . endif else if (. not . fdf_output ) then call io_assign ( fdf_out ) open ( fdf_out , file = fileout , form = 'formatted' , & status = 'unknown' ) REWIND ( fdf_out ) fdf_output = . TRUE . endif endif !----------------------------------------------------------------------- END END SUBROUTINE fdf_setoutput ! !   Debugging levels: !   level <= 0: nothing !   level  = 1: standard !   level >= 2: exhaustive SUBROUTINE fdf_setdebug ( level , filedebug ) implicit none !------------------------------------------------------------- Input Variables integer ( ip ) :: level character ( len =* ) :: filedebug !----------------------------------------------------------------------- BEGIN if ( level . le . 0 ) then if ( fdf_debug ) then call io_close ( fdf_log ) fdf_debug = . FALSE . endif else if (. not . fdf_debug ) then call io_assign ( fdf_log ) open ( fdf_log , file = filedebug , form = 'formatted' , & status = 'unknown' ) REWIND ( fdf_log ) fdf_debug = . TRUE . !         Set logging/debugging info for PARSE module also call setlog ( fdf_log ) call setdebug ( 1 ) endif endif fdf_debug2 = ( level . ge . 2 ) RETURN !----------------------------------------------------------------------- END END SUBROUTINE fdf_setdebug ! !   For handling deprecated labels. !   Also there is an optional \"newlabel\" if it has been changed into !   a new label. ! subroutine fdf_deprecated ( label , newlabel ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label character ( * ) :: newlabel !------------------------------------------------------------------------- BEGIN if ( fdf_defined ( label ) ) then if ( fdf_output ) write ( fdf_out , '(a)' ) \"#**Warning: FDF symbol '\" // trim ( label ) // & \"' is deprecated.\" if ( fdf_defined ( newlabel ) ) then if ( fdf_output ) write ( fdf_out , '(a)' ) \"#           FDF symbol '\" // trim ( newlabel ) // & \"' will be used instead.\" else if ( fdf_output ) write ( fdf_out , '(a)' ) \"#           FDF symbol '\" // trim ( newlabel ) // & \"' replaces '\" // trim ( label ) // \"'.\" end if end if !--------------------------------------------------------------------------- END end subroutine fdf_deprecated ! !   For handling obsoleted labels. ! subroutine fdf_obsolete ( label ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label !------------------------------------------------------------------------- BEGIN if ( fdf_defined ( label ) ) then if ( fdf_output ) write ( fdf_out , '(a)' ) \"#**Warning: FDF symbol '\" // trim ( label ) // & \"' is obsolete.\" end if !--------------------------------------------------------------------------- END end subroutine fdf_obsolete !===================== Serialization utilities for clients subroutine fdf_serialize_struct ( buffer ) character ( len = 1 ), intent ( inout ), allocatable :: buffer (:) character ( len = SERIALIZED_LENGTH ) bufline type ( line_dlist ), pointer :: mark integer ( ip ) :: i , length , init , final integer :: nchars ! total size of serialized content if ( allocated ( buffer )) deallocate ( buffer ) nchars = file_in % nlines * SERIALIZED_LENGTH allocate ( buffer ( nchars )) mark => file_in % first do i = 1 , file_in % nlines call serialize_pline ( mark % pline , bufline , length ) init = ( i - 1 ) * SERIALIZED_LENGTH + 1 final = ( i ) * SERIALIZED_LENGTH call convert_string_to_array_of_chars ( bufline , buffer ( init : final )) mark => mark % next enddo end subroutine fdf_serialize_struct subroutine fdf_recreate_struct ( bufferFDF ) character ( len = 1 ), intent ( in ) :: bufferFDF (:) character ( len = SERIALIZED_LENGTH ) bufline type ( parsed_line ), pointer :: pline integer ( ip ) :: nlines , i , init , final nlines = size ( bufferFDF ) / SERIALIZED_LENGTH do i = 1 , nlines init = ( i - 1 ) * SERIALIZED_LENGTH + 1 final = ( i ) * SERIALIZED_LENGTH call convert_array_of_chars_to_string ( bufferFDF ( init : final ), bufline ) allocate ( pline ) call recreate_pline ( pline , bufline ) call fdf_addtoken ( pline % line , pline ) enddo end subroutine fdf_recreate_struct ! To enable client-side setting, ! notably in the case of MPI, where non-root ranks ! will not call fdf_init. ! In this case, the unit handler is nullified for ! safety. The client code is responsible for setting ! the right one. ! SUBROUTINE fdf_set_started ( status ) logical , intent ( in ) :: status fdf_started = status inquire_unit => null () end SUBROUTINE fdf_set_started ! ! Units processing ! subroutine fdf_set_unit_handler ( func ) procedure ( inquire_unit_p ) :: func inquire_unit => func end subroutine fdf_set_unit_handler subroutine fdf_get_unit_handler ( func ) procedure ( inquire_unit_p ), pointer :: func func => inquire_unit end subroutine fdf_get_unit_handler END MODULE fdf","tags":"","loc":"sourcefile/fdf.f90.html"},{"title":"fdf_set_started.F90 – libfdf","text":"Contents Subroutines fdf_set_started Source Code fdf_set_started.F90 Source Code SUBROUTINE fdf_set_started ( status ) logical , intent ( in ) :: status fdf_started = status end SUBROUTINE fdf_set_started","tags":"","loc":"sourcefile/fdf_set_started.f90.html"},{"title":"fdf_isblock.F90 – libfdf","text":"Contents Functions fdf_isblock Source Code fdf_isblock.F90 Source Code FUNCTION fdf_isblock ( label ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label !-------------------------------------------------------------- Output Variables logical :: fdf_isblock !--------------------------------------------------------------- Local Variables type ( line_dlist ), pointer :: mark character ( 80 ) :: strlabel !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_isblock' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif fdf_isblock = . false . mark => file_in % first do while ( associated ( mark ) ) !!$        if ( match(mark%pline, 'l') ) then !!$          strlabel = labels(mark%pline) !!$ !!$          if ( labeleq(strlabel, label, fdf_log) ) then !!$            ! fdf has first-encounter acceptance. !!$            ! I.e. for an input !!$            !   Label_Name 1 !!$            !   %block Label_Name !!$            !     1 !!$            !   %endblock Label_Name !!$            ! the former will be accepted first. !!$            exit !!$          end if if ( match ( mark % pline , 'bl' ) ) then strlabel = blocks ( mark % pline ) if ( labeleq ( strlabel , label , fdf_log ) ) then fdf_isblock = . true . exit end if end if mark => mark % next end do if ( fdf_output ) write ( fdf_out , '(a,5x,l10)' ) \"#:block? \" // label , fdf_isblock RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_isblock","tags":"","loc":"sourcefile/fdf_isblock.f90.html"},{"title":"fdf_obsolete.F90 – libfdf","text":"Contents Subroutines fdf_obsolete Source Code fdf_obsolete.F90 Source Code subroutine fdf_obsolete ( label ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label !------------------------------------------------------------------------- BEGIN if ( fdf_defined ( label ) ) then if ( fdf_output ) write ( fdf_out , '(a)' ) \"#**Warning: FDF symbol '\" // trim ( label ) // & \"' is obsolete.\" end if !--------------------------------------------------------------------------- END end subroutine fdf_obsolete","tags":"","loc":"sourcefile/fdf_obsolete.f90.html"},{"title":"fdf_islist.F90 – libfdf","text":"Contents Functions fdf_islist Source Code fdf_islist.F90 Source Code FUNCTION fdf_islist ( label ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label !-------------------------------------------------------------- Output Variables logical :: fdf_islist !--------------------------------------------------------------- Local Variables type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_islist' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( fdf_locate ( label , mark )) then ! if it is a list: fdf_islist = match ( mark % pline , 'le' ) else fdf_islist = . false . endif if ( fdf_output ) write ( fdf_out , '(a,5x,l10)' ) \"#:list? \" // label , fdf_islist RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_islist","tags":"","loc":"sourcefile/fdf_islist.f90.html"},{"title":"fdf_dump.F90 – libfdf","text":"Contents Subroutines fdf_dump Source Code fdf_dump.F90 Source Code SUBROUTINE fdf_dump ( label ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label !--------------------------------------------------------------- Local Variables character ( 80 ) :: msg type ( block_fdf ) :: bfdf type ( parsed_line ), pointer :: pline !------------------------------------------------------------------------- BEGIN fdf_started = . TRUE . if (. not . fdf_block ( label , bfdf )) then write ( msg , * ) 'block ' , label , 'to dump not found' call die ( 'FDF module: fdf_dump' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif !     fdf_bline prints each block line in fdf_out do while ( fdf_bline ( bfdf , pline )) enddo fdf_started = . FALSE . RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_dump","tags":"","loc":"sourcefile/fdf_dump.f90.html"},{"title":"fdf_addline.F90 – libfdf","text":"Contents Subroutines fdf_addline Source Code fdf_addline.F90 Source Code SUBROUTINE fdf_addline ( line ) implicit none !--------------------------------------------------------------- Input Variables character ( len =* ) :: line !--------------------------------------------------------------- Local Variables integer ( ip ) :: ntok type ( parsed_line ), pointer :: pline !------------------------------------------------------------------------- BEGIN !     Check if valid data (tokens, non-blank) pline => digest ( line ) call setmorphol ( 1 , 'l' , pline ) call fdf_addtoken ( line , pline ) if ( fdf_debug2 ) then write ( fdf_log , * ) '***FDF_ADDLINE********************************' write ( fdf_log , * ) 'Line:' , TRIM ( line ) write ( fdf_log , * ) '**********************************************' endif END SUBROUTINE fdf_addline","tags":"","loc":"sourcefile/fdf_addline.f90.html"},{"title":"fdf_searchlabel.F90 – libfdf","text":"Contents Functions fdf_searchlabel Source Code fdf_searchlabel.F90 Source Code FUNCTION fdf_searchlabel ( found , nelem , label , plabel ) implicit none !--------------------------------------------------------------- Input Variables integer ( ip ) :: nelem logical :: found ( nelem ) character ( * ) :: label type ( parsed_line ), pointer :: plabel !-------------------------------------------------------------- Output Variables integer ( ip ) :: fdf_searchlabel !--------------------------------------------------------------- Local Variables logical :: found_elem integer ( ip ) :: i !------------------------------------------------------------------------- BEGIN i = 1 found_elem = . FALSE . fdf_searchlabel = - 1 do while (( i . le . nelem ) . and . (. not . found_elem )) if (. not . found ( i )) then if ( labeleq ( label , tokens ( plabel , i ))) then found_elem = . TRUE . fdf_searchlabel = i endif endif i = i + 1 enddo RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_searchlabel","tags":"","loc":"sourcefile/fdf_searchlabel.f90.html"},{"title":"fdf_double.F90 – libfdf","text":"Contents Functions fdf_double Source Code fdf_double.F90 Source Code FUNCTION fdf_double ( label , default , line ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label real ( dp ) :: default !-------------------------------------------------------------- Output Variables real ( dp ) :: fdf_double type ( line_dlist ), pointer , optional :: line !--------------------------------------------------------------- Local Variables character ( 80 ) :: msg type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_double' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( fdf_locate ( label , mark )) then if (. not . match ( mark % pline , 'lv' )) then write ( msg , * ) 'no real value for ' , label call die ( 'FDF module: fdf_double' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif fdf_double = values ( mark % pline , 1 , 1 ) if ( fdf_output ) write ( fdf_out , '(a,5x,g20.10)' ) label , fdf_double else fdf_double = default if ( fdf_output ) write ( fdf_out , '(a,5x,g20.10,5x,a)' ) label , default , '# default value' endif if ( PRESENT ( line )) line = mark RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_double","tags":"","loc":"sourcefile/fdf_double.f90.html"},{"title":"set_file_names.F90 – libfdf","text":"Contents Subroutines set_file_names Source Code set_file_names.F90 Source Code SUBROUTINE set_file_names ( fileIn , fileOut , & optFileIn , optFileOut , unitIn ) ! If present, copies input arguments optFileIn/Out to fileIn/Out. ! If absent, generates In/Out file names. If unitIn is present, and it is ! a named file, returns it as fileIn. If not, it copies input to a new ! file and returns its name. If .not.present(unitIn) => unitIn=5. ! If optFileIn is present, unitIn is ignored. implicit none character ( len =* ), intent ( out ) :: & fileIn , & ! Name of file to be used as input fileOut ! Name of file to be used as output character ( len =* ), optional , intent ( in ) :: & optFileIn , & ! Optional argument with input file name optFileOut ! Optional argument with output file name integer , optional , intent ( in ) :: & unitIn ! Optional input file unit (not used if present(optFileIn)) integer :: count , ierr , iostat , iu , iuIn logical :: named , opened character ( len = MAX_LENGTH * 2 ) line character ( len = maxFileNameLength ) fileName !------------------------------------------------------------------------- BEGIN ! Find a job-specific number call system_clock ( count ) count = mod ( count , 100000 ) ! Set output file name if ( present ( optFileOut )) then if ( len ( trim ( optFileOut )) > len ( fileOut )) & call die ( 'FDF module: set_file_names' , & 'Parameter maxFileNameLength too small.' // & 'Terminating.' , THIS_FILE , __ LINE__ , fdf_err , rc = ierr ) fileOut = optFileOut else ! set a job-specific file name write ( fileOut , '(a,i5.5,a)' ) 'fdf_' , count , '.log' endif ! Set input file if ( present ( optFileIn )) then ! just copy the file name if ( len ( trim ( optFileIn )) > len ( fileIn )) & call die ( 'FDF module: set_file_names' , & 'Parameter maxFileNameLength too small.' // & 'Terminating.' , THIS_FILE , __ LINE__ , fdf_err , rc = ierr ) fileIn = optFileIn else ! find or set a file name ! Find input file unit if ( present ( unitIn )) then ! use given unit (possibly 5) iuIn = unitIn else ! assume standard input iuIn = 5 endif ! Find file name associated with given unit if ( iuIn == 5 ) then ! no valid file name fileName = ' ' else ! check if this is a named file inquire ( unit = iuIn , opened = opened ) if ( opened ) then inquire ( unit = iuIn , named = named ) if ( named ) then ! inquire file name inquire ( unit = iuIn , name = fileName ) else ! no valid file name fileName = ' ' endif ! (named) else call die ( 'FDF module: set_file_names' , 'Input unit not opened.' // & 'Terminating.' , THIS_FILE , __ LINE__ , fdf_err , rc = ierr ) endif ! (opened) endif ! (iuIn==5) ! Set input file name, possibly after copying input to it if ( fileName == ' ' ) then ! not a valid file write ( fileIn , '(a,i5.5,a)' ) & 'INPUT_TMP_' , count , '.fdf' ! new file's name call io_assign ( iu ) ! new file's unit open ( iu , file = trim ( fileIn ), form = 'formatted' ) ! open new file do read ( iuIn , iostat = iostat , fmt = '(a)' ) line ! read line from old unit if ( iostat /= 0 ) exit write ( iu , '(a)' ) trim ( line ) ! write line to new file enddo call io_close ( iu ) ! close new file else ! valid file fileIn = fileName endif ! (fileName=='stdin') endif ! (present(optFileIn)) !--------------------------------------------------------------------------- END END SUBROUTINE set_file_names","tags":"","loc":"sourcefile/set_file_names.f90.html"},{"title":"fdf_destroy.F90 – libfdf","text":"Contents Subroutines fdf_destroy Source Code fdf_destroy.F90 Source Code SUBROUTINE fdf_destroy ( fdfp ) implicit none !-------------------------------------------------------------- Output Variables type ( fdf_file ) :: fdfp !------------------------------------------------------------------------- BEGIN if ( ASSOCIATED ( fdfp % first )) call fdf_destroy_dl ( fdfp % first ) RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_destroy","tags":"","loc":"sourcefile/fdf_destroy.f90.html"},{"title":"fdf_shutdown.F90 – libfdf","text":"Contents Subroutines fdf_shutdown Source Code fdf_shutdown.F90 Source Code SUBROUTINE fdf_shutdown () implicit none !------------------------------------------------------------------------- BEGIN !$OMP SINGLE if ( fdf_started ) then call fdf_destroy ( file_in ) fdf_started = . FALSE . call io_close ( fdf_out ) endif !$OMP END SINGLE RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_shutdown","tags":"","loc":"sourcefile/fdf_shutdown.f90.html"},{"title":"fdf_defined.F90 – libfdf","text":"Contents Functions fdf_defined Source Code fdf_defined.F90 Source Code logical FUNCTION fdf_defined ( label ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label !--------------------------------------------------------------- Local Variables type ( line_dlist ), pointer :: mark !--------------------------------------------------------------------- BEGIN ! First, check whether a single label exists: fdf_defined = fdf_locate ( label , mark ) if (. not . fdf_defined ) then ! Check whether there is a block with that label fdf_defined = fdf_isblock ( label ) endif if ( fdf_output ) then write ( fdf_out , '(a,5x,l10)' ) '#:defined? ' // label , fdf_defined endif RETURN !----------------------------------------------------------------------- END END FUNCTION fdf_defined","tags":"","loc":"sourcefile/fdf_defined.f90.html"},{"title":"fdf_integer.F90 – libfdf","text":"Contents Functions fdf_integer Source Code fdf_integer.F90 Source Code FUNCTION fdf_integer ( label , default , line ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label integer ( ip ) :: default !-------------------------------------------------------------- Output Variables integer ( ip ) :: fdf_integer type ( line_dlist ), pointer , optional :: line !--------------------------------------------------------------- Local Variables character ( 80 ) :: msg type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_integer' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( fdf_locate ( label , mark )) then if (. not . match ( mark % pline , 'li' )) then write ( msg , * ) 'no integer value for ' , label call die ( 'FDF module: fdf_integer' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif fdf_integer = integers ( mark % pline , 1 , 1 ) if ( fdf_output ) write ( fdf_out , '(a,5x,i10)' ) label , fdf_integer else fdf_integer = default if ( fdf_output ) write ( fdf_out , '(a,i10,5x,a)' ) label , default , '# default value' endif if ( PRESENT ( line )) line = mark RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_integer","tags":"","loc":"sourcefile/fdf_integer.f90.html"},{"title":"fdf_removelabel.F90 – libfdf","text":"Contents Subroutines fdf_removelabel Source Code fdf_removelabel.F90 Source Code SUBROUTINE fdf_removelabel ( label ) implicit none !--------------------------------------------------------------- Input Variables character ( len =* ) :: label !--------------------------------------------------------------- Local Variables type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN do while ( fdf_locate ( label , mark ) ) if ( fdf_debug2 ) then write ( fdf_log , * ) '***FDF_REMOVELABEL*******************************' write ( fdf_log , * ) 'Line:' , TRIM ( mark % str ) write ( fdf_log , * ) 'Label:' , trim ( label ) write ( fdf_log , * ) '**********************************************' endif ! To circumvent the first/last line in the fdf-file ! we have to check for the existence of the ! first/last mark being the one removed. ! That special case *must* correct the first/last ! tokens. if ( associated ( mark , target = file_in % first ) ) then file_in % first => mark % next end if if ( associated ( mark , target = file_in % last ) ) then file_in % last => mark % prev end if ! Remove the label from the dynamic list call destroy ( mark % pline ) if ( associated ( mark % prev ) ) then mark % prev % next => mark % next end if if ( associated ( mark % next ) ) then mark % next % prev => mark % prev end if DEALLOCATE ( mark ) NULLIFY ( mark ) end do END SUBROUTINE fdf_removelabel","tags":"","loc":"sourcefile/fdf_removelabel.f90.html"},{"title":"fdf_recreate_struct.F90 – libfdf","text":"Contents Subroutines fdf_recreate_struct Source Code fdf_recreate_struct.F90 Source Code subroutine fdf_recreate_struct ( bufferFDF ) character ( len = 1 ), intent ( in ) :: bufferFDF (:) character ( len = :), allocatable :: bufline , header type ( parsed_line ), pointer :: pline integer ( ip ) :: pos , length , serial_length , ntok pos = 0 allocate ( character ( len = 11 ) :: header ) do call convert_array_of_chars_to_string ( bufferFDF ( pos + 1 : pos + 11 ), header ) read ( header , \"(1x,i5,1x,i4)\" ) length , ntok serial_length = length + 12 + 10 * ntok allocate ( character ( len = serial_length ) :: bufline ) call convert_array_of_chars_to_string ( bufferFDF ( pos + 1 : pos + serial_length ), bufline ) allocate ( pline ) call recreate_pline ( pline , bufline ) deallocate ( bufline ) call fdf_addtoken ( pline % line , pline ) pos = pos + serial_length if ( pos >= size ( bufferFDF )) EXIT enddo deallocate ( header ) end subroutine fdf_recreate_struct","tags":"","loc":"sourcefile/fdf_recreate_struct.f90.html"},{"title":"fdf_bline.F90 – libfdf","text":"Contents Functions fdf_bline Source Code fdf_bline.F90 Source Code FUNCTION fdf_bline ( bfdf , pline ) implicit none !--------------------------------------------------------------- Input Variables type ( block_fdf ) :: bfdf !-------------------------------------------------------------- Output Variables logical :: fdf_bline type ( parsed_line ), pointer :: pline !--------------------------------------------------------------- Local Variables character ( 80 ) :: strlabel !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_bline' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if (. not . ASSOCIATED ( bfdf % mark )) then call die ( 'FDF module: fdf_bline' , 'block_fdf structure not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif fdf_bline = . TRUE . !     If we are in the head of the block move to the content if ( match ( bfdf % mark % pline , 'bl' )) then strlabel = blocks ( bfdf % mark % pline ) if ( labeleq ( strlabel , bfdf % label , fdf_log )) then bfdf % mark => bfdf % mark % next if ( fdf_output ) write ( fdf_out , '(a,a)' ) '%block ' , TRIM ( bfdf % label ) endif endif if ( match ( bfdf % mark % pline , 'el' )) then strlabel = endblocks ( bfdf % mark % pline ) if ( labeleq ( strlabel , bfdf % label , fdf_log )) then fdf_bline = . FALSE . NULLIFY ( pline ) if ( fdf_output ) write ( fdf_out , '(a,a)' ) '%endblock ' , TRIM ( bfdf % label ) endif endif if ( fdf_bline ) then if ( fdf_output ) write ( fdf_out , '(1x,a)' ) TRIM ( bfdf % mark % str ) pline => bfdf % mark % pline bfdf % mark => bfdf % mark % next endif RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_bline","tags":"","loc":"sourcefile/fdf_bline.f90.html"},{"title":"is_false.F90 – libfdf","text":"Contents Functions is_false Source Code is_false.F90 Source Code logical function is_false ( valstr ) result ( a ) character ( len =* ), intent ( in ) :: valstr a = leqi ( valstr , 'no' ) . or . leqi ( valstr , 'false' ) . or . & leqi ( valstr , '.false.' ) . or . leqi ( valstr , 'f' ) . or . & leqi ( valstr , 'n' ) end function is_false","tags":"","loc":"sourcefile/is_false.f90.html"},{"title":"fdf_printfdf.F90 – libfdf","text":"Contents Subroutines fdf_printfdf Source Code fdf_printfdf.F90 Source Code SUBROUTINE fdf_printfdf () implicit none !--------------------------------------------------------------- Local Variables integer ( ip ) :: i , ntokens character * 1 :: id type ( line_dlist ), pointer :: dlp character ( len = MAX_LENGTH ) :: tok !------------------------------------------------------------------------- BEGIN dlp => file_in % first write ( fdf_log , * ) '*** FDF Memory Structure Summary: ************' do while ( ASSOCIATED ( dlp )) ntokens = dlp % pline % ntokens write ( fdf_log , * ) 'Line:' , TRIM ( dlp % str ) write ( fdf_log , * ) 'Ntokens:' , ntokens do i = 1 , ntokens tok = tokens ( dlp % pline , i ) id = dlp % pline % id ( i ) write ( fdf_log , * ) '  Token:' , trim ( tok ), '(' , dlp % pline % id ( i ), ')' enddo dlp => dlp % next enddo write ( fdf_log , * ) '**********************************************' RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_printfdf","tags":"","loc":"sourcefile/fdf_printfdf.f90.html"},{"title":"fdf_islinteger.F90 – libfdf","text":"Contents Functions fdf_islinteger Source Code fdf_islinteger.F90 Source Code FUNCTION fdf_islinteger ( label ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label !-------------------------------------------------------------- Output Variables logical :: fdf_islinteger !--------------------------------------------------------------- Local Variables type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_islinteger' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( fdf_locate ( label , mark )) then ! if it is an integer list: fdf_islinteger = match ( mark % pline , 'la' ) else fdf_islinteger = . false . endif if ( fdf_output ) write ( fdf_out , '(a,5x,l10)' ) \"#:linteger? \" // label , & fdf_islinteger RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_islinteger","tags":"","loc":"sourcefile/fdf_islinteger.f90.html"},{"title":"fdf_setdebug.F90 – libfdf","text":"Contents Subroutines fdf_setdebug Source Code fdf_setdebug.F90 Source Code SUBROUTINE fdf_setdebug ( level , filedebug ) implicit none !------------------------------------------------------------- Input Variables integer ( ip ) :: level character ( len =* ) :: filedebug !----------------------------------------------------------------------- BEGIN if ( level . le . 0 ) then if ( fdf_debug ) then call io_close ( fdf_log ) fdf_debug = . FALSE . endif else if (. not . fdf_debug ) then call io_assign ( fdf_log ) open ( fdf_log , file = filedebug , form = 'formatted' , & status = 'unknown' ) REWIND ( fdf_log ) fdf_debug = . TRUE . !         Set logging/debugging info for PARSE module also call setlog ( fdf_log ) call setdebug ( 1 ) endif endif fdf_debug2 = ( level . ge . 2 ) RETURN !----------------------------------------------------------------------- END END SUBROUTINE fdf_setdebug","tags":"","loc":"sourcefile/fdf_setdebug.f90.html"},{"title":"fdf_block.F90 – libfdf","text":"Contents Functions fdf_block Source Code fdf_block.F90 Source Code FUNCTION fdf_block ( label , bfdf ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label !-------------------------------------------------------------- Output Variables logical :: fdf_block type ( block_fdf ) :: bfdf !--------------------------------------------------------------- Local Variables character ( 80 ) :: strlabel !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_block' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif fdf_block = . FALSE . bfdf % mark => file_in % first do while ((. not . fdf_block ) . and . ( ASSOCIATED ( bfdf % mark ))) if ( match ( bfdf % mark % pline , 'bl' )) then strlabel = blocks ( bfdf % mark % pline ) if ( labeleq ( strlabel , label , fdf_log )) then fdf_block = . TRUE . bfdf % label = label if ( fdf_output ) write ( fdf_out , '(a,a)' ) '%block ' , TRIM ( label ) endif endif bfdf % mark => bfdf % mark % next enddo if (. not . fdf_block ) NULLIFY ( bfdf % mark ) RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_block","tags":"","loc":"sourcefile/fdf_block.f90.html"},{"title":"fdf_overwrite.F90 – libfdf","text":"Contents Subroutines fdf_overwrite Source Code fdf_overwrite.F90 Source Code SUBROUTINE fdf_overwrite ( line ) !--------------------------------------------------------------- Input Variables character ( len =* ) :: line !--------------------------------------------------------------- Local Variables type ( parsed_line ), pointer :: pline character ( len = MAX_LENGTH ) :: label integer :: ierr pline => digest ( line ) if ( search ( '%block' , pline ) == 1 . or . & search ( '%endblock' , pline ) == 1 ) then ! We do not allow this in a single line call die ( 'FDF module: fdf_overwrite' , 'Error overwriting block (not implemented)' , & THIS_FILE , __ LINE__ , fdf_err , rc = ierr ) else if ( search ( '%include' , pline ) == 1 ) then ! We do not allow this in a single line call die ( 'FDF module: fdf_overwrite' , 'Error overwriting flags from input file (not implemen THIS_FILE, __LINE__, fdf_err, rc=ierr) else if ( search(' < ', pline) /= -1 ) then ! We do not allow this in a single line call die(' FDF module : fdf_overwrite ', ' Error piping in overwriting ( not implemented ) ',   & THIS_FILE, __LINE__, fdf_err, rc=ierr) else label = tokens(pline,1) call setmorphol(1, ' l ', pline) call fdf_removelabel(label) ! Add token to the list of fdf-flags ! Since we add it directly we shouldn' t destroy the pline call fdf_addtoken ( line , pline ) if ( fdf_debug ) then write ( fdf_log , '(2a)' ) '---> Overwriting token: ' , trim ( label ) end if end if END SUBROUTINE fdf_overwrite","tags":"","loc":"sourcefile/fdf_overwrite.f90.html"},{"title":"fdf_serialize_struct.F90 – libfdf","text":"Contents Subroutines fdf_serialize_struct Source Code fdf_serialize_struct.F90 Source Code subroutine fdf_serialize_struct ( buffer ) character ( len = 1 ), intent ( inout ), allocatable :: buffer (:) character ( len = :), allocatable :: bufline type ( line_dlist ), pointer :: mark integer ( ip ) :: i , length , init , final integer :: nchars ! total size of serialized content if ( allocated ( buffer )) deallocate ( buffer ) ! Determine total length of buffer nchars = 0 mark => file_in % first do i = 1 , file_in % nlines call serialize_pline ( mark % pline , length = length ) nchars = nchars + length mark => mark % next enddo allocate ( buffer ( nchars )) mark => file_in % first init = 1 do i = 1 , file_in % nlines call serialize_pline ( mark % pline , bufline , length ) final = init + length - 1 call convert_string_to_array_of_chars ( bufline , buffer ( init : final )) init = init + length mark => mark % next enddo end subroutine fdf_serialize_struct","tags":"","loc":"sourcefile/fdf_serialize_struct.f90.html"},{"title":"fdf_block_linecount.F90 – libfdf","text":"Contents Functions fdf_block_linecount Source Code fdf_block_linecount.F90 Source Code FUNCTION fdf_block_linecount ( label , morph ) implicit none !--------------------------------------------------------------- Input Variables character ( len =* ) :: label character ( len =* ), optional :: morph !-------------------------------------------------------------- Output Variables integer ( ip ) :: fdf_block_linecount !--------------------------------------------------------------- Local Variables type ( block_fdf ) :: bfdf type ( parsed_line ), pointer :: pline logical :: orig_fdf_output !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_block_linecount' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif ! Store the fdf_output variable (suppress writing to log) orig_fdf_output = fdf_output fdf_output = . false . ! Find the block and search for morhp fdf_block_linecount = 0 if ( fdf_block ( label , bfdf ) ) then do while ( fdf_bline ( bfdf , pline ) ) if ( present ( morph ) ) then if ( fdf_bmatch ( pline , morph ) ) then fdf_block_linecount = fdf_block_linecount + 1 end if else fdf_block_linecount = fdf_block_linecount + 1 end if end do call fdf_bclose ( bfdf ) end if ! Restore output fdf_output = orig_fdf_output if ( fdf_output ) then if ( present ( morph ) ) then write ( fdf_out , '(3a,3x,i0)' ) \"#:block-line-count? \" , & trim ( label ), ' (' // trim ( morph ) // ')' , fdf_block_linecount else write ( fdf_out , '(2a,3x,i0)' ) \"#:block-line-count? \" , & trim ( label ), fdf_block_linecount end if end if RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_block_linecount","tags":"","loc":"sourcefile/fdf_block_linecount.f90.html"},{"title":"fdf_read.f90 – libfdf","text":"Contents Subroutines fdf_read Source Code fdf_read.f90 Source Code !   Read an input file (and include files) and builds memory !   structure that will contain the data and will help in searching ! RECURSIVE SUBROUTINE fdf_read ( filein , blocklabel ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: filein character ( * ), optional :: blocklabel !--------------------------------------------------------------- Local Variables logical :: dump logical , allocatable :: found (:) character ( 80 ) :: msg character ( len = MAX_LENGTH ) :: label , inc_file character ( len = :), allocatable :: line integer ( ip ) :: i , ierr , ntok , ind_less , nlstart type ( parsed_line ), pointer :: pline !------------------------------------------------------------------------- BEGIN !     Open reading input file call fdf_open ( filein ) !     Read each input data line if ( PRESENT ( blocklabel )) then label = blocklabel else label = ' ' endif do while ( fdf_readline ( line )) !       Check if valid data (tokens, non-blank) pline => digest ( line ) ntok = ntokens ( pline ) if ( ntok . ne . 0 ) then !         Find different special cases in the input files !         (%block, %endblock, %include, Label1 Label2 ... < Filename) !         %block directive ind_less = search ( '<' , pline ) if ( search ( '%block' , pline ) . eq . 1 ) then !           No label found in %block directive if ( ntok . eq . 1 ) then write ( msg , * ) '%block label not found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_read' , msg , & THIS_FILE , __ LINE__ , fdf_err ) endif !           %block Label < Filename [ %dump ] if ( ind_less . eq . 3 ) then if ( ntok . ge . 4 ) then !               Test if %dump is present if ( search ( '%dump' , pline ) . eq . 5 ) then dump = . TRUE . else dump = . FALSE . endif !               Add begin, body and end sections of block label = tokens ( pline , 2 ) inc_file = tokens ( pline , 4 ) call destroy ( pline ) line = '%block ' // label pline => digest ( line ) call setmorphol ( 1 , 'b' , pline ) call setmorphol ( 2 , 'l' , pline ) call fdf_addtoken ( line , pline ) nullify ( pline ) ! it is stored in line nlstart = file_in % nlines call fdf_read ( inc_file , label ) !               Warn if block 'label' is empty if (( nlstart - file_in % nlines ) . eq . 0 ) then write ( msg , * ) 'FDF module: fdf_read: block ' , & TRIM ( label ), ' is empty...' call warn ( msg ) endif line = '%endblock ' // label pline => digest ( line ) call setmorphol ( 1 , 'e' , pline ) call setmorphol ( 2 , 'l' , pline ) call fdf_addtoken ( line , pline ) nullify ( pline ) ! it is stored in line !               Dump included file to fileout if ( dump ) call fdf_dump ( label ) label = ' ' !             Filename not found in %block directive else write ( msg , * ) '%block filename not found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_read' , msg , & THIS_FILE , __ LINE__ , fdf_err ) endif !           %block Label elseif ( ind_less . eq . - 1 ) then label = tokens ( pline , 2 ) call setmorphol ( 1 , 'b' , pline ) call setmorphol ( 2 , 'l' , pline ) call fdf_addtoken ( line , pline ) nullify ( pline ) ! it is stored in line nlstart = file_in % nlines !           Bad format in %block directive else write ( msg , * ) 'Bad ''<'' %block format in ' , TRIM ( filein ) call die ( 'FDF module: fdf_read' , msg , & THIS_FILE , __ LINE__ , fdf_err ) endif !         %endblock directive elseif ( search ( '%endblock' , pline ) . eq . 1 ) then !           Check if %block exists before %endblock if ( label . eq . ' ' ) then write ( msg , * ) 'Bad %endblock found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_read' , msg , & THIS_FILE , __ LINE__ , fdf_err ) else !             Warn if block 'label' is empty if (( nlstart - file_in % nlines ) . eq . 0 ) then write ( msg , * ) 'FDF module: fdf_read: block ' , & TRIM ( label ), ' is empty...' call warn ( msg ) endif call destroy ( pline ) line = '%endblock ' // label pline => digest ( line ) call setmorphol ( 1 , 'e' , pline ) call setmorphol ( 2 , 'l' , pline ) call fdf_addtoken ( line , pline ) nullify ( pline ) ! it is stored in line label = ' ' endif !         %include Filename directive elseif ( search ( '%include' , pline ) . eq . 1 ) then !           Check if include filename is specified if ( ntok . eq . 1 ) then write ( msg , * ) 'Filename on %include not found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_read' , msg , & THIS_FILE , __ LINE__ , fdf_err ) else inc_file = tokens ( pline , 2 ) call fdf_read ( inc_file ) endif ! Clean pline (we simply insert the next file) call destroy ( pline ) !         Label1 Label2 ... < Filename directive elseif ( ind_less . ne . - 1 ) then !           Check if '<' is in a valid position if ( ind_less . eq . 1 ) then write ( msg , * ) 'Bad ''<'' found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_read' , msg , & THIS_FILE , __ LINE__ , fdf_err ) !           Check if '<' filename is specified elseif ( ind_less . eq . ntok ) then write ( msg , * ) 'Filename not found after ''<'' in ' , TRIM ( filein ) call die ( 'FDF module: fdf_read' , msg , & THIS_FILE , __ LINE__ , fdf_err ) else !             Search label(s) in Filename inc_file = tokens ( pline , ind_less + 1 ) ALLOCATE ( found ( ind_less - 1 ), stat = ierr ) if ( ierr . ne . 0 ) then call die ( 'FDF module: fdf_read' , 'Error allocating found' , & THIS_FILE , __ LINE__ , fdf_err , rc = ierr ) endif !             If label(s) not found in such Filename throw an error found = . FALSE . if (. not . fdf_readlabel ( ind_less - 1 , pline , & inc_file , found )) then i = 1 do while (( i . le . ind_less - 1 ) . and . ( found ( i ))) i = i + 1 enddo label = tokens ( pline , i ) write ( msg , * ) 'Label ' , TRIM ( label ), & ' not found in ' , TRIM ( inc_file ) call die ( 'FDF module: fdf_read' , msg , & THIS_FILE , __ LINE__ , fdf_err ) endif call destroy ( pline ) DEALLOCATE ( found ) endif !         Add remaining kind of tokens to dynamic list as labels else if ( label . eq . ' ' ) call setmorphol ( 1 , 'l' , pline ) call fdf_addtoken ( line , pline ) nullify ( pline ) ! it is stored in line endif else !         Destroy parsed_line structure if no elements call destroy ( pline ) endif enddo !     Close one level of input file if ((. not . PRESENT ( blocklabel )) . and . ( label . ne . ' ' )) then write ( msg , * ) '%endblock ' , TRIM ( label ), & ' not found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_read' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif call fdf_close () RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_read","tags":"","loc":"sourcefile/fdf_read.f90.html"},{"title":"fdf_initdata.F90 – libfdf","text":"Contents Subroutines fdf_initdata Source Code fdf_initdata.F90 Source Code SUBROUTINE fdf_initdata () implicit none !--------------------------------------------------------------- Local Variables integer ( ip ) :: ierr !------------------------------------------------------------------------- BEGIN ndepth = 0 file_in % nlines = 0 NULLIFY ( file_in % first ) NULLIFY ( file_in % last ) RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_initdata","tags":"","loc":"sourcefile/fdf_initdata.f90.html"},{"title":"fdf_ldouble.F90 – libfdf","text":"Contents Subroutines fdf_ldouble Source Code fdf_ldouble.F90 Source Code SUBROUTINE fdf_ldouble ( label , nv , list , line ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label integer ( ip ) :: nv !-------------------------------------------------------------- Output Variables real ( dp ) :: list ( nv ) type ( line_dlist ), pointer , optional :: line !--------------------------------------------------------------- Local Variables character ( 80 ) :: msg type ( line_dlist ), pointer :: mark integer ( ip ) :: lnv real ( dp ) :: llist ( 1 ) !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_ldouble' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( fdf_locate ( label , mark )) then if (. not . match ( mark % pline , 'le' )) then write ( msg , * ) 'no list value for ' , label call die ( 'FDF module: fdf_ldouble' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif ! Retrieve length of list lnv = - 1 call valuelists ( mark % pline , 1 , lnv , llist ) if ( nv <= 0 ) then ! the user has requested size... nv = lnv else ! the list is not long enough if ( nv < lnv ) then write ( msg , '(2a,2(a,i0))' ) 'List ' , trim ( label ), & ' container too small: ' , nv , ' versus ' , lnv call die ( 'FDF module: fdf_ldouble' , trim ( msg ), & THIS_FILE , __ LINE__ , fdf_err ) end if call valuelists ( mark % pline , 1 , nv , list ) end if if ( fdf_output ) write ( fdf_out , '(a,5x,i10)' ) label , lnv else write ( msg , * ) 'no list value for ' , label call die ( 'FDF module: fdf_ldouble' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif if ( PRESENT ( line )) line = mark RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_ldouble","tags":"","loc":"sourcefile/fdf_ldouble.f90.html"},{"title":"fdf_deprecated.F90 – libfdf","text":"Contents Subroutines fdf_deprecated Source Code fdf_deprecated.F90 Source Code subroutine fdf_deprecated ( label , newlabel ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label character ( * ) :: newlabel !------------------------------------------------------------------------- BEGIN if ( fdf_defined ( label ) ) then if ( fdf_output ) write ( fdf_out , '(a)' ) \"#**Warning: FDF symbol '\" // trim ( label ) // & \"' is deprecated.\" if ( fdf_defined ( newlabel ) ) then if ( fdf_output ) write ( fdf_out , '(a)' ) \"#           FDF symbol '\" // trim ( newlabel ) // & \"' will be used instead.\" else if ( fdf_output ) write ( fdf_out , '(a)' ) \"#           FDF symbol '\" // trim ( newlabel ) // & \"' replaces '\" // trim ( label ) // \"'.\" end if end if !--------------------------------------------------------------------------- END end subroutine fdf_deprecated","tags":"","loc":"sourcefile/fdf_deprecated.f90.html"},{"title":"fdf_linteger.F90 – libfdf","text":"Contents Subroutines fdf_linteger Source Code fdf_linteger.F90 Source Code SUBROUTINE fdf_linteger ( label , ni , list , line ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label integer ( ip ) :: ni !-------------------------------------------------------------- Output Variables integer ( ip ) :: list ( ni ) type ( line_dlist ), pointer , optional :: line !--------------------------------------------------------------- Local Variables character ( 80 ) :: msg type ( line_dlist ), pointer :: mark integer ( ip ) :: lni , llist ( 1 ) !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_linteger' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( fdf_locate ( label , mark )) then if (. not . match ( mark % pline , 'la' )) then write ( msg , * ) 'no list value for ' , label call die ( 'FDF module: fdf_linteger' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif ! Retrieve length of list lni = - 1 call integerlists ( mark % pline , 1 , lni , llist ) if ( ni <= 0 ) then ! the user has requested size... ni = lni else ! the list is not long enough if ( ni < lni ) then write ( msg , '(2a,2(a,i0))' ) 'List ' , trim ( label ), & ' container too small: ' , ni , ' versus ' , lni call die ( 'FDF module: fdf_linteger' , trim ( msg ), & THIS_FILE , __ LINE__ , fdf_err ) end if call integerlists ( mark % pline , 1 , ni , list ) end if ! find a way to write out the list anyway if ( fdf_output ) write ( fdf_out , '(a,5x,i10)' ) label , lni else write ( msg , * ) 'no list value for ' , label call die ( 'FDF module: fdf_linteger' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif if ( PRESENT ( line )) line = mark RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_linteger","tags":"","loc":"sourcefile/fdf_linteger.f90.html"},{"title":"fdf_set_output_file.F90 – libfdf","text":"Contents Subroutines fdf_set_output_file Source Code fdf_set_output_file.F90 Source Code SUBROUTINE fdf_set_output_file ( fileout ) implicit none !----------------------------------------------------- Input Variables character ( len =* ), intent ( in ) :: fileout !----------------------------------------------------- Local Variables character ( 256 ) :: fileouttmp !----------------------------------------------------- BEGIN call io_assign ( fdf_out ) open ( unit = fdf_out , file = TRIM ( fileout ), form = 'formatted' , & access = 'sequential' , status = 'replace' ) RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_set_output_file","tags":"","loc":"sourcefile/fdf_set_output_file.f90.html"},{"title":"fdf_bphysical.F90 – libfdf","text":"Contents Functions fdf_bphysical Source Code fdf_bphysical.F90 Source Code FUNCTION fdf_bphysical ( pline , defunit , after ) implicit none !--------------------------------------------------------------- Input Variables type ( parsed_line ), pointer :: pline character ( * ) :: defunit integer ( ip ), intent ( in ), optional :: after !-------------------------------------------------------------- Output Variables real ( dp ) :: fdf_bphysical !--------------------------------------------------------------- Local Variables character ( 10 ) :: unitstr character ( 80 ) :: msg real ( dp ) :: value type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_bphysical' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if (. not . match ( pline , 'vn' , after )) then write ( msg , * ) 'no real value for line: ' // trim ( pline % line ) call die ( 'FDF module: fdf_bphysical' , msg , THIS_FILE , & __ LINE__ , fdf_err ) endif ! get value in block-line value = values ( pline , 1 , after ) ! get unit in block-line unitstr = names ( pline , 1 , after ) if ( leqi ( unitstr , defunit ) ) then fdf_bphysical = value else fdf_bphysical = value * fdf_convfac ( unitstr , defunit ) end if !--------------------------------------------------------------------------- END END FUNCTION fdf_bphysical","tags":"","loc":"sourcefile/fdf_bphysical.f90.html"},{"title":"fdf_string.F90 – libfdf","text":"Contents Functions fdf_string Source Code fdf_string.F90 Source Code FUNCTION fdf_string ( label , default , line ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label character ( * ) :: default !-------------------------------------------------------------- Output Variables character ( 80 ) :: fdf_string type ( line_dlist ), pointer , optional :: line !--------------------------------------------------------------- Local Variables type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_string' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( fdf_locate ( label , mark )) then if ( ntokens ( mark % pline ) < 2 ) then fdf_string = \"\" if ( fdf_output ) write ( fdf_out , '(a,5x,a)' ) label , & \"#  *** Set to empty string *** \" else ! Get all the characters spanning the space from the second to ! the last token fdf_string = characters ( mark % pline , ind_init = 2 , ind_final =- 1 ) if ( fdf_output ) write ( fdf_out , '(a,5x,a)' ) label , fdf_string endif else fdf_string = default if ( fdf_output ) write ( fdf_out , '(a,5x,a,5x,a)' ) label , default , '# default value' endif if ( PRESENT ( line )) line = mark RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_string","tags":"","loc":"sourcefile/fdf_string.f90.html"},{"title":"fdf_convfac.F90 – libfdf","text":"Contents Functions fdf_convfac Source Code fdf_convfac.F90 Source Code FUNCTION fdf_convfac ( from , to ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: from , to !-------------------------------------------------------------- Output Variables real ( dp ) :: fdf_convfac !--------------------------------------------------------------- Local Variables character ( 80 ) :: msg integer ( ip ) :: iu , ifrom , ito !------------------------------------------------------------------------- BEGIN ! !     We allow case variations in the units. this could be dangerous !     (meV --> MeV!!) in real life, but not in this restricted !     field. ! README BEFORE ADDING UNITS: ! ! Units should be added through the small Python code: !   fdf_units.py ! Add the appropriate unit in the designated unit-type and ! run the python script. It will then create (to std-out) ! a drop-in replacement for the following lines. integer ( ip ), parameter :: nu = 85 character ( 8 ) :: dimm ( nu ) character ( 10 ) :: name ( nu ) real ( dp ) :: unit ( nu ) data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 1 , 3 ) / & 'mass    ' , 'g         ' , 1.d-3 , & 'mass    ' , 'kg        ' , 1.d0 , & 'mass    ' , 'amu       ' , 1.66054d-27 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 4 , 9 ) / & 'length  ' , 'm         ' , 1.d0 , & 'length  ' , 'cm        ' , 1.d-2 , & 'length  ' , 'nm        ' , 1.d-9 , & 'length  ' , 'pm        ' , 1.d-12 , & 'length  ' , 'ang       ' , 1.d-10 , & 'length  ' , 'bohr      ' , 0.529177d-10 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 10 , 19 ) / & 'energy  ' , 'j         ' , 1.d0 , & 'energy  ' , 'kj        ' , 1.d3 , & 'energy  ' , 'erg       ' , 1.d-7 , & 'energy  ' , 'mev       ' , 1.60219d-22 , & 'energy  ' , 'ev        ' , 1.60219d-19 , & 'energy  ' , 'mry       ' , 2.17991d-21 , & 'energy  ' , 'ry        ' , 2.17991d-18 , & 'energy  ' , 'mha       ' , 4.35982d-21 , & 'energy  ' , 'mhartree  ' , 4.35982d-21 , & 'energy  ' , 'ha        ' , 4.35982d-18 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 20 , 29 ) / & 'energy  ' , 'hartree   ' , 4.35982d-18 , & 'energy  ' , 'k         ' , 1.38066d-23 , & 'energy  ' , 'kelvin    ' , 1.38066d-23 , & 'energy  ' , 'kcal/mol  ' , 6.94780d-21 , & 'energy  ' , 'kj/mol    ' , 1.6606d-21 , & 'energy  ' , 'hz        ' , 6.6262d-34 , & 'energy  ' , 'thz       ' , 6.6262d-22 , & 'energy  ' , 'cm-1      ' , 1.986d-23 , & 'energy  ' , 'cm&#94;-1     ' , 1.986d-23 , & 'energy  ' , 'cm**-1    ' , 1.986d-23 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 30 , 39 ) / & 'time    ' , 's         ' , 1.d0 , & 'time    ' , 'au        ' , 2.418884326505e-17 , & 'time    ' , 'ns        ' , 1.d-9 , & 'time    ' , 'ps        ' , 1.d-12 , & 'time    ' , 'fs        ' , 1.d-15 , & 'time    ' , 'min       ' , 6 0.d0 , & 'time    ' , 'mins      ' , 6 0.d0 , & 'time    ' , 'hour      ' , 360 0.d0 , & 'time    ' , 'hours     ' , 360 0.d0 , & 'time    ' , 'day       ' , 8640 0.d0 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 40 , 40 ) / & 'time    ' , 'days      ' , 8640 0.d0 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 41 , 44 ) / & 'force   ' , 'n         ' , 1.d0 , & 'force   ' , 'ev/ang    ' , 1.60219d-9 , & 'force   ' , 'ry/bohr   ' , 4.11943d-8 , & 'force   ' , 'ha/bohr   ' , 8.23886d-08 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 45 , 54 ) / & 'pressure' , 'pa        ' , 1.d0 , & 'pressure' , 'gpa       ' , 1.d9 , & 'pressure' , 'atm       ' , 1.01325d5 , & 'pressure' , 'bar       ' , 1.d5 , & 'pressure' , 'mbar      ' , 1.d11 , & 'pressure' , 'ev/ang**3 ' , 1.60219d11 , & 'pressure' , 'ev/ang&#94;3  ' , 1.60219d11 , & 'pressure' , 'ry/bohr**3' , 1.47108d13 , & 'pressure' , 'ry/bohr&#94;3 ' , 1.47108d13 , & 'pressure' , 'ha/bohr&#94;3 ' , 2.94216d13 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 55 , 55 ) / & 'pressure' , 'ha/bohr**3' , 2.94216d13 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 56 , 59 ) / & 'surftens' , 'n/m       ' , 1.d0 , & 'surftens' , 'mn/m      ' , 1.d3 , & 'surftens' , 'dyn/cm    ' , 1.d3 , & 'surftens' , 'erg/cm**2 ' , 1.d3 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 60 , 61 ) / & 'charge  ' , 'c         ' , 1.d0 , & 'charge  ' , 'e         ' , 1.602177d-19 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 62 , 66 ) / & 'dipole  ' , 'c*m       ' , 1.d0 , & 'dipole  ' , 'd         ' , 3.33564d-30 , & 'dipole  ' , 'debye     ' , 3.33564d-30 , & 'dipole  ' , 'e*bohr    ' , 8.47835d-30 , & 'dipole  ' , 'e*ang     ' , 1.602177d-29 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 67 , 68 ) / & 'mominert' , 'kg*m**2   ' , 1.d0 , & 'mominert' , 'ry*fs**2  ' , 2.17991d-48 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 69 , 75 ) / & 'efield  ' , 'v/m       ' , 1.d0 , & 'efield  ' , 'v/nm      ' , 1.d9 , & 'efield  ' , 'v/ang     ' , 1.d10 , & 'efield  ' , 'v/bohr    ' , 1.8897268d10 , & 'efield  ' , 'ry/bohr/e ' , 2.5711273d11 , & 'efield  ' , 'ha/bohr/e ' , 5.1422546d11 , & 'efield  ' , 'har/bohr/e' , 5.1422546d11 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 76 , 77 ) / & 'angle   ' , 'deg       ' , 1.d0 , & 'angle   ' , 'rad       ' , 5.72957795d1 / data ( dimm ( iu ), name ( iu ), unit ( iu ), iu = 78 , 85 ) / & 'torque  ' , 'mev/deg   ' , 1.0d-3 , & 'torque  ' , 'mev/rad   ' , 1.745533d-5 , & 'torque  ' , 'ev/deg    ' , 1.0d0 , & 'torque  ' , 'ev/rad    ' , 1.745533d-2 , & 'torque  ' , 'mry/deg   ' , 1 3.6058d-3 , & 'torque  ' , 'mry/rad   ' , 0.237466d-3 , & 'torque  ' , 'ry/deg    ' , 1 3.6058d0 , & 'torque  ' , 'ry/rad    ' , 0.237466d0 / ifrom = 0 ito = 0 do iu = 1 , nu if ( leqi ( name ( iu ), from )) ifrom = iu if ( leqi ( name ( iu ), to )) ito = iu end do if ( ifrom . eq . 0 ) then write ( msg , * ) 'unknown unit = ' , from call die ( 'FDF module: fdf_convfac' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif if ( ito . eq . 0 ) then write ( msg , * ) 'unknown unit = ' , to call die ( 'FDF module: fdf_convfac' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif if ( leqi ( dimm ( ifrom ), dimm ( ito ))) then fdf_convfac = unit ( ifrom ) / unit ( ito ) else write ( msg , * ) 'unit''s physical dimensions don''t match: ' , & from , ', ' , to call die ( 'FDF module: fdf_convfac' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif !--------------------------------------------------------------------------- END END FUNCTION fdf_convfac","tags":"","loc":"sourcefile/fdf_convfac.f90.html"},{"title":"fdf_readline.F90 – libfdf","text":"Contents Functions fdf_readline Source Code fdf_readline.F90 Source Code FUNCTION fdf_readline ( line ) use m_read , only : get_line implicit none !-------------------------------------------------------------- Output Variables logical :: fdf_readline character ( len = :), allocatable , intent ( out ) :: line !--------------------------------------------------------------- Local Variables integer ( ip ) :: stat character ( len = 256 ) :: iomsg !------------------------------------------------------------------------- BEGIN call get_line ( fdf_in ( ndepth ), line , stat , iomsg ) if ( stat . eq . 0 ) then fdf_readline = . TRUE . if ( fdf_debug2 ) write ( fdf_log , '(a,a76)' ) 'fdf_readline > ' , line else fdf_readline = . FALSE . if ( fdf_debug2 ) write ( fdf_log , '(a,a)' ) 'fdf_readline iomsg:> ' , trim ( iomsg ) endif RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_readline","tags":"","loc":"sourcefile/fdf_readline.f90.html"},{"title":"fdf_locate.F90 – libfdf","text":"Contents Functions fdf_locate Source Code fdf_locate.F90 Source Code FUNCTION fdf_locate ( label , mark ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label !-------------------------------------------------------------- Output Variables logical :: fdf_locate type ( line_dlist ), pointer :: mark !--------------------------------------------------------------- Local Variables character ( 80 ) :: strlabel !------------------------------------------------------------------------- BEGIN fdf_locate = . FALSE . !      if (fdf_donothing) return mark => file_in % first do while ((. not . fdf_locate ) . and . ( ASSOCIATED ( mark ))) if ( match ( mark % pline , 'l' )) then strlabel = labels ( mark % pline ) if ( labeleq ( strlabel , label , fdf_log )) then fdf_locate = . TRUE . else mark => mark % next endif else mark => mark % next endif enddo if (. not . fdf_locate ) NULLIFY ( mark ) RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_locate","tags":"","loc":"sourcefile/fdf_locate.f90.html"},{"title":"fdf_open.F90 – libfdf","text":"Contents Subroutines fdf_open Source Code fdf_open.F90 Source Code SUBROUTINE fdf_open ( filename ) implicit none !-------------------------------------------------------------- Output Variables character ( * ) :: filename !--------------------------------------------------------------- Local Variables logical :: file_exists character ( 80 ) :: msg integer ( ip ) :: lun !------------------------------------------------------------------------- BEGIN ndepth = ndepth + 1 if ( ndepth . gt . maxdepth ) then call die ( 'FDF module: fdf_open' , 'Too many nested fdf files...' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( leqi ( filename , 'stdin' )) then lun = INPUT_UNIT if ( fdf_debug ) write ( fdf_log , '(a,i1,a)' ) & '---> Reading from standard input [DEPTH:' , ndepth , '] ' else call io_assign ( lun ) INQUIRE ( file = filename , exist = file_exists ) if ( file_exists ) then open ( unit = lun , file = filename , status = 'old' , form = 'formatted' ) REWIND ( lun ) if ( fdf_debug ) write ( fdf_log , '(a,i1,a,a)' ) & '---> Opened [DEPTH:' , ndepth , '] ' , TRIM ( filename ) else write ( msg , '(a,a)' ) 'Cannot open ' , TRIM ( filename ) call die ( 'FDF module: fdf_open' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif endif fdf_in ( ndepth ) = lun REWIND ( fdf_in ( ndepth )) RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_open","tags":"","loc":"sourcefile/fdf_open.f90.html"},{"title":"fdf_input.F90 – libfdf","text":"Contents Subroutines fdf_input Source Code fdf_input.F90 Source Code SUBROUTINE fdf_input ( filein ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: filein !------------------------------------------------------------------------- BEGIN call fdf_read ( filein ) if ( fdf_output ) write ( fdf_out , '(a,a,a,i3)' ) '#FDF module: Opened ' , filein , & ' for input. Unit:' , fdf_in ( 1 ) RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_input","tags":"","loc":"sourcefile/fdf_input.f90.html"},{"title":"fdf_bclose.F90 – libfdf","text":"Contents Subroutines fdf_bclose Source Code fdf_bclose.F90 Source Code SUBROUTINE fdf_bclose ( bfdf ) implicit none !-------------------------------------------------------------- Output Variables type ( block_fdf ) :: bfdf !--------------------------------------------------------------- Local Variables type ( parsed_line ), pointer :: pline integer ( ip ) :: i character ( 80 ) :: msg !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_bclose' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif ! Quick return (no need for errors) if ( . not . associated ( bfdf % mark ) ) return ! This should hopefully discourage compilers to optimize the loop away... i = 0 do while ( fdf_bline ( bfdf , pline ) ) i = i + fdf_bnvalues ( pline ) end do write ( msg , '(a,i10)' ) 'Block ' , i RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_bclose","tags":"","loc":"sourcefile/fdf_bclose.f90.html"},{"title":"fdf_single.F90 – libfdf","text":"Contents Functions fdf_single Source Code fdf_single.F90 Source Code FUNCTION fdf_single ( label , default , line ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label real ( sp ) :: default !-------------------------------------------------------------- Output Variables real ( sp ) :: fdf_single type ( line_dlist ), pointer , optional :: line !--------------------------------------------------------------- Local Variables character ( 80 ) :: msg type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_single' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( fdf_locate ( label , mark )) then if (. not . match ( mark % pline , 'lv' )) then write ( msg , * ) 'no real value for ' , label call die ( 'FDF module: fdf_single' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif fdf_single = values ( mark % pline , 1 , 1 ) if ( fdf_output ) write ( fdf_out , '(a,5x,g20.10)' ) label , fdf_single else fdf_single = default if ( fdf_output ) write ( fdf_out , '(a,5x,g20.10,5x,a)' ) label , default , '# default value' endif if ( PRESENT ( line )) line = mark RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_single","tags":"","loc":"sourcefile/fdf_single.f90.html"},{"title":"fdf_physical.F90 – libfdf","text":"Contents Functions fdf_physical Source Code fdf_physical.F90 Source Code FUNCTION fdf_physical ( label , default , defunit , line ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label , defunit real ( dp ) :: default !-------------------------------------------------------------- Output Variables real ( dp ) :: fdf_physical type ( line_dlist ), pointer , optional :: line !--------------------------------------------------------------- Local Variables character ( 10 ) :: unitstr character ( 80 ) :: msg real ( dp ) :: value type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_physical' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif !     Label found if ( fdf_locate ( label , mark )) then if (. not . match ( mark % pline , 'lv' )) then write ( msg , * ) 'no real value for ' , label call die ( 'FDF module: fdf_physical' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif !       Label with value value = values ( mark % pline , 1 , 1 ) fdf_physical = value !       Look for unit if (. not . match ( mark % pline , 'lvn' )) then write ( msg , * ) 'no unit specified for ' , label call die ( 'FDF module: fdf_physical' , msg , THIS_FILE , __ LINE__ , fdf_err ) endif unitstr = names ( mark % pline , 1 , 2 ) if (. not . leqi ( unitstr , defunit )) & fdf_physical = value * fdf_convfac ( unitstr , defunit ) if ( fdf_output ) write ( fdf_out , '(a,5x,g20.10,1x,a10)' ) label , fdf_physical , defunit if ( fdf_output ) write ( fdf_out , '(a,a,5x,g20.10,1x,a10)' ) & '# above item originally: ' , label , value , unitstr else fdf_physical = default if ( fdf_output ) write ( fdf_out , '(a,5x,g20.10,1x,a,5x,a)' ) & label , default , defunit , '# default value' endif if ( PRESENT ( line )) line = mark RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_physical","tags":"","loc":"sourcefile/fdf_physical.f90.html"},{"title":"fdf_addtoken.F90 – libfdf","text":"Contents Subroutines fdf_addtoken Source Code fdf_addtoken.F90 Source Code SUBROUTINE fdf_addtoken ( line , pline ) implicit none !--------------------------------------------------------------- Input Variables character ( len =* ) :: line type ( parsed_line ), pointer :: pline !--------------------------------------------------------------- Local Variables integer ( ip ) :: i , ierr type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN ALLOCATE ( mark , stat = ierr ) if ( ierr . ne . 0 ) then call die ( 'FDF module: fdf_addtoken' , 'Error allocating mark' , & THIS_FILE , __ LINE__ , fdf_err , rc = ierr ) endif mark % str = line mark % pline => pline NULLIFY ( mark % next ) ! Add entry at the END of structure if ( ASSOCIATED ( file_in % first )) then mark % prev => file_in % last file_in % last % next => mark else NULLIFY ( mark % prev ) file_in % first => mark endif file_in % last => mark file_in % nlines = file_in % nlines + 1 if ( fdf_debug2 ) then write ( fdf_log , * ) '***FDF_ADDTOKEN*******************************' write ( fdf_log , * ) 'Line:' , TRIM ( mark % str ) write ( fdf_log , * ) 'Ntokens:' , mark % pline % ntokens do i = 1 , mark % pline % ntokens write ( fdf_log , * ) '  Token:' , trim ( tokens ( pline , i )), & ' (' , mark % pline % id ( i ), ')' enddo write ( fdf_log , * ) '**********************************************' endif RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_addtoken","tags":"","loc":"sourcefile/fdf_addtoken.f90.html"},{"title":"fdf_isphysical.F90 – libfdf","text":"Contents Functions fdf_isphysical Source Code fdf_isphysical.F90 Source Code FUNCTION fdf_isphysical ( label ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label !-------------------------------------------------------------- Output Variables logical :: fdf_isphysical !--------------------------------------------------------------- Local Variables type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_isphysical' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( fdf_locate ( label , mark )) then fdf_isphysical = match ( mark % pline , 'lvn' ) else fdf_isphysical = . false . endif if ( fdf_output ) write ( fdf_out , '(a,5x,l10)' ) \"#:physical? \" // label , fdf_isphysical RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_isphysical","tags":"","loc":"sourcefile/fdf_isphysical.f90.html"},{"title":"fdf_brewind.F90 – libfdf","text":"Contents Subroutines fdf_brewind Source Code fdf_brewind.F90 Source Code SUBROUTINE fdf_brewind ( bfdf ) implicit none !-------------------------------------------------------------- Output Variables type ( block_fdf ) :: bfdf !--------------------------------------------------------------- Local Variables character ( 80 ) :: msg !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_brewind' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if (. not . ASSOCIATED ( bfdf % mark )) then call die ( 'FDF module: fdf_brewind' , 'block_fdf structure not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if (. not . fdf_block ( bfdf % label , bfdf )) then write ( msg , * ) 'Block ' , bfdf % label , ' not found in FDF structure' call die ( 'FDF module: fdf_brewind' , msg , & THIS_FILE , __ LINE__ , fdf_err ) endif RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_brewind","tags":"","loc":"sourcefile/fdf_brewind.f90.html"},{"title":"fdf_islreal.F90 – libfdf","text":"Contents Functions fdf_islreal Source Code fdf_islreal.F90 Source Code FUNCTION fdf_islreal ( label ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: label !-------------------------------------------------------------- Output Variables logical :: fdf_islreal !--------------------------------------------------------------- Local Variables type ( line_dlist ), pointer :: mark !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_islreal' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if ( fdf_locate ( label , mark )) then ! if it is a reallist: fdf_islreal = match ( mark % pline , 'lc' ) else fdf_islreal = . false . endif if ( fdf_output ) write ( fdf_out , '(a,5x,l10)' ) \"#:lreal? \" // label , & fdf_islreal RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_islreal","tags":"","loc":"sourcefile/fdf_islreal.f90.html"},{"title":"fdf_setoutput.F90 – libfdf","text":"Contents Subroutines fdf_setoutput Source Code fdf_setoutput.F90 Source Code SUBROUTINE fdf_setoutput ( level , fileout_in ) implicit none !------------------------------------------------------------- Input Variables integer ( ip ) :: level character ( len =* ), intent ( in ) :: fileout_in character ( len = 256 ) :: fileout fileout = fileout_in if ( level . le . 0 ) then if ( fdf_output ) then call io_close ( fdf_out ) fdf_output = . FALSE . endif else if (. not . fdf_output ) then call io_assign ( fdf_out ) open ( fdf_out , file = fileout , form = 'formatted' , & status = 'unknown' ) REWIND ( fdf_out ) fdf_output = . TRUE . endif endif !----------------------------------------------------------------------- END END SUBROUTINE fdf_setoutput","tags":"","loc":"sourcefile/fdf_setoutput.f90.html"},{"title":"fdf_readlabel.F90 – libfdf","text":"Contents Functions fdf_readlabel Source Code fdf_readlabel.F90 Source Code RECURSIVE FUNCTION fdf_readlabel ( nelem , plabel , filein , found ) result ( readlabel ) implicit none !--------------------------------------------------------------- Input Variables character ( * ) :: filein integer ( ip ) :: nelem type ( parsed_line ), pointer :: plabel !-------------------------------------------------------------- Output Variables logical :: readlabel logical :: found ( nelem ) !--------------------------------------------------------------- Local Variables logical :: dump , found_elem logical , pointer :: found_loc (:) character ( 80 ) :: msg character ( len = :), allocatable :: line character ( len = MAX_LENGTH ) :: inc_file , label integer ( ip ) :: i , ierr , ntok , ind_less , nlstart integer ( ip ) :: elem , nelem_loc integer ( ip ), pointer :: found_index (:) type ( parsed_line ), pointer :: pline !------------------------------------------------------------------------- BEGIN !     Open input file with labels call fdf_open ( filein ) !     While not reach to end of file and found all labels do while ( fdf_readline ( line ) . and . (. not . ALL ( found ))) !       Check if valid data (tokens, non-blank) pline => digest ( line ) ntok = ntokens ( pline ) if ( ntok . ne . 0 ) then !         Find different special cases in the input files !         (%block, %endblock, %include, Label1 Label2 ... < Filename) !         %block directive ind_less = search ( '<' , pline ) if ( search ( '%block' , pline ) . eq . 1 ) then !           No label found in %block directive if ( ntok . eq . 1 ) then write ( msg , * ) '%block label not found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_readlabel' , msg , & THIS_FILE , __ LINE__ , fdf_err ) endif !           %block Label < Filename [ %dump ] if ( ind_less . eq . 3 ) then if ( ntok . ge . 4 ) then !               Test if %dump is present if ( search ( '%dump' , pline ) . eq . 5 ) then dump = . TRUE . else dump = . FALSE . endif label = tokens ( pline , 2 ) elem = fdf_searchlabel ( found , nelem , label , plabel ) inc_file = tokens ( pline , 4 ) call destroy ( pline ) !               If match with any label add [begin, body, end] of block if ( elem . ne . - 1 ) then line = '%block ' // label pline => digest ( line ) call setmorphol ( 1 , 'b' , pline ) call setmorphol ( 2 , 'l' , pline ) call fdf_addtoken ( line , pline ) nlstart = file_in % nlines call fdf_read ( inc_file , label ) !                 Warn if block 'label' is empty if (( nlstart - file_in % nlines ) . eq . 0 ) then write ( msg , * ) 'FDF module: fdf_readlabel: block ' , & TRIM ( label ), ' is empty...' call warn ( msg ) endif line = '%endblock ' // label pline => digest ( line ) call setmorphol ( 1 , 'e' , pline ) call setmorphol ( 2 , 'l' , pline ) call fdf_addtoken ( line , pline ) !                 Dump included file to fileout if ( dump ) call fdf_dump ( label ) found ( elem ) = . TRUE . label = ' ' endif !             Filename not found in %block directive else write ( msg , * ) 'Filename on %block not found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_readlabel' , msg , & THIS_FILE , __ LINE__ , fdf_err ) endif !           %block Label elseif ( ind_less . eq . - 1 ) then label = tokens ( pline , 2 ) elem = fdf_searchlabel ( found , nelem , label , plabel ) found_elem = . TRUE . !             If match with any label add [begin,body,end] of block if ( elem . ne . - 1 ) then call setmorphol ( 1 , 'b' , pline ) call setmorphol ( 2 , 'l' , pline ) call fdf_addtoken ( line , pline ) nlstart = file_in % nlines found_elem = . FALSE . do while ( fdf_readline ( line ) . and . (. not . found_elem )) pline => digest ( line ) if ( ntokens ( pline ) . ne . 0 ) then if ( search ( '%endblock' , pline ) . eq . 1 ) then !                     Warn if block 'label' is empty if (( nlstart - file_in % nlines ) . eq . 0 ) then write ( msg , * ) 'FDF module: fdf_readlabel: block ' , & TRIM ( label ), ' is empty...' call warn ( msg ) endif call destroy ( pline ) line = '%endblock ' // label pline => digest ( line ) call setmorphol ( 1 , 'e' , pline ) call setmorphol ( 2 , 'l' , pline ) label = ' ' found_elem = . TRUE . found ( elem ) = . TRUE . endif call fdf_addtoken ( line , pline ) endif enddo !             Move to the end of the block else call destroy ( pline ) found_elem = . FALSE . do while ( fdf_readline ( line ) . and . (. not . found_elem )) pline => digest ( line ) if ( search ( '%endblock' , pline ) . eq . 1 ) then label = ' ' found_elem = . TRUE . endif call destroy ( pline ) enddo endif !             Error due to %endblock not found if (. not . found_elem ) then write ( msg , * ) '%endblock ' , TRIM ( label ), & ' not found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_readlabel' , msg , & THIS_FILE , __ LINE__ , fdf_err ) endif !           Bad format in %block directive else write ( msg , * ) 'Bad ''<'' %block format in ' , TRIM ( filein ) call die ( 'FDF module: fdf_readlabel' , msg , & THIS_FILE , __ LINE__ , fdf_err ) endif !         %endblock directive elseif ( search ( '%endblock' , pline ) . eq . 1 ) then !           Bad if %endblock exists before %block write ( msg , * ) 'Bad %endblock found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_readlabel' , msg , & THIS_FILE , __ LINE__ , fdf_err ) !         %include Filename directive elseif ( search ( '%include' , pline ) . eq . 1 ) then !           Check if include filename is specified if ( ntok . eq . 1 ) then write ( msg , * ) 'Filename on %include not found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_readlabel' , msg , & THIS_FILE , __ LINE__ , fdf_err ) else inc_file = tokens ( pline , 2 ) call destroy ( pline ) readlabel = fdf_readlabel ( nelem , plabel , inc_file , found ) endif !         Label1 Label2 ... < Filename directive elseif ( ind_less . ne . - 1 ) then !           Check if '<' is in a valid position if ( ind_less . eq . 1 ) then write ( msg , * ) 'Bad ''<'' found in ' , TRIM ( filein ) call die ( 'FDF module: fdf_readlabel' , msg , & THIS_FILE , __ LINE__ , fdf_err ) !           Check if '<' filename is specified elseif ( ind_less . eq . ntok ) then write ( msg , * ) 'Filename not found after ''<'' in ' , TRIM ( filein ) call die ( 'FDF module: fdf_readlabel' , msg , & THIS_FILE , __ LINE__ , fdf_err ) else !             Search label(s) in Filename line = ' ' nelem_loc = 0 ALLOCATE ( found_index ( ind_less - 1 ), stat = ierr ) if ( ierr . ne . 0 ) then call die ( 'FDF module: fdf_readlabel' , 'Error allocating found_index' , & THIS_FILE , __ LINE__ , fdf_err , rc = ierr ) endif do i = 1 , ind_less - 1 label = tokens ( pline , i ) elem = fdf_searchlabel ( found , nelem , label , plabel ) if ( elem . ne . - 1 ) then line = TRIM ( line ) // ' ' // TRIM ( label ) nelem_loc = nelem_loc + 1 found_index ( nelem_loc ) = elem endif enddo !             Process Filename if any label found if ( nelem_loc . ge . 1 ) then inc_file = tokens ( pline , ind_less + 1 ) call destroy ( pline ) ALLOCATE ( found_loc ( nelem_loc ), stat = ierr ) if ( ierr . ne . 0 ) then call die ( 'FDF module: fdf_readlabel' , 'Error allocating found_loc' , & THIS_FILE , __ LINE__ , fdf_err , rc = ierr ) endif found_loc = . FALSE . !               If label(s) not found in such Filename throw an error pline => digest ( line ) if (. not . fdf_readlabel ( nelem_loc , pline , & inc_file , found_loc )) then i = 1 do while (( i . le . nelem_loc ) . and . ( found_loc ( i ))) i = i + 1 enddo label = tokens ( pline , i ) write ( msg , * ) 'Label ' , TRIM ( label ), ' not found in ' , TRIM ( inc_file ) call die ( 'FDF module: fdf_readlabel' , msg , & THIS_FILE , __ LINE__ , fdf_err ) else !                 Merge results if all labels found do i = 1 , nelem_loc found ( found_index ( i )) = found_loc ( i ) enddo endif DEALLOCATE ( found_index ) endif DEALLOCATE ( found_loc ) call destroy ( pline ) endif !         Label [ Value ] directive else elem = fdf_searchlabel ( found , nelem , tokens ( pline , 1 ), plabel ) !           If match with any label add it if ( elem . ne . - 1 ) then call setmorphol ( 1 , 'l' , pline ) call fdf_addtoken ( line , pline ) found ( elem ) = . TRUE . else !             Destroy parsed_line structure if no label found call destroy ( pline ) endif endif else !         Destroy parsed_line structure if no label found call destroy ( pline ) endif enddo !     Close input file with labels call fdf_close () readlabel = ALL ( found ) RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_readlabel","tags":"","loc":"sourcefile/fdf_readlabel.f90.html"},{"title":"fdf_bbackspace.F90 – libfdf","text":"Contents Functions fdf_bbackspace Source Code fdf_bbackspace.F90 Source Code FUNCTION fdf_bbackspace ( bfdf , pline ) implicit none !--------------------------------------------------------------- Input Variables type ( block_fdf ) :: bfdf !-------------------------------------------------------------- Output Variables logical :: fdf_bbackspace type ( parsed_line ), pointer , optional :: pline !--------------------------------------------------------------- Local Variables character ( 80 ) :: strlabel !------------------------------------------------------------------------- BEGIN !     Prevents using FDF routines without initialize if (. not . fdf_started ) then call die ( 'FDF module: fdf_bbackspace' , 'FDF subsystem not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif if (. not . ASSOCIATED ( bfdf % mark )) then call die ( 'FDF module: fdf_bbackspace' , 'block_fdf structure not initialized' , & THIS_FILE , __ LINE__ , fdf_err ) endif fdf_bbackspace = . TRUE . !     If we are in the bottom of the block move to the content if ( match ( bfdf % mark % pline , 'el' )) then strlabel = endblocks ( bfdf % mark % pline ) if ( labeleq ( strlabel , bfdf % label , fdf_log )) then bfdf % mark => bfdf % mark % prev if ( fdf_output ) write ( fdf_out , '(1x,a)' ) \"#:(Backspace to) \" // \"|\" // & TRIM ( bfdf % mark % str ) // \"|\" endif !     If we are at the head we cannot backspace else if ( match ( bfdf % mark % pline , 'bl' )) then strlabel = blocks ( bfdf % mark % pline ) if ( labeleq ( strlabel , bfdf % label , fdf_log )) then fdf_bbackspace = . FALSE . if ( fdf_output ) write ( fdf_out , '(1x,a)' ) \"#:(Cannot backspace) \" // \"|\" // & TRIM ( bfdf % mark % str ) // \"|\" endif else bfdf % mark => bfdf % mark % prev if ( fdf_output ) write ( fdf_out , '(1x,a)' ) \"#:(Backspace to) \" // \"|\" // & TRIM ( bfdf % mark % str ) // \"|\" endif if ( present ( pline ) ) pline => bfdf % mark % pline RETURN !--------------------------------------------------------------------------- END END FUNCTION fdf_bbackspace","tags":"","loc":"sourcefile/fdf_bbackspace.f90.html"},{"title":"fdf_close.F90 – libfdf","text":"Contents Subroutines fdf_close Source Code fdf_close.F90 Source Code SUBROUTINE fdf_close () implicit none !------------------------------------------------------------------------- BEGIN if ( ndepth . ge . 1 ) then call io_close ( fdf_in ( ndepth )) if ( fdf_debug ) & write ( fdf_log , '(a,i1,a)' ) '---> Closed [DEPTH:' , ndepth , ']' ndepth = ndepth - 1 endif RETURN !--------------------------------------------------------------------------- END END SUBROUTINE fdf_close","tags":"","loc":"sourcefile/fdf_close.f90.html"},{"title":"Overview – libfdf","text":"FDF stands for Flexible Data Format, designed within the Siesta\nproject to simplify the handling of input options. It is based on\na keyword/value paradigm (including physical units when relevant), supplemented by\nblocks for arbitrarily complex blobs of data and lists. LibFDF is the official implementation of the FDF specifications for use in client codes.\nAt present the FDF format is used extensively by Siesta, and it has\nbeen an inspiration for several other code-specific input formats. New input options can be implemented very easily. When a keyword is not present\nin the FDF file the corresponding program variable is assigned a\npre-programmed default value. This enables programmers of client codes\nto insert new input statements anywhere in the code, without taking\ncare of ``reserving a slot'' in a possibly already crowded\nfixed-format input file.","tags":"","loc":"page/index.html"},{"title":"libFDF User Guide – libfdf","text":"Example The typical use of FDF in a program is exemplified by the following snippet: use precision , only : dp use fdf , only : fdf_init , fdf_get use units , only : eV ! approx 1.0/13.6 integer :: npts logical :: debug real :: energy_tol call fdf_init ( \"sample.fdf\" , \"fdf-log.out\" ) npts = fdf_get ( \"NumberOfPoints\" , 100 ) debug = fdf_get ( \"Debug\" ,. false .) energy_tol = fdf_get ( \"energy-tolerance\" , 0.01 * eV , \"Ry\" ) ... If the contents of sample.fdf are number-of-points 200\nenergy-tolerance 0.001 eV the variables npts , debug , and energy_tol will be assigned the values\n200, .false. , and 0.001/13.6 (0.001 eV in Ry), respectively. In the absence of the debug label in the fdf file, the variable has\ntaken its default value as specified in the program. Units handling The case of energy_tol merits a special discussion. It is an example of a magnitude with units.\nHere, the program works internally in Rydberg (Ry) units. The energy tolerance variable has to\nstore a Ry value, and this is specified by the last argument in the call to fdf_get .  The default\nvalue in this case is set to 0.01 eV by making use of a parameter eV exported by a units module. These unit conversions work out of the box in the current fdf implementation, through the use by default of\na legacy unit handler and table appropriate for the domain of materials physics. For general use, a\nclient program should set its own table and handler. This is exemplified in the file tests/test-units.f90 : ... use units_m , only : inquire_unit ... ! Initialize call fdf_init ( 'units-test.fdf' , 'units-test.out' ) call fdf_set_unit_handler ( inquire_unit ) ... The handler inquire_unit is passed to fdf after fdf initialization\nwith the call to fdf_set_unit_handler . From then on, fdf will set\nthe (astrophysics-related) units table for the conversions. Parallel operation When working in parallel, there is an extra step in the initialization phase ... #ifdef MPI use mpi #endif use fdf use units_m , only : inquire_unit ... if ( Node . eq . 0 ) then call fdf_init ( filein , fileout ) else ! Non-root ranks will need an extra step                                                                                endif ! #ifdef MPI call broadcast_fdf_struct ( 0 , mpi_comm_world ) #endif call fdf_set_unit_handler ( inquire_unit ) !! call fdf_set_unit_handler(fdf_legacy_unit_handler) ... to broadcast the FDF database object to all the processors.  The\nroutine broadcast_fdf_struct can be found in file broadcast_fdf_struct.F90 in the doc subdirectory of the libFDF\ndistribution. It should be general enough for most codes.  Note that\nthe unit handler should be set AFTER the broadcast operation. If no\ncustom handler is available, and the legacy units are appropriate, the\nsecond (commented out) form of the call should be used. (This is\ndifferent in MPI operation due to the danger of setting different handlers\nfor the root and non-root ranks: forgetting the call after the broadcast would\nleave the root rank with the default handler, and no handler for the rest)","tags":"","loc":"page/02_user_guide/index.html"},{"title":"Installation – libfdf","text":"Installation of libFDF with CMake cmake - S . - B_build - DCMAKE_INSTALL_PREFIX = / path / to / install / directory cmake -- build _build cmake -- build _build -- target test # To run a simple test cmake -- install _build Installation of libFDF with autotools ./configure --prefix=/path/to/install/directory\n    make\n    make check\n    make install Compiling user programs with CMake Just use the standard CMake idiom in your CMakeLists.txt file: add_executable ( your_program your_sources ) find_package ( libfdf REQUIRED ) target_link_libraries ( your_program libfdf :: libfdf ) The above assumes that the installation directory for libfdf can be\nfound by CMake. This can be achieved by adding it to the\nCMAKE_PREFIX_PATH CMake or enviroment variable: cmake -S. -B_your_build -DCMAKE_PREFIX_PATH=\"$FDF_ROOT\" .......\n    CMAKE_PREFIX_PATH=$FDF_ROOT cmake -S. -B_your_build ....... Compiling user programs using pkg-config Both the CMake and the autotools building systems install a libfdf.pc\nfile in the installation hierarchy. This file can be used by\npkg-config to determine the libfdf module path and the appropriate\nlink incantation. For autotools the modules will be in $FDF_ROOT/include and the library files in $FDF_ROOT/lib`, but with\nCMake this might vary. In all cases, assuming that PKG_CONFIG_PATH is\nset correctly, pkg-config --cflags libfdf\n   pkg-config --libs libfdf will produce the appropriate include and link strings.","tags":"","loc":"page/02_user_guide/01_installation.html"},{"title":"libFDF API – libfdf","text":"Exported types Initialization routine Main routines Label queries Scalar values Block handling Lists Access to the library's functionality is provided by importing the fdf module: use fdf which exports the interfaces to the public user-level routines and other symbols. Exported types A block handle block_fdf A parsed-line handle parsed_line Initialization routine It is necessary to call the fdf_init routine before any other operations.\nWhen working in parallel, only the master node has to call the routine (see this file for\nmore information. Main routines These perform queries and extract data from the FDF file, in accordance with the FDF specifications Label queries The routine fdf_defined returns true if a given label is present in the fdf file. Scalar values The interface fdf_get is overloaded to cover all relevant data types, and optionally handles units. Block handling Routine fdf_block returns true if a given block is present\n  in the fdf file, and also instantiates a block handle for further\n  processing. A full example of block processing can be found here . Lists A full example of list processing can be found here .","tags":"","loc":"page/02_user_guide/02_api/index.html"},{"title":"Block Handling – libfdf","text":"Scanning block contents Block content can be flexibly handled by means of a pointer\nto a derived type 'block_fdf'. Typical usage: use fdf type ( block_fdf ) :: bfdf type ( parsed_line ), pointer :: pline if ( fdf_block ( 'SomeBlock' , bfdf )) then do while ( fdf_bline ( bfdf , pline )) ( process line 'integers|reals|values|names ...' ) enddo call fdf_bclose ( bfdf ) endif The subroutine 'fdf_block' returns in 'bfdf' a structure used to read\nthe contents of the block. Routine fdf_bline returns in 'pline' a parsed version of the next\nnon-blank, non-comment line from the block, unless there are no more\nlines, in which case it returns .FALSE. and 'pline' is undefined. Routine fdf_bclose runs the remaining lines in the block and ensures\nthe log may be used as input in subsequent entries. Processing block contents Once a block line has been parsed, a number of query and data extraction\nroutines can be used: fdf_bnnames : Returns the number of strings (\"names\") in the line. fdf_bnintegers fdf_bnreals fdf_bnvalues fdf_bntokens fdf_bnames : Extracts a name from its correlative index. ... Routine fdf_bbackspace moves the internal pointer of 'block_fdf'\nstructure to the previous line returned. Routine fdf_brewind moves the internal pointer of 'block_fdf' structure\nto the beginning of the block.","tags":"","loc":"page/02_user_guide/02_api/block_handling.html"},{"title":"FDF specifications – libfdf","text":"Specifications for FDF format and its processing by libFDF Input lines are parsed and a token list is created. A token is: * Any number of characters enclosed in a matching pair of quotes ( \" , ',`). Embedded strings are not considered tokens. The quotes are removed by the parsing routine. * A string of characters from the set [A-Z,a-z,0-9] of alphanumeric characters plus $%&@_.-*/&#94;+~ (and any adjacent unmatched quotes, as in apostrophes) * The character ' < ' by itself . Examples: MeshCutoff < \"File.fdf\" 3 tokens : MeshCutoff , < , File . fdf System_Name Devil ' s staircase 3 tokens : System_Name , Devil ' s , staircase %block AtomicCoordinates %dump < coords . dat 5 tokens The characters '#', ';', and '!' signal the beginning of a comment. Any\nremaining characters on the line are discarded. Labels and directives (%block, %include, %endblock) are case-insensitive.\nLabels are also internal-separator-insensitive, by which it is understood that\nthe characters '.', '_', and '-' are removed before any comparison is made. The\nfollowing forms are then equivalent: NumberOfPoints\nnumber-of-points\nNUMBER.of.Points\n... FDF data specifications Label [ Value ] This line assigns an optional Value to Label . Value could be a token or a sequence of tokens not including '<' . ' Numerical ' routines such as fdf_integer will only use the first token , but fdf_string will return the whole list . %block Label ... ... ... # Optional comments %endblock [ Label ] This construct specifies a block of data that is to be read by the calling program after a call to fdf_block . The contents of the block are dumped to fdf_out . %block and %endblock must be the first tokens in their respective lines . %block Label < Filename [ %dump ] Opens Filename in order to read the block . If %dump appears at the * end * of the line , the contents of Filename are dumped to fdf_out . %include Filename # Comments Opens Filename and continues reading from it . Label < Filename # Comments Opens Filename and continues reading from it , ONLY if searching for Label . There is a maximum number of files that can be opened at the same time for fdf processing . Debugging and logging. By default, all the fdf requests are logged, printing the final value\nextracted (if it is the default value, it is identified as such). No debugging is done, unless the \"debug-level\" is set to a value greater\nthan zero. The most meaningful way to use this feature is to set the\ndebugging level before the fdf data structures are built. This can be\nachieved by calling the routine fdf_setdebug with the appropriate level\nand file name before the call to fdf_init.  This gives full control\nover the behavior.","tags":"","loc":"page/02_user_guide/02_api/fdf.Standard.html"},{"title":"MPI operation – libfdf","text":"For MPI operation, the \"reading node\" has to call the fdf initialization routine,\nserialize the fdf data structure, and broadcast it. Other nodes receive the\nstructure and de-serialize it. In the following snippet we assume that 0 is the\nreading node: if ( Node . eq . 0 ) then call fdf_init ( filein , fileout ) else ! endif #ifdef MPI call broadcast_fdf_struct ( 0 , mpi_comm_world ) ! ! Required in MPI operation. Choose one of the two, according ! to whether the default unit handler is fine or not !! call fdf_set_unit_handler( custom_unit_handler ) !! call fdf_set_unit_handler( fdf_legacy_unit_handler ) #endif The routine broadcast_fdf_struct can be found in file broadcast_fdf_struct.F90 in the doc directory of the fdf distribution. It should be general enough for most codes.","tags":"","loc":"page/02_user_guide/README_MPI.html"},{"title":"Developer Notes – libfdf","text":"(Documentation work in progress) Creating the database The main routine is fdf_read , which opens the main file and starts\nadding material to the fdf object.  If an %include line is found,\nthe routine calls itself again with the new file. Support for the Label ... Label < other_file idiom complicates the\ncode quite a bit, since an alternative hierarchy of possibly nested\nfile reads must be instantiated. This is done with the fdf_readlabel routine, which is also recursive and may call fdf_read again. Parsing Low-level support for all the parsing needed is provided by the parse module, which is useful in itself and could potentially be\nmade into an independent library. The basic idiom is to digest an\ninput line into tokens, tagging them as integers, reals, names\n(strings), etc. There are query functions for number of tokens of each\nkind, plus extractors for them. Also, a quite powerful match routine can be used to identify at once the structure of a line. Things to do Make a cleaner separation of the reading and querying stages Abstract some more the basic operations related to the fdf database object Use better names for some of the procedures (Maybe) Allow multiple instances of fdf-objects in a single program","tags":"","loc":"page/03_developer_notes/index.html"}]}